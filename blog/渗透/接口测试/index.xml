<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>接口测试 on mrlxl的知识库</title>
    <link>https://yuy0ung.github.io/blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</link>
    <description>Recent content in 接口测试 on mrlxl的知识库</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 11 Dec 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://yuy0ung.github.io/blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GraphQL渗透测试学习</title>
      <link>https://yuy0ung.github.io/blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/graphql%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 11 Dec 2025 00:00:00 +0800</pubDate>
      <guid>https://yuy0ung.github.io/blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/graphql%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;h1 id=&#34;浅谈graphql渗透测试&#34;&gt;浅谈GraphQL渗透测试&lt;/h1&gt;&#xA;&lt;h3 id=&#34;前置知识&#34;&gt;前置知识&lt;/h3&gt;&#xA;&lt;h4 id=&#34;graphql概念&#34;&gt;GraphQL概念&lt;/h4&gt;&#xA;&lt;p&gt;GraphQL是一个用于 API的查询语言，下面我用通俗的语言来谈谈它的特点：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;简单说，&lt;strong&gt;GraphQL 是一种“灵活取数据”的工具&lt;/strong&gt;。比如你点外卖时，可以自由组合菜品，而不用按固定套餐点。GraphQL 的作用类似：&lt;strong&gt;前端可以按需“点”数据，后端精准返回&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;那么这里就可以看出GraphQL与传统Rest API的区别了，我们同样以”点外卖“来描述：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Rest API&lt;/strong&gt;：固定套餐，比如&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;套餐A：用户信息（姓名、头像）&lt;/li&gt;&#xA;&lt;li&gt;套餐B：用户的朋友列表&lt;/li&gt;&#xA;&lt;li&gt;套餐C：用户的订单记录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;那么可以看出来它的&lt;strong&gt;局限&lt;/strong&gt;：如果你想同时要“用户姓名”和“朋友列表”，得点两次套餐（发两次请求），或者让后端临时做个新套餐（改接口）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;GraphQL&lt;/strong&gt;：自助餐，想要什么直接通过接口告诉后端，比如下面这个请求：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-graphql&#34; data-lang=&#34;graphql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 只要姓名&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;friends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 和朋友列表&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个请求能够，一次精准拿到 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;friends&lt;/code&gt; 数据，不会多拿（比如不需要头像），也不会少拿&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;通过上面的描述，我们能够知道GraphQL API与Rest API最大的区别：GraphQL 通过将数据查询和数据修改分离开来，使得客户端能够更灵活地控制所需数据的粒度和类型，并且在多个资源之间建立关系&lt;/p&gt;&#xA;&lt;h4 id=&#34;graphql查询方式&#34;&gt;GraphQL查询方式&lt;/h4&gt;&#xA;&lt;p&gt;查询方式主要有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Query&lt;/li&gt;&#xA;&lt;li&gt;Mutation&lt;/li&gt;&#xA;&lt;li&gt;Subscription&lt;/li&gt;&#xA;&lt;li&gt;Input&lt;/li&gt;&#xA;&lt;li&gt;Enum&lt;/li&gt;&#xA;&lt;li&gt;Union&lt;/li&gt;&#xA;&lt;li&gt;Interface&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;最常见的是&lt;code&gt;Query&lt;/code&gt;、&lt;code&gt;Mutation&lt;/code&gt;、&lt;code&gt;Subscription&lt;/code&gt;三种，这里简单举例：&lt;/p&gt;&#xA;&lt;h5 id=&#34;query查询&#34;&gt;Query（查询）&lt;/h5&gt;&#xA;&lt;p&gt;用于获取数据，只读取不修改：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-graphql&#34; data-lang=&#34;graphql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;操作名称&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;py&#34;&gt;可选参数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;字段名&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;py&#34;&gt;参数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;子字段&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;mutation变更&#34;&gt;Mutation（变更）&lt;/h5&gt;&#xA;&lt;p&gt;用于修改数据，属于写操作，会改变服务器状态：&lt;/p&gt;</description>
    </item>
    <item>
      <title>VUE&amp;webpack框架测试技巧</title>
      <link>https://yuy0ung.github.io/blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/vuewebpack%E6%A1%86%E6%9E%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 11 Dec 2025 00:00:00 +0800</pubDate>
      <guid>https://yuy0ung.github.io/blog/%E6%B8%97%E9%80%8F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/vuewebpack%E6%A1%86%E6%9E%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
      <description>&lt;h1 id=&#34;浅谈vuewebpack框架测试技巧&#34;&gt;浅谈VUE+webpack框架测试技巧&lt;/h1&gt;&#xA;&lt;p&gt;主要记录针对vue和webpack的测试技巧&lt;/p&gt;&#xA;&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;&#xA;&lt;p&gt;Vue.js 是一个渐进式 JavaScript 框架，用于构建用户界面，学过一点点前端便很好理解：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原生JS：要手动抓取DOM元素，用addEventListener监听点击，自己计算总价并更新页面&lt;/li&gt;&#xA;&lt;li&gt;Vue：你只要写好数据 cartItems 和 totalPrice，界面会自动跟着变化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而 Webpack 是一个模块打包工具，用于将项目中的各种资源（如 JavaScript 模块、CSS 样式文件、图片等）打包成浏览器可以识别的文件，同样很好理解：&lt;/p&gt;&#xA;&lt;p&gt;假设一个大型项目，前端的文件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;100 份JS文件&lt;/li&gt;&#xA;&lt;li&gt;50 份CSS文件&lt;/li&gt;&#xA;&lt;li&gt;200 种图片字体等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;正常加载的话可能需要浏览器发几百个请求，而Webpack可以很好的整合打包，一次性加载，显著降低请求的压力，比如说：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;你写了一个 .vue 文件（包含HTML/JS/CSS）&#xA;↓&#xA;Webpack 用 vue-loader 拆解成三部分&#xA;↓&#xA;JS部分交给Babel转译&#xA;CSS部分交给PostCSS加前缀&#xA;↓&#xA;最后合并成 1个app.js 和 1个style.css&#xA;↓&#xA;浏览器只需加载2个文件就能运行整个应用&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;框架测试&#34;&gt;框架测试&lt;/h2&gt;&#xA;&lt;p&gt;接下来分析针对vue+webpack这类网站的测试技巧&lt;/p&gt;&#xA;&lt;h3 id=&#34;特征识别&#34;&gt;特征识别&lt;/h3&gt;&#xA;&lt;p&gt;最简单就是看url中是否有&lt;code&gt;/#/&lt;/code&gt;，如果有，很可能就是vue站点&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250216012927215.png&#34; alt=&#34;image-20250216012927215&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;首先就是我们常用的浏览器插件&lt;strong&gt;Wappalyzer&lt;/strong&gt;，可以快速识别网站是否使用了webpack或vue技术：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250215182702291.png&#34; alt=&#34;image-20250215182702291&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其次学习过vue开发的就知道还有一款用于vue测试的插件&lt;strong&gt;Vue.js devtools&lt;/strong&gt;，同样可以识别网站前端是否为vue：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;正常情况下插件为灰色：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250215183018450.png&#34; alt=&#34;image-20250215183018450&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;若网站使用了vue，插件图标则会亮起：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250215183109909.png&#34; alt=&#34;image-20250215183109909&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我们也可以F12查看网页加载的js文件来判断，通常是一个或少量&lt;code&gt;app.xxx.js&lt;/code&gt;和一大堆&lt;code&gt;chunk-xxx.js&lt;/code&gt;文件：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250215184538807.png&#34; alt=&#34;image-20250215184538807&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;api接口和路由获取&#34;&gt;API接口和路由获取&lt;/h3&gt;&#xA;&lt;h4 id=&#34;常规插件&#34;&gt;常规插件&lt;/h4&gt;&#xA;&lt;p&gt;首先肯定非常方便的插件&lt;strong&gt;findsomething&lt;/strong&gt;，能将加载出的js中的路由识别并列出：&#xA;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250215185229786.png&#34; alt=&#34;image-20250215185229786&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;也有类似的其他工具，比如burp的HAE、BurpJSLinkFinder等插件&lt;/p&gt;&#xA;&lt;h4 id=&#34;js文件&#34;&gt;JS文件&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;首先查看的就是app.xxx.js，通过搜索关键字（比如&lt;code&gt;path:&amp;quot;&lt;/code&gt;）可能会找到一些路由：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250216182447777.png&#34; alt=&#34;image-20250216182447777&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;上面提到了chunk结构的打包文件，在低权限状态下，有些js不会自动加载，往往这类js可能会存在大量接口和敏感信息，一般来说可以进入app.js这类文件查看所有的chunk-xxx.js：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250216021422486.png&#34; alt=&#34;image-20250216021422486&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这里我们可以写一个脚本处理这些chunk为对应url，再进行批量访问，配合burp插件等寻找隐藏接口**（比如httpx代理到burp，配合jslinkfinder和Hae进行处理）**，可以扩大攻击面：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250216021849481.png&#34; alt=&#34;image-20250216021849481&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
